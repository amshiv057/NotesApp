{"ast":null,"code":"import { BELOW_CENTER_ANCHOR } from \"./constants\";\nimport { createHorizontalPosition } from \"./createHorizontalPosition\";\nimport { createVerticalPosition } from \"./createVerticalPosition\";\nimport { findSizingContainer } from \"./findSizingContainer\";\nimport { getElementRect } from \"./getElementRect\";\nimport { getTransformOrigin } from \"./getTransformOrigin\";\nimport { getViewportSize } from \"./getViewportSize\";\n/**\n * This is used when there is no `container` element so that some styles can\n * still be created. The main use-case for this is context menus and when the\n * `initialX` and `initialY` options have been provided.\n *\n * @internal\n * @remarks \\@since 5.0.0\n */\nvar FALLBACK_DOM_RECT = {\n  x: 0,\n  y: 0,\n  height: 0,\n  width: 0,\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0,\n  toJSON: function () {\n    // do nothing\n  }\n};\n/**\n * One of the most complicated functions in this project that will attempt to\n * position an element relative to another container element while still being\n * visible within the viewport. Below is the logical flow for attempting to fix\n * the element to the container:\n *\n * No Container: If there is no container element, return the provided x and y\n * positions and no styles since there's nothing we can use to calculate the\n * position.\n *\n * No Element: If the container was provided but the element to position does\n * not exist, return an style object containing the `left` and `top` values for\n * the container and apply as many of the positioning options as possible so\n * that the styles are \"as close as possible\" before the fixed element is added\n * to the DOM. This will also return the provided x and y positions since\n * nothing could be swapped around yet.\n *\n * Container and Element: If both the container and fixed element were provided,\n * apply all the positioning options to the `left` and `top` values of the\n * container based on the sizes of both elements.\n *\n * Now that the `left` and `top` values were applied, check to see if the\n * element is fully visible within the viewport with the provided positioning\n * options. If it is fully visible, do nothing else. If it isn't... follow the\n * next flow:\n *\n * First, check the horizontal sizes and make sure that the element is still\n * within the viewport with the provided viewwidth margin. If it isn't, first\n * try to swap only to a `right` style instead of left to see if that fixes it,\n * otherwise keep both the `left` and `right` styles.\n */\nexport function getFixedPosition(_a) {\n  var _b;\n  var container = _a.container,\n    element = _a.element,\n    _c = _a.anchor,\n    anchor = _c === void 0 ? BELOW_CENTER_ANCHOR : _c,\n    initialX = _a.initialX,\n    initialY = _a.initialY,\n    _d = _a.vwMargin,\n    vwMargin = _d === void 0 ? 16 : _d,\n    _e = _a.vhMargin,\n    vhMargin = _e === void 0 ? 16 : _e,\n    _f = _a.xMargin,\n    xMargin = _f === void 0 ? 0 : _f,\n    _g = _a.yMargin,\n    yMargin = _g === void 0 ? 0 : _g,\n    _h = _a.width,\n    widthType = _h === void 0 ? \"auto\" : _h,\n    _j = _a.preventOverlap,\n    preventOverlap = _j === void 0 ? false : _j,\n    _k = _a.transformOrigin,\n    transformOrigin = _k === void 0 ? false : _k,\n    _l = _a.disableSwapping,\n    propDisableSwapping = _l === void 0 ? false : _l,\n    _m = _a.disableVHBounds,\n    disableVHBounds = _m === void 0 ? false : _m;\n  container = findSizingContainer(container);\n  if (process.env.NODE_ENV !== \"production\") {\n    if (widthType !== \"auto\" && anchor.x !== \"center\") {\n      throw new Error('Unable to use a calculated width when the horizontal anchor is not `\"center\"`.');\n    }\n    if (preventOverlap && anchor.y !== \"above\" && anchor.y !== \"below\") {\n      throw new Error('Unable to prevent overlap when the vertical anchor is not `\"above\"` or `\"below\"`');\n    }\n  }\n  if (!element) {\n    return {\n      actualX: anchor.x,\n      actualY: anchor.y\n    };\n  }\n  var containerRect = (_b = container === null || container === void 0 ? void 0 : container.getBoundingClientRect()) !== null && _b !== void 0 ? _b : FALLBACK_DOM_RECT;\n  var vh = getViewportSize(\"height\");\n  var vw = getViewportSize(\"width\");\n  var _o = getElementRect(element),\n    height = _o.height,\n    elWidth = _o.width;\n  if (disableVHBounds) {\n    var dialog = element.closest(\"[role='dialog']\");\n    if (!dialog) {\n      initialY = (initialY !== null && initialY !== void 0 ? initialY : 0) + window.scrollY;\n    }\n  }\n  var disableSwapping = propDisableSwapping || !container;\n  var _p = createHorizontalPosition({\n      x: anchor.x,\n      vw: vw,\n      vwMargin: vwMargin,\n      xMargin: xMargin,\n      width: widthType,\n      elWidth: elWidth,\n      initialX: initialX,\n      containerRect: containerRect,\n      disableSwapping: disableSwapping\n    }),\n    left = _p.left,\n    right = _p.right,\n    width = _p.width,\n    minWidth = _p.minWidth,\n    actualX = _p.actualX;\n  var _q = createVerticalPosition({\n      y: anchor.y,\n      vh: vh,\n      vhMargin: vhMargin,\n      yMargin: yMargin,\n      initialY: initialY,\n      elHeight: height,\n      containerRect: containerRect,\n      disableSwapping: disableSwapping,\n      preventOverlap: preventOverlap,\n      disableVHBounds: disableVHBounds\n    }),\n    top = _q.top,\n    bottom = _q.bottom,\n    actualY = _q.actualY;\n  return {\n    actualX: actualX,\n    actualY: actualY,\n    style: {\n      left: left,\n      top: top,\n      right: right,\n      bottom: bottom,\n      width: width,\n      minWidth: minWidth,\n      position: disableVHBounds ? \"absolute\" : \"fixed\",\n      transformOrigin: transformOrigin ? getTransformOrigin({\n        x: actualX,\n        y: actualY\n      }) : undefined\n    }\n  };\n}","map":{"version":3,"names":["BELOW_CENTER_ANCHOR","createHorizontalPosition","createVerticalPosition","findSizingContainer","getElementRect","getTransformOrigin","getViewportSize","FALLBACK_DOM_RECT","x","y","height","width","left","right","top","bottom","toJSON","getFixedPosition","_a","container","element","_c","anchor","initialX","initialY","_d","vwMargin","_e","vhMargin","_f","xMargin","_g","yMargin","_h","widthType","_j","preventOverlap","_k","transformOrigin","_l","disableSwapping","propDisableSwapping","_m","disableVHBounds","process","env","NODE_ENV","Error","actualX","actualY","containerRect","_b","getBoundingClientRect","vh","vw","_o","elWidth","dialog","closest","window","scrollY","_p","minWidth","_q","elHeight","style","position","undefined"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\utils\\src\\positioning\\getFixedPosition.ts"],"sourcesContent":["import { BELOW_CENTER_ANCHOR } from \"./constants\";\nimport { createHorizontalPosition } from \"./createHorizontalPosition\";\nimport { createVerticalPosition } from \"./createVerticalPosition\";\nimport { findSizingContainer } from \"./findSizingContainer\";\nimport { getElementRect } from \"./getElementRect\";\nimport { getTransformOrigin } from \"./getTransformOrigin\";\nimport { getViewportSize } from \"./getViewportSize\";\nimport type { FixedPosition, FixedPositionOptions } from \"./types\";\n\n/**\n * This is used when there is no `container` element so that some styles can\n * still be created. The main use-case for this is context menus and when the\n * `initialX` and `initialY` options have been provided.\n *\n * @internal\n * @remarks \\@since 5.0.0\n */\nconst FALLBACK_DOM_RECT: DOMRect = {\n  x: 0,\n  y: 0,\n  height: 0,\n  width: 0,\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0,\n  toJSON() {\n    // do nothing\n  },\n};\n\n/**\n * One of the most complicated functions in this project that will attempt to\n * position an element relative to another container element while still being\n * visible within the viewport. Below is the logical flow for attempting to fix\n * the element to the container:\n *\n * No Container: If there is no container element, return the provided x and y\n * positions and no styles since there's nothing we can use to calculate the\n * position.\n *\n * No Element: If the container was provided but the element to position does\n * not exist, return an style object containing the `left` and `top` values for\n * the container and apply as many of the positioning options as possible so\n * that the styles are \"as close as possible\" before the fixed element is added\n * to the DOM. This will also return the provided x and y positions since\n * nothing could be swapped around yet.\n *\n * Container and Element: If both the container and fixed element were provided,\n * apply all the positioning options to the `left` and `top` values of the\n * container based on the sizes of both elements.\n *\n * Now that the `left` and `top` values were applied, check to see if the\n * element is fully visible within the viewport with the provided positioning\n * options. If it is fully visible, do nothing else. If it isn't... follow the\n * next flow:\n *\n * First, check the horizontal sizes and make sure that the element is still\n * within the viewport with the provided viewwidth margin. If it isn't, first\n * try to swap only to a `right` style instead of left to see if that fixes it,\n * otherwise keep both the `left` and `right` styles.\n */\nexport function getFixedPosition({\n  container,\n  element,\n  anchor = BELOW_CENTER_ANCHOR,\n  initialX,\n  initialY,\n  vwMargin = 16,\n  vhMargin = 16,\n  xMargin = 0,\n  yMargin = 0,\n  width: widthType = \"auto\",\n  preventOverlap = false,\n  transformOrigin = false,\n  disableSwapping: propDisableSwapping = false,\n  disableVHBounds = false,\n}: FixedPositionOptions): FixedPosition {\n  container = findSizingContainer(container);\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (widthType !== \"auto\" && anchor.x !== \"center\") {\n      throw new Error(\n        'Unable to use a calculated width when the horizontal anchor is not `\"center\"`.'\n      );\n    }\n\n    if (preventOverlap && anchor.y !== \"above\" && anchor.y !== \"below\") {\n      throw new Error(\n        'Unable to prevent overlap when the vertical anchor is not `\"above\"` or `\"below\"`'\n      );\n    }\n  }\n\n  if (!element) {\n    return {\n      actualX: anchor.x,\n      actualY: anchor.y,\n    };\n  }\n\n  const containerRect = container?.getBoundingClientRect() ?? FALLBACK_DOM_RECT;\n  const vh = getViewportSize(\"height\");\n  const vw = getViewportSize(\"width\");\n\n  const { height, width: elWidth } = getElementRect(element);\n  if (disableVHBounds) {\n    const dialog = element.closest(\"[role='dialog']\");\n    if (!dialog) {\n      initialY = (initialY ?? 0) + window.scrollY;\n    }\n  }\n\n  const disableSwapping = propDisableSwapping || !container;\n\n  const { left, right, width, minWidth, actualX } = createHorizontalPosition({\n    x: anchor.x,\n    vw,\n    vwMargin,\n    xMargin,\n    width: widthType,\n    elWidth,\n    initialX,\n    containerRect,\n    disableSwapping,\n  });\n  const { top, bottom, actualY } = createVerticalPosition({\n    y: anchor.y,\n    vh,\n    vhMargin,\n    yMargin,\n    initialY,\n    elHeight: height,\n    containerRect,\n    disableSwapping,\n    preventOverlap,\n    disableVHBounds,\n  });\n\n  return {\n    actualX,\n    actualY,\n    style: {\n      left,\n      top,\n      right,\n      bottom,\n      width,\n      minWidth,\n      position: disableVHBounds ? \"absolute\" : \"fixed\",\n      transformOrigin: transformOrigin\n        ? getTransformOrigin({ x: actualX, y: actualY })\n        : undefined,\n    },\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}