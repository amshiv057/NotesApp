{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { useCallback, useRef } from \"react\";\nimport { JumpMovementKey, MovementPresets, scrollIntoView, useActiveDescendantMovement, useIsUserInteractionMode } from \"@react-md/utils\";\nimport { useFlattenedTreeList } from \"./useFlattenedTreeList\";\nimport { useNestedTreeList } from \"./useNestedTreeList\";\n/**\n * This is a temporary workaround for allowing the navigation tree to scroll\n * correctly with keyboard movement since it manually sets the\n * `overflow: visible` which prevents scrolling. I'll need to think of a better\n * way to find/get the scrollable element (if any). It might also just go into\n * the `scrollIntoView` util.\n *\n * @remarks \\@since 2.5.3\n * @internal\n */\nvar getScrollContainer = function (target) {\n  if (target.classList.contains(\"rmd-layout-tree\")) {\n    return target.parentElement;\n  }\n  return target;\n};\n/**\n * This hook handles all the complex and \"fun\" stuff for selecting keyboard\n * accessibility within a tree and enabling keyboard movement, selection, and\n * expansion.\n *\n * @internal\n */\nexport function useTreeMovement(_a) {\n  var id = _a.id,\n    data = _a.data,\n    rootId = _a.rootId,\n    sort = _a.sort,\n    onBlur = _a.onBlur,\n    onFocus = _a.onFocus,\n    onKeyDown = _a.onKeyDown,\n    multiSelect = _a.multiSelect,\n    selectedIds = _a.selectedIds,\n    onItemSelect = _a.onItemSelect,\n    onMultiItemSelect = _a.onMultiItemSelect,\n    expandedIds = _a.expandedIds,\n    onItemExpansion = _a.onItemExpansion,\n    onMultiItemExpansion = _a.onMultiItemExpansion,\n    valueKey = _a.valueKey,\n    getItemValue = _a.getItemValue;\n  var items = useNestedTreeList(data, sort, rootId);\n  var _b = __read(useFlattenedTreeList({\n      id: id,\n      items: items,\n      expandedIds: expandedIds,\n      rootId: rootId,\n      valueKey: valueKey,\n      getItemValue: getItemValue\n    }), 3),\n    visibleItems = _b[0],\n    itemIdRefs = _b[1],\n    flattenedItems = _b[2];\n  var isKeyboard = useIsUserInteractionMode(\"keyboard\");\n  var _c = useActiveDescendantMovement(__assign(__assign({}, MovementPresets.VERTICAL_TREE), {\n      items: visibleItems,\n      baseId: id,\n      getId: function (_baseId, index) {\n        return (visibleItems[index] || {\n          id: \"\"\n        }).id;\n      },\n      onSpace: function (focusedIndex) {\n        var item = visibleItems[focusedIndex];\n        if (!item) {\n          return;\n        }\n        var itemId = item.itemId;\n        onItemSelect(itemId);\n      },\n      onChange: function (data) {\n        var index = data.index,\n          target = data.target,\n          query = data.query;\n        var itemId = visibleItems[index].itemId;\n        // Note: have to do a custom `scrollIntoView` here instead of relying on\n        // the `useActiveDescendantMovement`'s `scrollIntoView` because of how the\n        // tree renders with the ref behavior.\n        var item = itemIdRefs[itemId].ref.current;\n        var container = getScrollContainer(target);\n        if (item && container && container.scrollHeight > container.offsetHeight) {\n          scrollIntoView(container, item);\n        }\n        if (!multiSelect) {\n          return;\n        }\n        var isToStart = query.endsWith(JumpMovementKey.ControlShiftHome);\n        var isToEnd = query.endsWith(JumpMovementKey.ControlShiftEnd);\n        if (!isToStart && !isToEnd) {\n          return;\n        }\n        var start = isToStart ? 0 : focusedIndex;\n        var end = isToStart ? focusedIndex + 1 : undefined;\n        var jumpSelectedIds = visibleItems.slice(start, end).map(function (_a) {\n          var itemId = _a.itemId;\n          return itemId;\n        });\n        var uniqueSelectedIds = Array.from(new Set(__spreadArray(__spreadArray([], __read(selectedIds), false), __read(jumpSelectedIds), false)));\n        if (selectedIds.length !== uniqueSelectedIds.length) {\n          onMultiItemSelect(uniqueSelectedIds);\n        }\n      },\n      onKeyDown: function (event) {\n        var _a, _b, _c, _d;\n        if (onKeyDown) {\n          onKeyDown(event);\n        }\n        var item = visibleItems[focusedIndex];\n        if (!item) {\n          return;\n        }\n        var itemId = item.itemId,\n          parentId = item.parentId,\n          isParent = item.isParent;\n        switch (event.key) {\n          case \"Enter\":\n            {\n              if (isParent) {\n                onItemExpansion(itemId, !expandedIds.includes(itemId));\n                return;\n              }\n              var node = itemIdRefs[itemId].ref.current;\n              var anchor = node && node.getAttribute(\"role\") === \"none\" && node.querySelector(\"a[href]\");\n              if (!anchor) {\n                onItemSelect(itemId);\n                return;\n              }\n              // if a user is navigating through the app with a keyboard and presses\n              // cmd+shift+enter (Mac) or ctrl+shift+enter (Windows), the link will\n              // be forcefully opened in a new tab irregardless of the target\n              // attribute on the anchor tag. Since a tree doesn't actually focus\n              // the link in this case, need to \"polyfill\" it with this workaround.\n              // the `meta` key is for Mac and `ctrlKey` for Windows\n              var forceNewTab = event.shiftKey && (event.metaKey || event.ctrlKey);\n              var prevTarget = anchor.target;\n              if (forceNewTab) {\n                anchor.target = \"_blank\";\n              }\n              anchor.click();\n              if (forceNewTab) {\n                anchor.target = prevTarget;\n              }\n              break;\n            }\n          case \"ArrowRight\":\n            if (!isParent) {\n              return;\n            }\n            if (!expandedIds.includes(itemId)) {\n              onItemExpansion(itemId, true);\n            } else {\n              var nextIndex = focusedIndex + 1;\n              var nextItem = (_b = itemIdRefs[(_a = visibleItems[nextIndex]) === null || _a === void 0 ? void 0 : _a.itemId]) === null || _b === void 0 ? void 0 : _b.ref.current;\n              setFocusedIndex(nextIndex);\n              scrollIntoView(event.currentTarget, nextItem);\n            }\n            break;\n          case \"ArrowLeft\":\n            if (isParent && expandedIds.includes(itemId)) {\n              onItemExpansion(itemId, false);\n            } else if (parentId !== rootId) {\n              var parentIndex = visibleItems.findIndex(function (item) {\n                return item.itemId === parentId;\n              });\n              var parentItem = (_d = itemIdRefs[(_c = visibleItems[parentIndex]) === null || _c === void 0 ? void 0 : _c.itemId]) === null || _d === void 0 ? void 0 : _d.ref.current;\n              setFocusedIndex(parentIndex);\n              scrollIntoView(event.currentTarget, parentItem);\n            }\n            break;\n          case \"a\":\n            {\n              if (!multiSelect || !event.ctrlKey) {\n                return;\n              }\n              event.preventDefault();\n              var allItemIds = visibleItems.map(function (_a) {\n                var itemId = _a.itemId;\n                return itemId;\n              });\n              if (selectedIds.length === allItemIds.length) {\n                onMultiItemSelect([]);\n              } else {\n                onMultiItemSelect(allItemIds);\n              }\n              break;\n            }\n          case \"*\":\n            {\n              var item_1 = visibleItems[focusedIndex];\n              if (!item_1) {\n                return;\n              }\n              var expectedExpandedIds = visibleItems.filter(function (_a) {\n                var isParent = _a.isParent,\n                  parentId = _a.parentId;\n                return isParent && parentId === item_1.parentId;\n              }).map(function (_a) {\n                var itemId = _a.itemId;\n                return itemId;\n              });\n              var nextIds = Array.from(new Set(__spreadArray(__spreadArray([], __read(expandedIds), false), __read(expectedExpandedIds), false)));\n              if (nextIds.length !== expandedIds.length) {\n                onMultiItemExpansion(nextIds);\n                // since new items will be rendered, need to also update the focused\n                // index so the currently active item is still the \"focused\" item\n                //\n                // TODO: Look into a much better way to handle this sort of stuff..\n                // This still doesn't correctly scroll the active element into view.\n                // I should probably move all the scroll behavior into a useEffect\n                // for whenever the focusedIndex changes.\n                var visibleCount = 0;\n                var lookup = {};\n                for (var i = 0; i < flattenedItems.length; i += 1) {\n                  var item_2 = flattenedItems[i];\n                  var isVisible = item_2.parentId === rootId;\n                  if (item_2.parentId !== null && nextIds.includes(item_2.parentId)) {\n                    isVisible = !!lookup[item_2.parentId];\n                  }\n                  lookup[item_2.itemId] = isVisible;\n                  if (itemId === item_2.itemId) {\n                    setFocusedIndex(visibleCount);\n                    return;\n                  }\n                  if (isVisible) {\n                    visibleCount += 1;\n                  }\n                }\n              }\n            }\n          // no default\n        }\n      }\n    })),\n    activeId = _c.activeId,\n    handleKeyDown = _c.onKeyDown,\n    focusedIndex = _c.focusedIndex,\n    setFocusedIndex = _c.setFocusedIndex;\n  var lastFocus = useRef(0);\n  var handleBlur = useCallback(function (event) {\n    if (onBlur) {\n      onBlur(event);\n    }\n    if (document.activeElement && event.currentTarget.contains(document.activeElement)) {\n      return;\n    }\n    lastFocus.current = focusedIndex;\n    setFocusedIndex(-1);\n  }, [focusedIndex, onBlur, setFocusedIndex]);\n  var handleFocus = useCallback(function (event) {\n    var _a, _b;\n    if (onFocus) {\n      onFocus(event);\n    }\n    if (focusedIndex !== -1) {\n      // this happens when a tree item is clicked with the mouse or touch\n      return;\n    }\n    var index = -1;\n    // try to \"focus\" the first selected itemId if there is a selection.\n    if (selectedIds.length) {\n      index = visibleItems.findIndex(function (item) {\n        return selectedIds.includes(item.itemId);\n      });\n    }\n    // fallback to the first visible tree item if there were no selected ids\n    if (index === -1) {\n      index = Math.max(0, Math.min(lastFocus.current, visibleItems.length));\n    }\n    var currentItem = (_b = itemIdRefs[(_a = visibleItems[index]) === null || _a === void 0 ? void 0 : _a.itemId]) === null || _b === void 0 ? void 0 : _b.ref.current;\n    if (currentItem && isKeyboard) {\n      scrollIntoView(getScrollContainer(event.currentTarget), currentItem);\n    }\n    setFocusedIndex(index);\n  }, [focusedIndex, isKeyboard, itemIdRefs, onFocus, selectedIds, setFocusedIndex, visibleItems]);\n  var setActiveId = useCallback(function (itemId) {\n    var index = visibleItems.findIndex(function (item) {\n      return item.itemId === itemId;\n    });\n    if (index !== -1) {\n      setFocusedIndex(index);\n    }\n  }, [setFocusedIndex, visibleItems]);\n  return {\n    items: items,\n    activeId: activeId,\n    setActiveId: setActiveId,\n    itemIdRefs: itemIdRefs,\n    handleBlur: handleBlur,\n    handleFocus: handleFocus,\n    handleKeyDown: handleKeyDown\n  };\n}","map":{"version":3,"names":["useCallback","useRef","JumpMovementKey","MovementPresets","scrollIntoView","useActiveDescendantMovement","useIsUserInteractionMode","useFlattenedTreeList","useNestedTreeList","getScrollContainer","target","classList","contains","parentElement","useTreeMovement","_a","id","data","rootId","sort","onBlur","onFocus","onKeyDown","multiSelect","selectedIds","onItemSelect","onMultiItemSelect","expandedIds","onItemExpansion","onMultiItemExpansion","valueKey","getItemValue","items","_b","__read","visibleItems","itemIdRefs","flattenedItems","isKeyboard","_c","__assign","VERTICAL_TREE","baseId","getId","_baseId","index","onSpace","focusedIndex","item","itemId","onChange","query","ref","current","container","scrollHeight","offsetHeight","isToStart","endsWith","ControlShiftHome","isToEnd","ControlShiftEnd","start","end","undefined","jumpSelectedIds","slice","map","uniqueSelectedIds","Array","from","Set","__spreadArray","length","event","parentId","isParent","key","includes","node","anchor","getAttribute","querySelector","forceNewTab","shiftKey","metaKey","ctrlKey","prevTarget","click","nextIndex","nextItem","setFocusedIndex","currentTarget","parentIndex","findIndex","parentItem","_d","preventDefault","allItemIds","item_1","expectedExpandedIds","filter","nextIds","visibleCount","lookup","i","item_2","isVisible","activeId","handleKeyDown","lastFocus","handleBlur","document","activeElement","handleFocus","Math","max","min","currentItem","setActiveId"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\tree\\src\\useTreeMovement.ts"],"sourcesContent":["import type { FocusEventHandler, KeyboardEventHandler } from \"react\";\nimport { useCallback, useRef } from \"react\";\nimport type { ListElement } from \"@react-md/list\";\nimport {\n  JumpMovementKey,\n  MovementPresets,\n  scrollIntoView,\n  useActiveDescendantMovement,\n  useIsUserInteractionMode,\n} from \"@react-md/utils\";\n\nimport type { TreeItemId, TreeProps, UnknownTreeItem } from \"./types\";\nimport type {\n  MetadataRecord,\n  SearchableTreeItem,\n} from \"./useFlattenedTreeList\";\nimport { useFlattenedTreeList } from \"./useFlattenedTreeList\";\nimport type { NestedTreeItem } from \"./useNestedTreeList\";\nimport { useNestedTreeList } from \"./useNestedTreeList\";\n\ntype Options = Pick<\n  TreeProps<UnknownTreeItem>,\n  | \"id\"\n  | \"data\"\n  | \"sort\"\n  | \"onBlur\"\n  | \"onFocus\"\n  | \"onKeyDown\"\n  | \"multiSelect\"\n  | \"selectedIds\"\n  | \"onItemSelect\"\n  | \"onMultiItemSelect\"\n  | \"expandedIds\"\n  | \"onItemExpansion\"\n  | \"onMultiItemExpansion\"\n> &\n  Required<\n    Pick<TreeProps<UnknownTreeItem>, \"valueKey\" | \"getItemValue\" | \"rootId\">\n  >;\n\ninterface ReturnValue {\n  /**\n   * A nested list representation of the provided tree data. This is used for\n   * rendering all the treeitem nodes.\n   */\n  items: readonly NestedTreeItem<UnknownTreeItem>[];\n\n  /**\n   * The current treeitem's DOM id that is currently keyboard focused.\n   */\n  activeId: string;\n\n  /**\n   * A function that updates the `activeId` based on the provided `itemId`. This\n   * should really only be used whenever an item is clicked with a mouse or\n   * touch since the `activeId` will be updated automatically for all the other\n   * flows.\n   */\n  setActiveId(itemId: TreeItemId): void;\n\n  /**\n   * A record containing the DOM ids for each tree item along with a ref object\n   * to provide to the itemRenderer for that item. This is just for a quick\n   * lookup to help with all the tree traversal and keyboard movement.\n   */\n  itemIdRefs: MetadataRecord;\n\n  /**\n   * A blur handler that should be passed to the tree list element that handles\n   * removing the `aria-activedescendant` when the tree is no longer within\n   * focus. This will also call the optional `onBlur` prop.\n   */\n  handleBlur: FocusEventHandler<ListElement>;\n\n  /**\n   * A focus handler that should be passed to the tree element that handles\n   * conditionally setting the default `aria-activedescendant` id on first\n   * focus. This will also call the optional `onFocus` prop.\n   */\n  handleFocus: FocusEventHandler<ListElement>;\n\n  /**\n   * The keydown handler that should be passed to the tree list element that\n   * handles all the keyboard functionality and movement.\n   *\n   * This will also call the optional `onKeyDown` prop.\n   */\n  handleKeyDown: KeyboardEventHandler<ListElement>;\n}\n\n/**\n * This is a temporary workaround for allowing the navigation tree to scroll\n * correctly with keyboard movement since it manually sets the\n * `overflow: visible` which prevents scrolling. I'll need to think of a better\n * way to find/get the scrollable element (if any). It might also just go into\n * the `scrollIntoView` util.\n *\n * @remarks \\@since 2.5.3\n * @internal\n */\nconst getScrollContainer = (target: HTMLElement): HTMLElement | null => {\n  if (target.classList.contains(\"rmd-layout-tree\")) {\n    return target.parentElement;\n  }\n\n  return target;\n};\n\n/**\n * This hook handles all the complex and \"fun\" stuff for selecting keyboard\n * accessibility within a tree and enabling keyboard movement, selection, and\n * expansion.\n *\n * @internal\n */\nexport function useTreeMovement({\n  id,\n  data,\n  rootId,\n  sort,\n  onBlur,\n  onFocus,\n  onKeyDown,\n  multiSelect,\n  selectedIds,\n  onItemSelect,\n  onMultiItemSelect,\n  expandedIds,\n  onItemExpansion,\n  onMultiItemExpansion,\n  valueKey,\n  getItemValue,\n}: Options): ReturnValue {\n  const items = useNestedTreeList(data, sort, rootId);\n  const [visibleItems, itemIdRefs, flattenedItems] = useFlattenedTreeList({\n    id,\n    items,\n    expandedIds,\n    rootId,\n    valueKey,\n    getItemValue,\n  });\n\n  const isKeyboard = useIsUserInteractionMode(\"keyboard\");\n\n  const {\n    activeId,\n    onKeyDown: handleKeyDown,\n    focusedIndex,\n    setFocusedIndex,\n  } = useActiveDescendantMovement<\n    SearchableTreeItem,\n    ListElement,\n    HTMLLIElement\n  >({\n    ...MovementPresets.VERTICAL_TREE,\n    items: visibleItems,\n    baseId: id,\n    getId(_baseId, index) {\n      return (visibleItems[index] || { id: \"\" }).id;\n    },\n    onSpace(focusedIndex) {\n      const item = visibleItems[focusedIndex];\n      if (!item) {\n        return;\n      }\n\n      const { itemId } = item;\n      onItemSelect(itemId);\n    },\n    onChange(data) {\n      const { index, target, query } = data;\n      const { itemId } = visibleItems[index];\n      // Note: have to do a custom `scrollIntoView` here instead of relying on\n      // the `useActiveDescendantMovement`'s `scrollIntoView` because of how the\n      // tree renders with the ref behavior.\n      const item = itemIdRefs[itemId].ref.current;\n      const container = getScrollContainer(target);\n      if (\n        item &&\n        container &&\n        container.scrollHeight > container.offsetHeight\n      ) {\n        scrollIntoView(container, item);\n      }\n\n      if (!multiSelect) {\n        return;\n      }\n\n      const isToStart = query.endsWith(JumpMovementKey.ControlShiftHome);\n      const isToEnd = query.endsWith(JumpMovementKey.ControlShiftEnd);\n      if (!isToStart && !isToEnd) {\n        return;\n      }\n\n      const start = isToStart ? 0 : focusedIndex;\n      const end = isToStart ? focusedIndex + 1 : undefined;\n      const jumpSelectedIds = visibleItems\n        .slice(start, end)\n        .map(({ itemId }) => itemId);\n      const uniqueSelectedIds = Array.from(\n        new Set([...selectedIds, ...jumpSelectedIds])\n      );\n      if (selectedIds.length !== uniqueSelectedIds.length) {\n        onMultiItemSelect(uniqueSelectedIds);\n      }\n    },\n    onKeyDown(event) {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      const item = visibleItems[focusedIndex];\n      if (!item) {\n        return;\n      }\n\n      const { itemId, parentId, isParent } = item;\n      switch (event.key) {\n        case \"Enter\": {\n          if (isParent) {\n            onItemExpansion(itemId, !expandedIds.includes(itemId));\n            return;\n          }\n\n          const node = itemIdRefs[itemId].ref.current;\n          const anchor =\n            node &&\n            node.getAttribute(\"role\") === \"none\" &&\n            node.querySelector<HTMLAnchorElement>(\"a[href]\");\n          if (!anchor) {\n            onItemSelect(itemId);\n            return;\n          }\n\n          // if a user is navigating through the app with a keyboard and presses\n          // cmd+shift+enter (Mac) or ctrl+shift+enter (Windows), the link will\n          // be forcefully opened in a new tab irregardless of the target\n          // attribute on the anchor tag. Since a tree doesn't actually focus\n          // the link in this case, need to \"polyfill\" it with this workaround.\n          // the `meta` key is for Mac and `ctrlKey` for Windows\n          const forceNewTab =\n            event.shiftKey && (event.metaKey || event.ctrlKey);\n\n          const prevTarget = anchor.target;\n          if (forceNewTab) {\n            anchor.target = \"_blank\";\n          }\n          anchor.click();\n          if (forceNewTab) {\n            anchor.target = prevTarget;\n          }\n\n          break;\n        }\n        case \"ArrowRight\":\n          if (!isParent) {\n            return;\n          }\n\n          if (!expandedIds.includes(itemId)) {\n            onItemExpansion(itemId, true);\n          } else {\n            const nextIndex = focusedIndex + 1;\n            const nextItem =\n              itemIdRefs[visibleItems[nextIndex]?.itemId]?.ref.current;\n\n            setFocusedIndex(nextIndex);\n            scrollIntoView(event.currentTarget, nextItem);\n          }\n          break;\n        case \"ArrowLeft\":\n          if (isParent && expandedIds.includes(itemId)) {\n            onItemExpansion(itemId, false);\n          } else if (parentId !== rootId) {\n            const parentIndex = visibleItems.findIndex(\n              (item) => item.itemId === parentId\n            );\n            const parentItem =\n              itemIdRefs[visibleItems[parentIndex]?.itemId]?.ref.current;\n\n            setFocusedIndex(parentIndex);\n            scrollIntoView(event.currentTarget, parentItem);\n          }\n          break;\n        case \"a\": {\n          if (!multiSelect || !event.ctrlKey) {\n            return;\n          }\n\n          event.preventDefault();\n          const allItemIds = visibleItems.map(({ itemId }) => itemId);\n          if (selectedIds.length === allItemIds.length) {\n            onMultiItemSelect([]);\n          } else {\n            onMultiItemSelect(allItemIds);\n          }\n          break;\n        }\n        case \"*\": {\n          const item = visibleItems[focusedIndex];\n          if (!item) {\n            return;\n          }\n\n          const expectedExpandedIds = visibleItems\n            .filter(\n              ({ isParent, parentId }) => isParent && parentId === item.parentId\n            )\n            .map(({ itemId }) => itemId);\n          const nextIds = Array.from(\n            new Set([...expandedIds, ...expectedExpandedIds])\n          );\n          if (nextIds.length !== expandedIds.length) {\n            onMultiItemExpansion(nextIds);\n\n            // since new items will be rendered, need to also update the focused\n            // index so the currently active item is still the \"focused\" item\n            //\n            // TODO: Look into a much better way to handle this sort of stuff..\n            // This still doesn't correctly scroll the active element into view.\n            // I should probably move all the scroll behavior into a useEffect\n            // for whenever the focusedIndex changes.\n            let visibleCount = 0;\n            const lookup: Record<TreeItemId, boolean> = {};\n            for (let i = 0; i < flattenedItems.length; i += 1) {\n              const item = flattenedItems[i];\n              let isVisible = item.parentId === rootId;\n              if (item.parentId !== null && nextIds.includes(item.parentId)) {\n                isVisible = !!lookup[item.parentId];\n              }\n\n              lookup[item.itemId] = isVisible;\n\n              if (itemId === item.itemId) {\n                setFocusedIndex(visibleCount);\n                return;\n              }\n\n              if (isVisible) {\n                visibleCount += 1;\n              }\n            }\n          }\n        }\n        // no default\n      }\n    },\n  });\n\n  const lastFocus = useRef(0);\n  const handleBlur = useCallback(\n    (event: React.FocusEvent<ListElement>) => {\n      if (onBlur) {\n        onBlur(event);\n      }\n\n      if (\n        document.activeElement &&\n        event.currentTarget.contains(document.activeElement)\n      ) {\n        return;\n      }\n\n      lastFocus.current = focusedIndex;\n      setFocusedIndex(-1);\n    },\n    [focusedIndex, onBlur, setFocusedIndex]\n  );\n\n  const handleFocus = useCallback(\n    (event: React.FocusEvent<ListElement>) => {\n      if (onFocus) {\n        onFocus(event);\n      }\n\n      if (focusedIndex !== -1) {\n        // this happens when a tree item is clicked with the mouse or touch\n        return;\n      }\n\n      let index = -1;\n      // try to \"focus\" the first selected itemId if there is a selection.\n      if (selectedIds.length) {\n        index = visibleItems.findIndex((item) =>\n          selectedIds.includes(item.itemId)\n        );\n      }\n\n      // fallback to the first visible tree item if there were no selected ids\n      if (index === -1) {\n        index = Math.max(0, Math.min(lastFocus.current, visibleItems.length));\n      }\n\n      const currentItem = itemIdRefs[visibleItems[index]?.itemId]?.ref.current;\n      if (currentItem && isKeyboard) {\n        scrollIntoView(getScrollContainer(event.currentTarget), currentItem);\n      }\n      setFocusedIndex(index);\n    },\n    [\n      focusedIndex,\n      isKeyboard,\n      itemIdRefs,\n      onFocus,\n      selectedIds,\n      setFocusedIndex,\n      visibleItems,\n    ]\n  );\n\n  const setActiveId = useCallback(\n    (itemId: TreeItemId) => {\n      const index = visibleItems.findIndex((item) => item.itemId === itemId);\n      if (index !== -1) {\n        setFocusedIndex(index);\n      }\n    },\n    [setFocusedIndex, visibleItems]\n  );\n\n  return {\n    items,\n    activeId,\n    setActiveId,\n    itemIdRefs,\n    handleBlur,\n    handleFocus,\n    handleKeyDown,\n  };\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAASA,WAAW,EAAEC,MAAM,QAAQ,OAAO;AAE3C,SACEC,eAAe,EACfC,eAAe,EACfC,cAAc,EACdC,2BAA2B,EAC3BC,wBAAwB,QACnB,iBAAiB;AAOxB,SAASC,oBAAoB,QAAQ,wBAAwB;AAE7D,SAASC,iBAAiB,QAAQ,qBAAqB;AAwEvD;;;;;;;;;;AAUA,IAAMC,kBAAkB,GAAG,SAAAA,CAACC,MAAmB;EAC7C,IAAIA,MAAM,CAACC,SAAS,CAACC,QAAQ,CAAC,iBAAiB,CAAC,EAAE;IAChD,OAAOF,MAAM,CAACG,aAAa;;EAG7B,OAAOH,MAAM;AACf,CAAC;AAED;;;;;;;AAOA,OAAM,SAAUI,eAAeA,CAACC,EAiBtB;MAhBRC,EAAE,GAAAD,EAAA,CAAAC,EAAA;IACFC,IAAI,GAAAF,EAAA,CAAAE,IAAA;IACJC,MAAM,GAAAH,EAAA,CAAAG,MAAA;IACNC,IAAI,GAAAJ,EAAA,CAAAI,IAAA;IACJC,MAAM,GAAAL,EAAA,CAAAK,MAAA;IACNC,OAAO,GAAAN,EAAA,CAAAM,OAAA;IACPC,SAAS,GAAAP,EAAA,CAAAO,SAAA;IACTC,WAAW,GAAAR,EAAA,CAAAQ,WAAA;IACXC,WAAW,GAAAT,EAAA,CAAAS,WAAA;IACXC,YAAY,GAAAV,EAAA,CAAAU,YAAA;IACZC,iBAAiB,GAAAX,EAAA,CAAAW,iBAAA;IACjBC,WAAW,GAAAZ,EAAA,CAAAY,WAAA;IACXC,eAAe,GAAAb,EAAA,CAAAa,eAAA;IACfC,oBAAoB,GAAAd,EAAA,CAAAc,oBAAA;IACpBC,QAAQ,GAAAf,EAAA,CAAAe,QAAA;IACRC,YAAY,GAAAhB,EAAA,CAAAgB,YAAA;EAEZ,IAAMC,KAAK,GAAGxB,iBAAiB,CAACS,IAAI,EAAEE,IAAI,EAAED,MAAM,CAAC;EAC7C,IAAAe,EAAA,GAAAC,MAAA,CAA6C3B,oBAAoB,CAAC;MACtES,EAAE,EAAAA,EAAA;MACFgB,KAAK,EAAAA,KAAA;MACLL,WAAW,EAAAA,WAAA;MACXT,MAAM,EAAAA,MAAA;MACNY,QAAQ,EAAAA,QAAA;MACRC,YAAY,EAAAA;KACb,CAAC;IAPKI,YAAY,GAAAF,EAAA;IAAEG,UAAU,GAAAH,EAAA;IAAEI,cAAc,GAAAJ,EAAA,GAO7C;EAEF,IAAMK,UAAU,GAAGhC,wBAAwB,CAAC,UAAU,CAAC;EAEjD,IAAAiC,EAAA,GAKFlC,2BAA2B,CAAAmC,QAAA,CAAAA,QAAA,KAK1BrC,eAAe,CAACsC,aAAa;MAChCT,KAAK,EAAEG,YAAY;MACnBO,MAAM,EAAE1B,EAAE;MACV2B,KAAK,WAAAA,CAACC,OAAO,EAAEC,KAAK;QAClB,OAAO,CAACV,YAAY,CAACU,KAAK,CAAC,IAAI;UAAE7B,EAAE,EAAE;QAAE,CAAE,EAAEA,EAAE;MAC/C,CAAC;MACD8B,OAAO,WAAAA,CAACC,YAAY;QAClB,IAAMC,IAAI,GAAGb,YAAY,CAACY,YAAY,CAAC;QACvC,IAAI,CAACC,IAAI,EAAE;UACT;;QAGM,IAAAC,MAAM,GAAKD,IAAI,CAAAC,MAAT;QACdxB,YAAY,CAACwB,MAAM,CAAC;MACtB,CAAC;MACDC,QAAQ,WAAAA,CAACjC,IAAI;QACH,IAAA4B,KAAK,GAAoB5B,IAAI,CAAA4B,KAAxB;UAAEnC,MAAM,GAAYO,IAAI,CAAAP,MAAhB;UAAEyC,KAAK,GAAKlC,IAAI,CAAAkC,KAAT;QACpB,IAAAF,MAAM,GAAKd,YAAY,CAACU,KAAK,CAAC,CAAAI,MAAxB;QACd;QACA;QACA;QACA,IAAMD,IAAI,GAAGZ,UAAU,CAACa,MAAM,CAAC,CAACG,GAAG,CAACC,OAAO;QAC3C,IAAMC,SAAS,GAAG7C,kBAAkB,CAACC,MAAM,CAAC;QAC5C,IACEsC,IAAI,IACJM,SAAS,IACTA,SAAS,CAACC,YAAY,GAAGD,SAAS,CAACE,YAAY,EAC/C;UACApD,cAAc,CAACkD,SAAS,EAAEN,IAAI,CAAC;;QAGjC,IAAI,CAACzB,WAAW,EAAE;UAChB;;QAGF,IAAMkC,SAAS,GAAGN,KAAK,CAACO,QAAQ,CAACxD,eAAe,CAACyD,gBAAgB,CAAC;QAClE,IAAMC,OAAO,GAAGT,KAAK,CAACO,QAAQ,CAACxD,eAAe,CAAC2D,eAAe,CAAC;QAC/D,IAAI,CAACJ,SAAS,IAAI,CAACG,OAAO,EAAE;UAC1B;;QAGF,IAAME,KAAK,GAAGL,SAAS,GAAG,CAAC,GAAGV,YAAY;QAC1C,IAAMgB,GAAG,GAAGN,SAAS,GAAGV,YAAY,GAAG,CAAC,GAAGiB,SAAS;QACpD,IAAMC,eAAe,GAAG9B,YAAY,CACjC+B,KAAK,CAACJ,KAAK,EAAEC,GAAG,CAAC,CACjBI,GAAG,CAAC,UAACpD,EAAU;cAARkC,MAAM,GAAAlC,EAAA,CAAAkC,MAAA;UAAO,OAAAA,MAAM;QAAN,CAAM,CAAC;QAC9B,IAAMmB,iBAAiB,GAAGC,KAAK,CAACC,IAAI,CAClC,IAAIC,GAAG,CAAAC,aAAA,CAAAA,aAAA,KAAAtC,MAAA,CAAKV,WAAW,WAAAU,MAAA,CAAK+B,eAAe,UAAE,CAC9C;QACD,IAAIzC,WAAW,CAACiD,MAAM,KAAKL,iBAAiB,CAACK,MAAM,EAAE;UACnD/C,iBAAiB,CAAC0C,iBAAiB,CAAC;;MAExC,CAAC;MACD9C,SAAS,EAAT,SAAAA,CAAUoD,KAAK;;QACb,IAAIpD,SAAS,EAAE;UACbA,SAAS,CAACoD,KAAK,CAAC;;QAGlB,IAAM1B,IAAI,GAAGb,YAAY,CAACY,YAAY,CAAC;QACvC,IAAI,CAACC,IAAI,EAAE;UACT;;QAGM,IAAAC,MAAM,GAAyBD,IAAI,CAAAC,MAA7B;UAAE0B,QAAQ,GAAe3B,IAAI,CAAA2B,QAAnB;UAAEC,QAAQ,GAAK5B,IAAI,CAAA4B,QAAT;QAClC,QAAQF,KAAK,CAACG,GAAG;UACf,KAAK,OAAO;YAAE;cACZ,IAAID,QAAQ,EAAE;gBACZhD,eAAe,CAACqB,MAAM,EAAE,CAACtB,WAAW,CAACmD,QAAQ,CAAC7B,MAAM,CAAC,CAAC;gBACtD;;cAGF,IAAM8B,IAAI,GAAG3C,UAAU,CAACa,MAAM,CAAC,CAACG,GAAG,CAACC,OAAO;cAC3C,IAAM2B,MAAM,GACVD,IAAI,IACJA,IAAI,CAACE,YAAY,CAAC,MAAM,CAAC,KAAK,MAAM,IACpCF,IAAI,CAACG,aAAa,CAAoB,SAAS,CAAC;cAClD,IAAI,CAACF,MAAM,EAAE;gBACXvD,YAAY,CAACwB,MAAM,CAAC;gBACpB;;cAGF;cACA;cACA;cACA;cACA;cACA;cACA,IAAMkC,WAAW,GACfT,KAAK,CAACU,QAAQ,KAAKV,KAAK,CAACW,OAAO,IAAIX,KAAK,CAACY,OAAO,CAAC;cAEpD,IAAMC,UAAU,GAAGP,MAAM,CAACtE,MAAM;cAChC,IAAIyE,WAAW,EAAE;gBACfH,MAAM,CAACtE,MAAM,GAAG,QAAQ;;cAE1BsE,MAAM,CAACQ,KAAK,EAAE;cACd,IAAIL,WAAW,EAAE;gBACfH,MAAM,CAACtE,MAAM,GAAG6E,UAAU;;cAG5B;;UAEF,KAAK,YAAY;YACf,IAAI,CAACX,QAAQ,EAAE;cACb;;YAGF,IAAI,CAACjD,WAAW,CAACmD,QAAQ,CAAC7B,MAAM,CAAC,EAAE;cACjCrB,eAAe,CAACqB,MAAM,EAAE,IAAI,CAAC;aAC9B,MAAM;cACL,IAAMwC,SAAS,GAAG1C,YAAY,GAAG,CAAC;cAClC,IAAM2C,QAAQ,GACZ,CAAAzD,EAAA,GAAAG,UAAU,CAAC,CAAArB,EAAA,GAAAoB,YAAY,CAACsD,SAAS,CAAC,cAAA1E,EAAA,uBAAAA,EAAA,CAAEkC,MAAM,CAAC,cAAAhB,EAAA,uBAAAA,EAAA,CAAEmB,GAAG,CAACC,OAAO;cAE1DsC,eAAe,CAACF,SAAS,CAAC;cAC1BrF,cAAc,CAACsE,KAAK,CAACkB,aAAa,EAAEF,QAAQ,CAAC;;YAE/C;UACF,KAAK,WAAW;YACd,IAAId,QAAQ,IAAIjD,WAAW,CAACmD,QAAQ,CAAC7B,MAAM,CAAC,EAAE;cAC5CrB,eAAe,CAACqB,MAAM,EAAE,KAAK,CAAC;aAC/B,MAAM,IAAI0B,QAAQ,KAAKzD,MAAM,EAAE;cAC9B,IAAM2E,WAAW,GAAG1D,YAAY,CAAC2D,SAAS,CACxC,UAAC9C,IAAI;gBAAK,OAAAA,IAAI,CAACC,MAAM,KAAK0B,QAAQ;cAAxB,CAAwB,CACnC;cACD,IAAMoB,UAAU,GACd,CAAAC,EAAA,GAAA5D,UAAU,CAAC,CAAAG,EAAA,GAAAJ,YAAY,CAAC0D,WAAW,CAAC,cAAAtD,EAAA,uBAAAA,EAAA,CAAEU,MAAM,CAAC,cAAA+C,EAAA,uBAAAA,EAAA,CAAE5C,GAAG,CAACC,OAAO;cAE5DsC,eAAe,CAACE,WAAW,CAAC;cAC5BzF,cAAc,CAACsE,KAAK,CAACkB,aAAa,EAAEG,UAAU,CAAC;;YAEjD;UACF,KAAK,GAAG;YAAE;cACR,IAAI,CAACxE,WAAW,IAAI,CAACmD,KAAK,CAACY,OAAO,EAAE;gBAClC;;cAGFZ,KAAK,CAACuB,cAAc,EAAE;cACtB,IAAMC,UAAU,GAAG/D,YAAY,CAACgC,GAAG,CAAC,UAACpD,EAAU;oBAARkC,MAAM,GAAAlC,EAAA,CAAAkC,MAAA;gBAAO,OAAAA,MAAM;cAAN,CAAM,CAAC;cAC3D,IAAIzB,WAAW,CAACiD,MAAM,KAAKyB,UAAU,CAACzB,MAAM,EAAE;gBAC5C/C,iBAAiB,CAAC,EAAE,CAAC;eACtB,MAAM;gBACLA,iBAAiB,CAACwE,UAAU,CAAC;;cAE/B;;UAEF,KAAK,GAAG;YAAE;cACR,IAAMC,MAAI,GAAGhE,YAAY,CAACY,YAAY,CAAC;cACvC,IAAI,CAACoD,MAAI,EAAE;gBACT;;cAGF,IAAMC,mBAAmB,GAAGjE,YAAY,CACrCkE,MAAM,CACL,UAACtF,EAAsB;oBAApB6D,QAAQ,GAAA7D,EAAA,CAAA6D,QAAA;kBAAED,QAAQ,GAAA5D,EAAA,CAAA4D,QAAA;gBAAO,OAAAC,QAAQ,IAAID,QAAQ,KAAKwB,MAAI,CAACxB,QAAQ;cAAtC,CAAsC,CACnE,CACAR,GAAG,CAAC,UAACpD,EAAU;oBAARkC,MAAM,GAAAlC,EAAA,CAAAkC,MAAA;gBAAO,OAAAA,MAAM;cAAN,CAAM,CAAC;cAC9B,IAAMqD,OAAO,GAAGjC,KAAK,CAACC,IAAI,CACxB,IAAIC,GAAG,CAAAC,aAAA,CAAAA,aAAA,KAAAtC,MAAA,CAAKP,WAAW,WAAAO,MAAA,CAAKkE,mBAAmB,UAAE,CAClD;cACD,IAAIE,OAAO,CAAC7B,MAAM,KAAK9C,WAAW,CAAC8C,MAAM,EAAE;gBACzC5C,oBAAoB,CAACyE,OAAO,CAAC;gBAE7B;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA,IAAIC,YAAY,GAAG,CAAC;gBACpB,IAAMC,MAAM,GAAgC,EAAE;gBAC9C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpE,cAAc,CAACoC,MAAM,EAAEgC,CAAC,IAAI,CAAC,EAAE;kBACjD,IAAMC,MAAI,GAAGrE,cAAc,CAACoE,CAAC,CAAC;kBAC9B,IAAIE,SAAS,GAAGD,MAAI,CAAC/B,QAAQ,KAAKzD,MAAM;kBACxC,IAAIwF,MAAI,CAAC/B,QAAQ,KAAK,IAAI,IAAI2B,OAAO,CAACxB,QAAQ,CAAC4B,MAAI,CAAC/B,QAAQ,CAAC,EAAE;oBAC7DgC,SAAS,GAAG,CAAC,CAACH,MAAM,CAACE,MAAI,CAAC/B,QAAQ,CAAC;;kBAGrC6B,MAAM,CAACE,MAAI,CAACzD,MAAM,CAAC,GAAG0D,SAAS;kBAE/B,IAAI1D,MAAM,KAAKyD,MAAI,CAACzD,MAAM,EAAE;oBAC1B0C,eAAe,CAACY,YAAY,CAAC;oBAC7B;;kBAGF,IAAII,SAAS,EAAE;oBACbJ,YAAY,IAAI,CAAC;;;;;UAKzB;;MAEJ;IAAC,GACD;IA3MAK,QAAQ,GAAArE,EAAA,CAAAqE,QAAA;IACGC,aAAa,GAAAtE,EAAA,CAAAjB,SAAA;IACxByB,YAAY,GAAAR,EAAA,CAAAQ,YAAA;IACZ4C,eAAe,GAAApD,EAAA,CAAAoD,eAwMf;EAEF,IAAMmB,SAAS,GAAG7G,MAAM,CAAC,CAAC,CAAC;EAC3B,IAAM8G,UAAU,GAAG/G,WAAW,CAC5B,UAAC0E,KAAoC;IACnC,IAAItD,MAAM,EAAE;MACVA,MAAM,CAACsD,KAAK,CAAC;;IAGf,IACEsC,QAAQ,CAACC,aAAa,IACtBvC,KAAK,CAACkB,aAAa,CAAChF,QAAQ,CAACoG,QAAQ,CAACC,aAAa,CAAC,EACpD;MACA;;IAGFH,SAAS,CAACzD,OAAO,GAAGN,YAAY;IAChC4C,eAAe,CAAC,CAAC,CAAC,CAAC;EACrB,CAAC,EACD,CAAC5C,YAAY,EAAE3B,MAAM,EAAEuE,eAAe,CAAC,CACxC;EAED,IAAMuB,WAAW,GAAGlH,WAAW,CAC7B,UAAC0E,KAAoC;;IACnC,IAAIrD,OAAO,EAAE;MACXA,OAAO,CAACqD,KAAK,CAAC;;IAGhB,IAAI3B,YAAY,KAAK,CAAC,CAAC,EAAE;MACvB;MACA;;IAGF,IAAIF,KAAK,GAAG,CAAC,CAAC;IACd;IACA,IAAIrB,WAAW,CAACiD,MAAM,EAAE;MACtB5B,KAAK,GAAGV,YAAY,CAAC2D,SAAS,CAAC,UAAC9C,IAAI;QAClC,OAAAxB,WAAW,CAACsD,QAAQ,CAAC9B,IAAI,CAACC,MAAM,CAAC;MAAjC,CAAiC,CAClC;;IAGH;IACA,IAAIJ,KAAK,KAAK,CAAC,CAAC,EAAE;MAChBA,KAAK,GAAGsE,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAACP,SAAS,CAACzD,OAAO,EAAElB,YAAY,CAACsC,MAAM,CAAC,CAAC;;IAGvE,IAAM6C,WAAW,GAAG,CAAArF,EAAA,GAAAG,UAAU,CAAC,CAAArB,EAAA,GAAAoB,YAAY,CAACU,KAAK,CAAC,cAAA9B,EAAA,uBAAAA,EAAA,CAAEkC,MAAM,CAAC,cAAAhB,EAAA,uBAAAA,EAAA,CAAEmB,GAAG,CAACC,OAAO;IACxE,IAAIiE,WAAW,IAAIhF,UAAU,EAAE;MAC7BlC,cAAc,CAACK,kBAAkB,CAACiE,KAAK,CAACkB,aAAa,CAAC,EAAE0B,WAAW,CAAC;;IAEtE3B,eAAe,CAAC9C,KAAK,CAAC;EACxB,CAAC,EACD,CACEE,YAAY,EACZT,UAAU,EACVF,UAAU,EACVf,OAAO,EACPG,WAAW,EACXmE,eAAe,EACfxD,YAAY,CACb,CACF;EAED,IAAMoF,WAAW,GAAGvH,WAAW,CAC7B,UAACiD,MAAkB;IACjB,IAAMJ,KAAK,GAAGV,YAAY,CAAC2D,SAAS,CAAC,UAAC9C,IAAI;MAAK,OAAAA,IAAI,CAACC,MAAM,KAAKA,MAAM;IAAtB,CAAsB,CAAC;IACtE,IAAIJ,KAAK,KAAK,CAAC,CAAC,EAAE;MAChB8C,eAAe,CAAC9C,KAAK,CAAC;;EAE1B,CAAC,EACD,CAAC8C,eAAe,EAAExD,YAAY,CAAC,CAChC;EAED,OAAO;IACLH,KAAK,EAAAA,KAAA;IACL4E,QAAQ,EAAAA,QAAA;IACRW,WAAW,EAAAA,WAAA;IACXnF,UAAU,EAAAA,UAAA;IACV2E,UAAU,EAAAA,UAAA;IACVG,WAAW,EAAAA,WAAA;IACXL,aAAa,EAAAA;GACd;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}