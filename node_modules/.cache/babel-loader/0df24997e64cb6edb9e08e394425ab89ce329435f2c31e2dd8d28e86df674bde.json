{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createContext, useCallback, useContext, useEffect, useMemo, useState } from \"react\";\nimport { useAppSize } from \"@react-md/utils\";\nimport { DEFAULT_DESKTOP_LAYOUT, DEFAULT_LANDSCAPE_TABLET_LAYOUT, DEFAULT_PHONE_LAYOUT, DEFAULT_TABLET_LAYOUT } from \"./constants\";\nimport { getLayoutType, isMiniLayout, isPersistentLayout, isToggleableLayout } from \"./utils\";\n/**\n * @internal\n */\nvar notInitialized = function (name) {\n  return function () {\n    /* istanbul ignore next */\n    if (process.env.NODE_ENV !== \"production\") {\n      /* eslint-disable no-console */\n      console.warn(\"Uh oh, something went wrong. Somehow the `LayoutNavigationConfiguration` context has not been initialized. \" + \"This caused the \\\"\".concat(name, \"\\\" callback to do nothing.\"));\n    }\n  };\n};\nvar context = createContext({\n  baseId: \"layout\",\n  layout: \"temporary\",\n  visible: false,\n  showNav: notInitialized(\"showNav\"),\n  hideNav: notInitialized(\"hideNav\"),\n  fixedAppBar: true,\n  isMiniable: false\n});\n/**\n * Gets the current layout state and configuration.\n */\nexport function useLayoutConfig() {\n  return useContext(context);\n}\nvar Provider = context.Provider;\n/**\n * @remarks \\@since 2.6.0\n * @internal\n */\nfunction isToggleableVisible(behavior, layout) {\n  return typeof behavior === \"string\" ? behavior === layout : behavior && isToggleableLayout(layout);\n}\n/**\n * Determines the current layout based on the `LayoutConfiguration` and hooks\n * into the `AppSizeListener` to update on resize. This also initializes the\n * `LayLayoutContext` so that a custom layout implementation can be used along\n * with the `useLayoutConfig()` hook and the multiple `Layout` components.\n */\nexport function LayoutProvider(_a) {\n  var baseId = _a.baseId,\n    _b = _a.phoneLayout,\n    phoneLayout = _b === void 0 ? DEFAULT_PHONE_LAYOUT : _b,\n    _c = _a.tabletLayout,\n    tabletLayout = _c === void 0 ? DEFAULT_TABLET_LAYOUT : _c,\n    _d = _a.landscapeTabletLayout,\n    landscapeTabletLayout = _d === void 0 ? DEFAULT_LANDSCAPE_TABLET_LAYOUT : _d,\n    _e = _a.desktopLayout,\n    desktopLayout = _e === void 0 ? DEFAULT_DESKTOP_LAYOUT : _e,\n    largeDesktopLayout = _a.largeDesktopLayout,\n    _f = _a.defaultToggleableVisible,\n    defaultToggleableVisible = _f === void 0 ? false : _f,\n    _g = _a.fixedAppBar,\n    fixedAppBar = _g === void 0 ? true : _g,\n    children = _a.children;\n  var appSize = useAppSize();\n  var layout = getLayoutType({\n    appSize: appSize,\n    phoneLayout: phoneLayout,\n    tabletLayout: tabletLayout,\n    landscapeTabletLayout: landscapeTabletLayout,\n    desktopLayout: desktopLayout,\n    largeDesktopLayout: largeDesktopLayout\n  });\n  var isMiniable = [phoneLayout, tabletLayout, landscapeTabletLayout, desktopLayout, largeDesktopLayout].some(function (layout) {\n    return !!layout && isMiniLayout(layout);\n  });\n  var isDesktop = appSize.isDesktop;\n  var _h = __read(useState(isPersistentLayout(layout) && isDesktop || isToggleableVisible(defaultToggleableVisible, layout)), 2),\n    visible = _h[0],\n    setVisible = _h[1];\n  useEffect(function () {\n    setVisible(isPersistentLayout(layout) || isToggleableVisible(defaultToggleableVisible, layout));\n  }, [defaultToggleableVisible, layout]);\n  var showNav = useCallback(function () {\n    setVisible(true);\n  }, []);\n  var hideNav = useCallback(function () {\n    if (!isPersistentLayout(layout)) {\n      setVisible(false);\n    }\n  }, [layout]);\n  var value = useMemo(function () {\n    return {\n      baseId: baseId,\n      layout: layout,\n      visible: visible,\n      showNav: showNav,\n      hideNav: hideNav,\n      fixedAppBar: fixedAppBar,\n      isMiniable: isMiniable\n    };\n  }, [baseId, layout, visible, showNav, hideNav, fixedAppBar, isMiniable]);\n  return _jsx(Provider, __assign({\n    value: value\n  }, {\n    children: children\n  }));\n}","map":{"version":3,"names":["createContext","useCallback","useContext","useEffect","useMemo","useState","useAppSize","DEFAULT_DESKTOP_LAYOUT","DEFAULT_LANDSCAPE_TABLET_LAYOUT","DEFAULT_PHONE_LAYOUT","DEFAULT_TABLET_LAYOUT","getLayoutType","isMiniLayout","isPersistentLayout","isToggleableLayout","notInitialized","name","process","env","NODE_ENV","console","warn","concat","context","baseId","layout","visible","showNav","hideNav","fixedAppBar","isMiniable","useLayoutConfig","Provider","isToggleableVisible","behavior","LayoutProvider","_a","_b","phoneLayout","_c","tabletLayout","_d","landscapeTabletLayout","_e","desktopLayout","largeDesktopLayout","_f","defaultToggleableVisible","_g","children","appSize","some","isDesktop","_h","__read","setVisible","value","_jsx","__assign"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\layout\\src\\LayoutProvider.tsx"],"sourcesContent":["import type { ReactElement, ReactNode } from \"react\";\nimport {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\";\nimport { useAppSize } from \"@react-md/utils\";\n\nimport {\n  DEFAULT_DESKTOP_LAYOUT,\n  DEFAULT_LANDSCAPE_TABLET_LAYOUT,\n  DEFAULT_PHONE_LAYOUT,\n  DEFAULT_TABLET_LAYOUT,\n} from \"./constants\";\nimport type { LayoutConfiguration, SupportedWideLayout } from \"./types\";\nimport {\n  getLayoutType,\n  isMiniLayout,\n  isPersistentLayout,\n  isToggleableLayout,\n} from \"./utils\";\n\n/**\n * @internal\n */\nconst notInitialized = (name: string) => (): void => {\n  /* istanbul ignore next */\n  if (process.env.NODE_ENV !== \"production\") {\n    /* eslint-disable no-console */\n    console.warn(\n      \"Uh oh, something went wrong. Somehow the `LayoutNavigationConfiguration` context has not been initialized. \" +\n        `This caused the \"${name}\" callback to do nothing.`\n    );\n  }\n};\n\nexport interface LayoutContext {\n  /**\n   * The root `id` that was passed to the `Layout` component so that `id`s can\n   * be generated for child components.\n   */\n  baseId: string;\n\n  /**\n   * The current layout that is being used based on the app's size.\n   */\n  layout: SupportedWideLayout;\n\n  /**\n   * Boolean if the navigation panel is currently visible. This will always be\n   * `true` for persist layout types on desktop.\n   */\n  visible: boolean;\n\n  /**\n   * A function that will set the `visible` state to `true`.\n   */\n  showNav(): void;\n\n  /**\n   * A function that will set the `visible` state to `false`.\n   */\n  hideNav(): void;\n\n  /**\n   * Boolean if the layout is currently using a fixed app bar which can be\n   * useful for determining specific scroll or layout behavior.\n   *\n   * @remarks \\@since 2.8.3\n   */\n  fixedAppBar: boolean;\n\n  /**\n   * Boolean if one of the layout types are mini. This is mostly used internally\n   * to prevent the `<main>` element from unmounting (and losing state) for\n   * non-fixed app bar layouts.\n   *\n   * @remarks \\@since 2.9.1\n   */\n  isMiniable: boolean;\n}\n\nconst context = createContext<LayoutContext>({\n  baseId: \"layout\",\n  layout: \"temporary\",\n  visible: false,\n  showNav: notInitialized(\"showNav\"),\n  hideNav: notInitialized(\"hideNav\"),\n  fixedAppBar: true,\n  isMiniable: false,\n});\n\n/**\n * Gets the current layout state and configuration.\n */\nexport function useLayoutConfig(): LayoutContext {\n  return useContext(context);\n}\n\nconst { Provider } = context;\n\nexport interface LayoutProviderProps extends LayoutConfiguration {\n  /**\n   * The base id for the layout component. This is required since all the child\n   * components use this to generate their ids.\n   */\n  baseId: string;\n\n  /**\n   * The children to render that can inherit the current layout.\n   */\n  children: ReactNode;\n\n  /** {@inheritDoc LayoutContext.fixedAppBar} */\n  fixedAppBar?: boolean;\n}\n\n/**\n * @remarks \\@since 2.6.0\n * @internal\n */\nfunction isToggleableVisible(\n  behavior: boolean | \"toggleable\" | \"toggleable-mini\",\n  layout: SupportedWideLayout\n): boolean {\n  return typeof behavior === \"string\"\n    ? behavior === layout\n    : behavior && isToggleableLayout(layout);\n}\n\n/**\n * Determines the current layout based on the `LayoutConfiguration` and hooks\n * into the `AppSizeListener` to update on resize. This also initializes the\n * `LayLayoutContext` so that a custom layout implementation can be used along\n * with the `useLayoutConfig()` hook and the multiple `Layout` components.\n */\nexport function LayoutProvider({\n  baseId,\n  phoneLayout = DEFAULT_PHONE_LAYOUT,\n  tabletLayout = DEFAULT_TABLET_LAYOUT,\n  landscapeTabletLayout = DEFAULT_LANDSCAPE_TABLET_LAYOUT,\n  desktopLayout = DEFAULT_DESKTOP_LAYOUT,\n  largeDesktopLayout,\n  defaultToggleableVisible = false,\n  fixedAppBar = true,\n  children,\n}: LayoutProviderProps): ReactElement {\n  const appSize = useAppSize();\n  const layout = getLayoutType({\n    appSize,\n    phoneLayout,\n    tabletLayout,\n    landscapeTabletLayout,\n    desktopLayout,\n    largeDesktopLayout,\n  });\n  const isMiniable = [\n    phoneLayout,\n    tabletLayout,\n    landscapeTabletLayout,\n    desktopLayout,\n    largeDesktopLayout,\n  ].some((layout) => !!layout && isMiniLayout(layout));\n\n  const { isDesktop } = appSize;\n  const [visible, setVisible] = useState(\n    (isPersistentLayout(layout) && isDesktop) ||\n      isToggleableVisible(defaultToggleableVisible, layout)\n  );\n\n  useEffect(() => {\n    setVisible(\n      isPersistentLayout(layout) ||\n        isToggleableVisible(defaultToggleableVisible, layout)\n    );\n  }, [defaultToggleableVisible, layout]);\n\n  const showNav = useCallback(() => {\n    setVisible(true);\n  }, []);\n\n  const hideNav = useCallback(() => {\n    if (!isPersistentLayout(layout)) {\n      setVisible(false);\n    }\n  }, [layout]);\n\n  const value = useMemo<LayoutContext>(\n    () => ({\n      baseId,\n      layout,\n      visible,\n      showNav,\n      hideNav,\n      fixedAppBar,\n      isMiniable,\n    }),\n    [baseId, layout, visible, showNav, hideNav, fixedAppBar, isMiniable]\n  );\n\n  return <Provider value={value}>{children}</Provider>;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SACEA,aAAa,EACbC,WAAW,EACXC,UAAU,EACVC,SAAS,EACTC,OAAO,EACPC,QAAQ,QACH,OAAO;AACd,SAASC,UAAU,QAAQ,iBAAiB;AAE5C,SACEC,sBAAsB,EACtBC,+BAA+B,EAC/BC,oBAAoB,EACpBC,qBAAqB,QAChB,aAAa;AAEpB,SACEC,aAAa,EACbC,YAAY,EACZC,kBAAkB,EAClBC,kBAAkB,QACb,SAAS;AAEhB;;;AAGA,IAAMC,cAAc,GAAG,SAAAA,CAACC,IAAY;EAAK;IACvC;IACA,IAAIC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzC;MACAC,OAAO,CAACC,IAAI,CACV,6GAA6G,GAC3G,qBAAAC,MAAA,CAAoBN,IAAI,+BAA2B,CACtD;;EAEL,CAAC;AATwC,CASxC;AAgDD,IAAMO,OAAO,GAAGvB,aAAa,CAAgB;EAC3CwB,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,WAAW;EACnBC,OAAO,EAAE,KAAK;EACdC,OAAO,EAAEZ,cAAc,CAAC,SAAS,CAAC;EAClCa,OAAO,EAAEb,cAAc,CAAC,SAAS,CAAC;EAClCc,WAAW,EAAE,IAAI;EACjBC,UAAU,EAAE;CACb,CAAC;AAEF;;;AAGA,OAAM,SAAUC,eAAeA,CAAA;EAC7B,OAAO7B,UAAU,CAACqB,OAAO,CAAC;AAC5B;AAEQ,IAAAS,QAAQ,GAAKT,OAAO,CAAAS,QAAZ;AAkBhB;;;;AAIA,SAASC,mBAAmBA,CAC1BC,QAAoD,EACpDT,MAA2B;EAE3B,OAAO,OAAOS,QAAQ,KAAK,QAAQ,GAC/BA,QAAQ,KAAKT,MAAM,GACnBS,QAAQ,IAAIpB,kBAAkB,CAACW,MAAM,CAAC;AAC5C;AAEA;;;;;;AAMA,OAAM,SAAUU,cAAcA,CAACC,EAUT;MATpBZ,MAAM,GAAAY,EAAA,CAAAZ,MAAA;IACNa,EAAA,GAAAD,EAAA,CAAAE,WAAkC;IAAlCA,WAAW,GAAAD,EAAA,cAAG5B,oBAAoB,GAAA4B,EAAA;IAClCE,EAAA,GAAAH,EAAA,CAAAI,YAAoC;IAApCA,YAAY,GAAAD,EAAA,cAAG7B,qBAAqB,GAAA6B,EAAA;IACpCE,EAAA,GAAAL,EAAA,CAAAM,qBAAuD;IAAvDA,qBAAqB,GAAAD,EAAA,cAAGjC,+BAA+B,GAAAiC,EAAA;IACvDE,EAAA,GAAAP,EAAA,CAAAQ,aAAsC;IAAtCA,aAAa,GAAAD,EAAA,cAAGpC,sBAAsB,GAAAoC,EAAA;IACtCE,kBAAkB,GAAAT,EAAA,CAAAS,kBAAA;IAClBC,EAAA,GAAAV,EAAA,CAAAW,wBAAgC;IAAhCA,wBAAwB,GAAAD,EAAA,cAAG,KAAK,GAAAA,EAAA;IAChCE,EAAA,GAAAZ,EAAA,CAAAP,WAAkB;IAAlBA,WAAW,GAAAmB,EAAA,cAAG,IAAI,GAAAA,EAAA;IAClBC,QAAQ,GAAAb,EAAA,CAAAa,QAAA;EAER,IAAMC,OAAO,GAAG5C,UAAU,EAAE;EAC5B,IAAMmB,MAAM,GAAGd,aAAa,CAAC;IAC3BuC,OAAO,EAAAA,OAAA;IACPZ,WAAW,EAAAA,WAAA;IACXE,YAAY,EAAAA,YAAA;IACZE,qBAAqB,EAAAA,qBAAA;IACrBE,aAAa,EAAAA,aAAA;IACbC,kBAAkB,EAAAA;GACnB,CAAC;EACF,IAAMf,UAAU,GAAG,CACjBQ,WAAW,EACXE,YAAY,EACZE,qBAAqB,EACrBE,aAAa,EACbC,kBAAkB,CACnB,CAACM,IAAI,CAAC,UAAC1B,MAAM;IAAK,QAAC,CAACA,MAAM,IAAIb,YAAY,CAACa,MAAM,CAAC;EAAhC,CAAgC,CAAC;EAE5C,IAAA2B,SAAS,GAAKF,OAAO,CAAAE,SAAZ;EACX,IAAAC,EAAA,GAAAC,MAAA,CAAwBjD,QAAQ,CACnCQ,kBAAkB,CAACY,MAAM,CAAC,IAAI2B,SAAS,IACtCnB,mBAAmB,CAACc,wBAAwB,EAAEtB,MAAM,CAAC,CACxD;IAHMC,OAAO,GAAA2B,EAAA;IAAEE,UAAU,GAAAF,EAAA,GAGzB;EAEDlD,SAAS,CAAC;IACRoD,UAAU,CACR1C,kBAAkB,CAACY,MAAM,CAAC,IACxBQ,mBAAmB,CAACc,wBAAwB,EAAEtB,MAAM,CAAC,CACxD;EACH,CAAC,EAAE,CAACsB,wBAAwB,EAAEtB,MAAM,CAAC,CAAC;EAEtC,IAAME,OAAO,GAAG1B,WAAW,CAAC;IAC1BsD,UAAU,CAAC,IAAI,CAAC;EAClB,CAAC,EAAE,EAAE,CAAC;EAEN,IAAM3B,OAAO,GAAG3B,WAAW,CAAC;IAC1B,IAAI,CAACY,kBAAkB,CAACY,MAAM,CAAC,EAAE;MAC/B8B,UAAU,CAAC,KAAK,CAAC;;EAErB,CAAC,EAAE,CAAC9B,MAAM,CAAC,CAAC;EAEZ,IAAM+B,KAAK,GAAGpD,OAAO,CACnB;IAAM,OAAC;MACLoB,MAAM,EAAAA,MAAA;MACNC,MAAM,EAAAA,MAAA;MACNC,OAAO,EAAAA,OAAA;MACPC,OAAO,EAAAA,OAAA;MACPC,OAAO,EAAAA,OAAA;MACPC,WAAW,EAAAA,WAAA;MACXC,UAAU,EAAAA;KACX;EARK,CAQJ,EACF,CAACN,MAAM,EAAEC,MAAM,EAAEC,OAAO,EAAEC,OAAO,EAAEC,OAAO,EAAEC,WAAW,EAAEC,UAAU,CAAC,CACrE;EAED,OAAO2B,IAAA,CAACzB,QAAQ,EAAA0B,QAAA;IAACF,KAAK,EAAEA;EAAK;IAAAP,QAAA,EAAGA;EAAQ,GAAY;AACtD"},"metadata":{},"sourceType":"module","externalDependencies":[]}