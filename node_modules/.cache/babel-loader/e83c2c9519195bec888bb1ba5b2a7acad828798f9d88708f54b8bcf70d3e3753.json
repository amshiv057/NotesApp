{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { useEffect, useRef } from \"react\";\nimport { useFixedPositioning } from \"@react-md/transition\";\nimport { containsElement, useIsUserInteractionMode, useScrollLock } from \"@react-md/utils\";\nimport { useMenuBarContext } from \"./MenuBarProvider\";\nimport { getDefaultAnchor, noop } from \"./utils\";\n/**\n * This hook provides all the functionality for a menu to:\n * - toggle the `Menu`'s visibility when the `MenuButton` or `MenuItemButton`\n *   has been clicked\n * - hide the `Menu` when an element outside of the `Menu` has been clicked\n * - hide the `Menu` when the `Escape` or `Tab` key has been pressed\n * - focus the `Menu` element when it gains visibility\n * - refocus the `MenuButton` or `MenuItemButton` when the menu loses visibility\n * - position the menu within the viewport with {@link useFixedPositioning}\n * - show the `Menu` when the `ArrowRight` key is pressed for a vertical\n *   `MenuItemButton`\n * - show the `Menu` when the `ArrowDown` key is pressed for a horizontal\n *   `MenuItemButton`\n * - hide the `Menu` when the `ArrowRight` key is pressed in a vertical submenu\n * - hide the `Menu` when the `ArrowDown` key is pressed in a horizontal\n *   submenu\n * - conditionally hide the `Menu` if the page is scrolled while the `Menu` is\n *   visible\n * - conditionally hide the `Menu` if the page is resized while the `Menu` is\n *   visible\n * - conditionally move focus to the next `DropdownMenu` with keyboard movement\n *   when inside of a `MenuBar`\n * - conditionally enable the visibility for a `DropdownMenu` when the mouse\n *   hovers over a `MenuItemButton` with a parent `MenuBar` that has been\n *   activated\n * - conditionally show/hide the `Menu` based on a parent `MenuBar`'s `activeId`\n *\n * This hook will probably never need to be used externally since it has been\n * integrated into the `DropdownMenu` component and `useContextMenu` hook.\n *\n * @example\n * Simple Example\n * ```tsx\n * import { ReactElement, useState } from \"react\";\n * import { useMenu, Menu, MenuButton, MenuItem } from \"@react-md/menu\";\n *\n * function Example(): ReactElement {\n *   const [visible, setVisible] = useState(false);\n *   const { menuRef, menuProps, toggleRef, toggleProps } = useMenu<\n *     HTMLButtonElement\n *   >({\n *     baseId: \"custom-menu-button\",\n *     visible,\n *     setVisible,\n *   });\n *\n *   return (\n *     <>\n *       <MenuButton ref={toggleRef} {...toggleProps}>\n *         Button\n *       </MenuButton>\n *       <Menu ref={menuRef} {...menuProps}>\n *         <MenuItem>Item 1</MenuItem>\n *         <MenuItem>Item 2</MenuItem>\n *         <MenuItem>Item 3</MenuItem>\n *       </Menu>\n *     </>\n *   );\n * }\n * ```\n *\n * @remarks \\@since 5.0.0\n */\nexport function useMenu(options) {\n  var baseId = options.baseId,\n    _a = options.disabled,\n    disabled = _a === void 0 ? false : _a,\n    propStyle = options.style,\n    menuLabel = options.menuLabel,\n    visible = options.visible,\n    setVisible = options.setVisible,\n    _b = options.floating,\n    floating = _b === void 0 ? null : _b,\n    _c = options.onMenuClick,\n    onMenuClick = _c === void 0 ? noop : _c,\n    _d = options.onMenuKeyDown,\n    onMenuKeyDown = _d === void 0 ? noop : _d,\n    _e = options.onToggleClick,\n    onToggleClick = _e === void 0 ? noop : _e,\n    _f = options.onToggleKeyDown,\n    onToggleKeyDown = _f === void 0 ? noop : _f,\n    _g = options.onToggleMouseEnter,\n    onToggleMouseEnter = _g === void 0 ? noop : _g,\n    _h = options.onToggleMouseLeave,\n    onToggleMouseLeave = _h === void 0 ? noop : _h,\n    _j = options.menuitem,\n    menuitem = _j === void 0 ? false : _j,\n    _k = options.horizontal,\n    horizontal = _k === void 0 ? false : _k,\n    propAnchor = options.anchor,\n    fixedPositionOptions = options.fixedPositionOptions,\n    getFixedPositionOptions = options.getFixedPositionOptions,\n    _l = options.closeOnResize,\n    closeOnResize = _l === void 0 ? false : _l,\n    _m = options.closeOnScroll,\n    closeOnScroll = _m === void 0 ? false : _m,\n    onEnter = options.onEnter,\n    onEntering = options.onEntering,\n    _o = options.onEntered,\n    onEntered = _o === void 0 ? noop : _o,\n    _p = options.onExited,\n    onExited = _p === void 0 ? noop : _p,\n    _q = options.onFixedPositionScroll,\n    onFixedPositionScroll = _q === void 0 ? noop : _q,\n    _r = options.onFixedPositionResize,\n    onFixedPositionResize = _r === void 0 ? noop : _r,\n    _s = options.preventScroll,\n    preventScroll = _s === void 0 ? false : _s,\n    _t = options.disableFocusOnMount,\n    disableFocusOnMount = _t === void 0 ? false : _t,\n    _u = options.disableFocusOnUnmount,\n    disableFocusOnUnmount = _u === void 0 ? false : _u;\n  var _v = useMenuBarContext(),\n    root = _v.root,\n    menubar = _v.menubar,\n    activeId = _v.activeId,\n    setActiveId = _v.setActiveId,\n    hoverTimeout = _v.hoverTimeout,\n    setAnimatedOnce = _v.setAnimatedOnce;\n  var touch = useIsUserInteractionMode(\"touch\");\n  var timeout = useRef();\n  useEffect(function () {\n    return function () {\n      window.clearTimeout(timeout.current);\n    };\n  }, []);\n  // if the menu hides because the user scrolls the page or the page is resized,\n  // the focus toggle behavior should be disabled since the user is no longer\n  // interacting with the menu\n  var cancelExitFocus = useRef(false);\n  var anchor = propAnchor !== null && propAnchor !== void 0 ? propAnchor : getDefaultAnchor({\n    menubar: menubar,\n    menuitem: menuitem,\n    floating: floating,\n    horizontal: horizontal\n  });\n  var menuNodeRef = useRef(null);\n  var toggleRef = useRef(null);\n  var _w = useFixedPositioning(__assign(__assign({\n      nodeRef: menuNodeRef,\n      style: propStyle,\n      fixedTo: toggleRef,\n      onEnter: onEnter,\n      onEntering: onEntering,\n      onEntered: function (appearing) {\n        var _a;\n        cancelExitFocus.current = false;\n        onEntered(appearing);\n        setAnimatedOnce(true);\n        if (!disableFocusOnMount) {\n          (_a = menuNodeRef.current) === null || _a === void 0 ? void 0 : _a.focus();\n        }\n      },\n      onExited: function () {\n        var _a;\n        onExited();\n        // this has to be done onExited or else the toggle component will be\n        // clicked if the user pressed the \"Enter\" key which makes it look like\n        // the menu never closes.\n        if (!disableFocusOnUnmount && !cancelExitFocus.current) {\n          (_a = toggleRef.current) === null || _a === void 0 ? void 0 : _a.focus();\n        }\n      },\n      anchor: anchor,\n      transformOrigin: true\n    }, fixedPositionOptions), {\n      getFixedPositionOptions: getFixedPositionOptions,\n      onScroll: function (event, data) {\n        onFixedPositionScroll(event, data);\n        if (!data.visible || closeOnScroll) {\n          cancelExitFocus.current = true;\n          setVisible(false);\n        }\n      },\n      onResize: function (event) {\n        onFixedPositionResize(event);\n        if (closeOnResize) {\n          cancelExitFocus.current = true;\n          setVisible(false);\n        }\n      }\n    })),\n    style = _w.style,\n    _x = _w.transitionOptions,\n    nodeRef = _x.nodeRef,\n    transitionOptions = __rest(_x, [\"nodeRef\"]);\n  useScrollLock(preventScroll && visible);\n  useEffect(function () {\n    if (!visible) {\n      return;\n    }\n    var handler = function (_a) {\n      var _b, _c;\n      var target = _a.target;\n      if (!(target instanceof Element) || !((_b = menuNodeRef.current) === null || _b === void 0 ? void 0 : _b.contains(target)) && !((_c = toggleRef.current) === null || _c === void 0 ? void 0 : _c.contains(target))) {\n        setVisible(false);\n      }\n    };\n    window.addEventListener(\"click\", handler);\n    return function () {\n      window.removeEventListener(\"click\", handler);\n    };\n  }, [menuNodeRef, setVisible, toggleRef, visible]);\n  useEffect(function () {\n    var _a;\n    if (visible) {\n      return;\n    }\n    // this is to fix keyboard movement behavior when navigating between\n    // different root-level menuitems with the `ArrowLeft` and `ArrowRight` keys\n    // while menus are visible. If the exit focus behavior is not cancelled, the\n    // next menu's menu will be visible, but the current menu's menuitem would\n    // be the current focus which breaks everything\n    cancelExitFocus.current = cancelExitFocus.current || !((_a = menuNodeRef.current) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement));\n    setActiveId(function (prevActiveId) {\n      return baseId === prevActiveId ? \"\" : prevActiveId;\n    });\n  }, [baseId, root, setActiveId, visible]);\n  useEffect(function () {\n    setVisible(baseId === activeId);\n  }, [activeId, baseId, root, setVisible]);\n  return {\n    menuRef: nodeRef,\n    menuProps: __assign(__assign({\n      // typecast to string so that it passes the RequireAtLeastOne<LabelA11y>\n      // TS won't pass otherwise\n      \"aria-label\": menuLabel,\n      \"aria-labelledby\": menuLabel ? undefined : baseId,\n      id: \"\".concat(baseId, \"-menu\"),\n      style: style\n    }, transitionOptions), {\n      visible: visible,\n      onClick: function (event) {\n        onMenuClick(event);\n        if (event.isPropagationStopped()) {\n          return;\n        }\n        // this makes it so you can click on the menu/list without closing the\n        // menu\n        if (event.currentTarget === event.target) {\n          return;\n        }\n        // This might be a test only workaround since clicking links move focus\n        // somewhere else\n        if (event.target instanceof HTMLElement) {\n          cancelExitFocus.current = containsElement(event.currentTarget, event.target.closest(\"a\"));\n        }\n        setVisible(false);\n      },\n      onKeyDown: function (event) {\n        onMenuKeyDown(event);\n        if (event.isPropagationStopped()) {\n          return;\n        }\n        switch (event.key) {\n          case \"Escape\":\n            // prevent parent components that have an \"Escape\" keypress event\n            // from being triggered as well\n            event.stopPropagation();\n            setVisible(false);\n            break;\n          case \"Tab\":\n            // since menus are portalled, tab index is kinda broke so just close\n            // the menu instead of doing default tab behavior\n            event.preventDefault();\n            if (!menuitem) {\n              // pressing the tab key should still cascade close all menus\n              event.stopPropagation();\n            }\n            setVisible(false);\n            break;\n          case \"ArrowUp\":\n            if (menuitem && horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(false);\n            }\n            break;\n          case \"ArrowLeft\":\n            if (menuitem && !horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(false);\n            }\n            break;\n        }\n      }\n    }),\n    menuNodeRef: menuNodeRef,\n    toggleRef: toggleRef,\n    toggleProps: {\n      \"aria-haspopup\": \"menu\",\n      \"aria-expanded\": visible || undefined,\n      id: baseId,\n      onClick: function (event) {\n        onToggleClick(event);\n        if (event.isPropagationStopped()) {\n          return;\n        }\n        if (menuitem || menubar) {\n          // do not allow the default menu close behavior from\n          // triggering for parent menus\n          event.stopPropagation();\n        }\n        setVisible(function (prevVisible) {\n          return !prevVisible;\n        });\n        setActiveId(function (prevActiveId) {\n          return baseId === prevActiveId ? \"\" : baseId;\n        });\n      },\n      onKeyDown: function (event) {\n        onToggleKeyDown(event);\n        if (event.isPropagationStopped() || disabled) {\n          return;\n        }\n        if (menubar && !menuitem && event.key === \"ArrowDown\") {\n          event.preventDefault();\n          event.stopPropagation();\n          setActiveId(baseId);\n          return;\n        }\n        if (!menuitem) {\n          return;\n        }\n        switch (event.key) {\n          case \"ArrowDown\":\n            if (horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(true);\n            }\n            break;\n          case \"ArrowRight\":\n            if (!horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(true);\n            }\n            break;\n        }\n      },\n      onMouseEnter: function (event) {\n        onToggleMouseEnter(event);\n        if (event.isPropagationStopped() || disabled || !menubar || !activeId || touch) {\n          if (typeof hoverTimeout === \"number\") {\n            timeout.current = window.setTimeout(function () {\n              setActiveId(baseId);\n            }, hoverTimeout);\n          }\n          return;\n        }\n        setActiveId(baseId);\n      },\n      onMouseLeave: function (event) {\n        onToggleMouseLeave(event);\n        window.clearTimeout(timeout.current);\n      }\n    }\n  };\n}","map":{"version":3,"names":["useEffect","useRef","useFixedPositioning","containsElement","useIsUserInteractionMode","useScrollLock","useMenuBarContext","getDefaultAnchor","noop","useMenu","options","baseId","_a","disabled","propStyle","style","menuLabel","visible","setVisible","_b","floating","_c","onMenuClick","_d","onMenuKeyDown","_e","onToggleClick","_f","onToggleKeyDown","_g","onToggleMouseEnter","_h","onToggleMouseLeave","_j","menuitem","_k","horizontal","propAnchor","anchor","fixedPositionOptions","getFixedPositionOptions","_l","closeOnResize","_m","closeOnScroll","onEnter","onEntering","_o","onEntered","_p","onExited","_q","onFixedPositionScroll","_r","onFixedPositionResize","_s","preventScroll","_t","disableFocusOnMount","_u","disableFocusOnUnmount","_v","root","menubar","activeId","setActiveId","hoverTimeout","setAnimatedOnce","touch","timeout","window","clearTimeout","current","cancelExitFocus","menuNodeRef","toggleRef","_w","__assign","nodeRef","fixedTo","appearing","focus","transformOrigin","onScroll","event","data","onResize","_x","transitionOptions","__rest","handler","target","Element","contains","addEventListener","removeEventListener","document","activeElement","prevActiveId","menuRef","menuProps","undefined","id","concat","onClick","isPropagationStopped","currentTarget","HTMLElement","closest","onKeyDown","key","stopPropagation","preventDefault","toggleProps","prevVisible","onMouseEnter","setTimeout","onMouseLeave"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\menu\\src\\useMenu.ts"],"sourcesContent":["import type {\n  KeyboardEventHandler,\n  MouseEventHandler,\n  MutableRefObject,\n} from \"react\";\nimport { useEffect, useRef } from \"react\";\nimport type { FABPosition } from \"@react-md/button\";\nimport { useFixedPositioning } from \"@react-md/transition\";\nimport {\n  containsElement,\n  useIsUserInteractionMode,\n  useScrollLock,\n} from \"@react-md/utils\";\n\nimport { useMenuBarContext } from \"./MenuBarProvider\";\nimport type {\n  BaseMenuHookOptions,\n  BaseMenuHookReturnValue,\n  ProvidedMenuToggleProps,\n} from \"./types\";\nimport { getDefaultAnchor, noop } from \"./utils\";\n\n/** @remarks \\@since 5.0.0 */\nexport interface MenuHookOptions<ToggleEl extends HTMLElement>\n  extends BaseMenuHookOptions {\n  /**\n   * Boolean if the toggle component is currently disabled which will prevent\n   * the arrow keys from opening a menuitem's menu.\n   *\n   * @defaultValue `false`\n   */\n  disabled?: boolean;\n\n  /**\n   * This is just used to update the default anchor behavior.\n   *\n   * @see {@link FABPosition}\n   * @defaultValue `null`\n   */\n  floating?: FABPosition;\n\n  /**\n   * An optional click handler to merge with the\n   * {@link MenuHookReturnValue.onClick} behavior.\n   */\n  onMenuClick?: MouseEventHandler<HTMLDivElement>;\n\n  /**\n   * An optional keydown handler to merge with the\n   * {@link MenuHookReturnValue.menuProps} behavior. Calling\n   * `event.stopPropagation()` will prevent the default behavior of closing the\n   * menu when the `\"Escape\"` key is pressed.\n   */\n  onMenuKeyDown?: KeyboardEventHandler<HTMLDivElement>;\n\n  /**\n   * An optional click handler to merge with the toggle visibility behavior.\n   * Calling `event.stopPropagation()` will prevent the default behavior from\n   * occurring.\n   */\n  onToggleClick?: MouseEventHandler<ToggleEl>;\n\n  /**\n   * An optional keydown handler to merge with the\n   * {@link ProvidedMenuToggleProps.onKeyDown} behavior.\n   */\n  onToggleKeyDown?: KeyboardEventHandler<ToggleEl>;\n\n  /**\n   * An optional keydown handler to merge with the\n   * {@link ProvidedMenuToggleProps.onMouseEnter} behavior.\n   */\n  onToggleMouseEnter?: MouseEventHandler<ToggleEl>;\n\n  /**\n   * An optional keydown handler to merge with the\n   * {@link ProvidedMenuToggleProps.onMouseLeave} behavior.\n   */\n  onToggleMouseLeave?: MouseEventHandler<ToggleEl>;\n}\n\n/**\n * @remarks \\@since 5.0.0\n */\nexport interface MenuHookReturnValue<ToggleEl extends HTMLElement>\n  extends BaseMenuHookReturnValue {\n  /**\n   * A ref that **must** be passed to the toggle element if the toggle should be\n   * refocused when the menu is closed via a keyboard press. This can also be\n   * used if you need access to the toggle element's DOM node for some reason.\n   */\n  toggleRef: MutableRefObject<ToggleEl | null>;\n\n  /**\n   * An object of props that must be provided to the toggle element for the\n   * visibility functionality of menus to work.\n   *\n   * @see {@link ProvidedMenuToggleProps}\n   */\n  toggleProps: ProvidedMenuToggleProps<ToggleEl>;\n}\n\n/**\n * This hook provides all the functionality for a menu to:\n * - toggle the `Menu`'s visibility when the `MenuButton` or `MenuItemButton`\n *   has been clicked\n * - hide the `Menu` when an element outside of the `Menu` has been clicked\n * - hide the `Menu` when the `Escape` or `Tab` key has been pressed\n * - focus the `Menu` element when it gains visibility\n * - refocus the `MenuButton` or `MenuItemButton` when the menu loses visibility\n * - position the menu within the viewport with {@link useFixedPositioning}\n * - show the `Menu` when the `ArrowRight` key is pressed for a vertical\n *   `MenuItemButton`\n * - show the `Menu` when the `ArrowDown` key is pressed for a horizontal\n *   `MenuItemButton`\n * - hide the `Menu` when the `ArrowRight` key is pressed in a vertical submenu\n * - hide the `Menu` when the `ArrowDown` key is pressed in a horizontal\n *   submenu\n * - conditionally hide the `Menu` if the page is scrolled while the `Menu` is\n *   visible\n * - conditionally hide the `Menu` if the page is resized while the `Menu` is\n *   visible\n * - conditionally move focus to the next `DropdownMenu` with keyboard movement\n *   when inside of a `MenuBar`\n * - conditionally enable the visibility for a `DropdownMenu` when the mouse\n *   hovers over a `MenuItemButton` with a parent `MenuBar` that has been\n *   activated\n * - conditionally show/hide the `Menu` based on a parent `MenuBar`'s `activeId`\n *\n * This hook will probably never need to be used externally since it has been\n * integrated into the `DropdownMenu` component and `useContextMenu` hook.\n *\n * @example\n * Simple Example\n * ```tsx\n * import { ReactElement, useState } from \"react\";\n * import { useMenu, Menu, MenuButton, MenuItem } from \"@react-md/menu\";\n *\n * function Example(): ReactElement {\n *   const [visible, setVisible] = useState(false);\n *   const { menuRef, menuProps, toggleRef, toggleProps } = useMenu<\n *     HTMLButtonElement\n *   >({\n *     baseId: \"custom-menu-button\",\n *     visible,\n *     setVisible,\n *   });\n *\n *   return (\n *     <>\n *       <MenuButton ref={toggleRef} {...toggleProps}>\n *         Button\n *       </MenuButton>\n *       <Menu ref={menuRef} {...menuProps}>\n *         <MenuItem>Item 1</MenuItem>\n *         <MenuItem>Item 2</MenuItem>\n *         <MenuItem>Item 3</MenuItem>\n *       </Menu>\n *     </>\n *   );\n * }\n * ```\n *\n * @remarks \\@since 5.0.0\n */\nexport function useMenu<ToggleEl extends HTMLElement>(\n  options: MenuHookOptions<ToggleEl>\n): MenuHookReturnValue<ToggleEl> {\n  const {\n    baseId,\n    disabled = false,\n    style: propStyle,\n    menuLabel,\n    visible,\n    setVisible,\n    floating = null,\n    onMenuClick = noop,\n    onMenuKeyDown = noop,\n    onToggleClick = noop,\n    onToggleKeyDown = noop,\n    onToggleMouseEnter = noop,\n    onToggleMouseLeave = noop,\n    menuitem = false,\n    horizontal = false,\n    anchor: propAnchor,\n    fixedPositionOptions,\n    getFixedPositionOptions,\n    closeOnResize = false,\n    closeOnScroll = false,\n    onEnter,\n    onEntering,\n    onEntered = noop,\n    onExited = noop,\n    onFixedPositionScroll = noop,\n    onFixedPositionResize = noop,\n    preventScroll = false,\n    disableFocusOnMount = false,\n    disableFocusOnUnmount = false,\n  } = options;\n  const {\n    root,\n    menubar,\n    activeId,\n    setActiveId,\n    hoverTimeout,\n    setAnimatedOnce,\n  } = useMenuBarContext();\n  const touch = useIsUserInteractionMode(\"touch\");\n\n  const timeout = useRef<number | undefined>();\n  useEffect(() => {\n    return () => {\n      window.clearTimeout(timeout.current);\n    };\n  }, []);\n\n  // if the menu hides because the user scrolls the page or the page is resized,\n  // the focus toggle behavior should be disabled since the user is no longer\n  // interacting with the menu\n  const cancelExitFocus = useRef(false);\n  const anchor =\n    propAnchor ?? getDefaultAnchor({ menubar, menuitem, floating, horizontal });\n  const menuNodeRef = useRef<HTMLDivElement>(null);\n  const toggleRef = useRef<ToggleEl | null>(null);\n  const {\n    style,\n    transitionOptions: { nodeRef, ...transitionOptions },\n  } = useFixedPositioning({\n    nodeRef: menuNodeRef,\n    style: propStyle,\n    fixedTo: toggleRef,\n    onEnter,\n    onEntering,\n    onEntered(appearing) {\n      cancelExitFocus.current = false;\n      onEntered(appearing);\n      setAnimatedOnce(true);\n      if (!disableFocusOnMount) {\n        menuNodeRef.current?.focus();\n      }\n    },\n    onExited() {\n      onExited();\n\n      // this has to be done onExited or else the toggle component will be\n      // clicked if the user pressed the \"Enter\" key which makes it look like\n      // the menu never closes.\n      if (!disableFocusOnUnmount && !cancelExitFocus.current) {\n        toggleRef.current?.focus();\n      }\n    },\n    anchor,\n    transformOrigin: true,\n    ...fixedPositionOptions,\n    getFixedPositionOptions,\n    onScroll(event, data) {\n      onFixedPositionScroll(event, data);\n      if (!data.visible || closeOnScroll) {\n        cancelExitFocus.current = true;\n        setVisible(false);\n      }\n    },\n    onResize(event) {\n      onFixedPositionResize(event);\n      if (closeOnResize) {\n        cancelExitFocus.current = true;\n        setVisible(false);\n      }\n    },\n  });\n  useScrollLock(preventScroll && visible);\n\n  useEffect(() => {\n    if (!visible) {\n      return;\n    }\n\n    const handler = ({ target }: MouseEvent): void => {\n      if (\n        !(target instanceof Element) ||\n        (!menuNodeRef.current?.contains(target) &&\n          !toggleRef.current?.contains(target))\n      ) {\n        setVisible(false);\n      }\n    };\n\n    window.addEventListener(\"click\", handler);\n    return () => {\n      window.removeEventListener(\"click\", handler);\n    };\n  }, [menuNodeRef, setVisible, toggleRef, visible]);\n  useEffect(() => {\n    if (visible) {\n      return;\n    }\n\n    // this is to fix keyboard movement behavior when navigating between\n    // different root-level menuitems with the `ArrowLeft` and `ArrowRight` keys\n    // while menus are visible. If the exit focus behavior is not cancelled, the\n    // next menu's menu will be visible, but the current menu's menuitem would\n    // be the current focus which breaks everything\n    cancelExitFocus.current =\n      cancelExitFocus.current ||\n      !menuNodeRef.current?.contains(document.activeElement);\n\n    setActiveId((prevActiveId) =>\n      baseId === prevActiveId ? \"\" : prevActiveId\n    );\n  }, [baseId, root, setActiveId, visible]);\n  useEffect(() => {\n    setVisible(baseId === activeId);\n  }, [activeId, baseId, root, setVisible]);\n\n  return {\n    menuRef: nodeRef,\n    menuProps: {\n      // typecast to string so that it passes the RequireAtLeastOne<LabelA11y>\n      // TS won't pass otherwise\n      \"aria-label\": menuLabel as string,\n      \"aria-labelledby\": menuLabel ? undefined : baseId,\n      id: `${baseId}-menu`,\n      style,\n      ...transitionOptions,\n      visible,\n      onClick(event) {\n        onMenuClick(event);\n        if (event.isPropagationStopped()) {\n          return;\n        }\n\n        // this makes it so you can click on the menu/list without closing the\n        // menu\n        if (event.currentTarget === event.target) {\n          return;\n        }\n\n        // This might be a test only workaround since clicking links move focus\n        // somewhere else\n        if (event.target instanceof HTMLElement) {\n          cancelExitFocus.current = containsElement(\n            event.currentTarget,\n            event.target.closest(\"a\")\n          );\n        }\n        setVisible(false);\n      },\n      onKeyDown(event) {\n        onMenuKeyDown(event);\n        if (event.isPropagationStopped()) {\n          return;\n        }\n\n        switch (event.key) {\n          case \"Escape\":\n            // prevent parent components that have an \"Escape\" keypress event\n            // from being triggered as well\n            event.stopPropagation();\n            setVisible(false);\n            break;\n          case \"Tab\":\n            // since menus are portalled, tab index is kinda broke so just close\n            // the menu instead of doing default tab behavior\n            event.preventDefault();\n            if (!menuitem) {\n              // pressing the tab key should still cascade close all menus\n              event.stopPropagation();\n            }\n            setVisible(false);\n            break;\n          case \"ArrowUp\":\n            if (menuitem && horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(false);\n            }\n            break;\n          case \"ArrowLeft\":\n            if (menuitem && !horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(false);\n            }\n            break;\n        }\n      },\n    },\n    menuNodeRef,\n    toggleRef,\n    toggleProps: {\n      \"aria-haspopup\": \"menu\",\n      \"aria-expanded\": visible || undefined,\n      id: baseId,\n      onClick(event) {\n        onToggleClick(event);\n        if (event.isPropagationStopped()) {\n          return;\n        }\n\n        if (menuitem || menubar) {\n          // do not allow the default menu close behavior from\n          // triggering for parent menus\n          event.stopPropagation();\n        }\n\n        setVisible((prevVisible) => !prevVisible);\n        setActiveId((prevActiveId) => (baseId === prevActiveId ? \"\" : baseId));\n      },\n      onKeyDown(event) {\n        onToggleKeyDown(event);\n        if (event.isPropagationStopped() || disabled) {\n          return;\n        }\n\n        if (menubar && !menuitem && event.key === \"ArrowDown\") {\n          event.preventDefault();\n          event.stopPropagation();\n          setActiveId(baseId);\n          return;\n        }\n\n        if (!menuitem) {\n          return;\n        }\n\n        switch (event.key) {\n          case \"ArrowDown\":\n            if (horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(true);\n            }\n            break;\n          case \"ArrowRight\":\n            if (!horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(true);\n            }\n            break;\n        }\n      },\n      onMouseEnter(event) {\n        onToggleMouseEnter(event);\n        if (\n          event.isPropagationStopped() ||\n          disabled ||\n          !menubar ||\n          !activeId ||\n          touch\n        ) {\n          if (typeof hoverTimeout === \"number\") {\n            timeout.current = window.setTimeout(() => {\n              setActiveId(baseId);\n            }, hoverTimeout);\n          }\n          return;\n        }\n\n        setActiveId(baseId);\n      },\n      onMouseLeave(event) {\n        onToggleMouseLeave(event);\n        window.clearTimeout(timeout.current);\n      },\n    },\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}