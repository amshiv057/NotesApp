{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { useCallback, useMemo } from \"react\";\nimport { useTempValue } from \"../useTempValue\";\nimport { findMatchIndex as DEFAULT_FIND_MATCH_INDEX } from \"./findMatchIndex\";\nimport { DEFAULT_GET_ITEM_VALUE, DEFAULT_SEARCH_RESET_TIME, DEFAULT_VALUE_KEY } from \"./utils\";\n/**\n * Adds the accessibility functionality to search a list of items as the user\n * types to trigger `aria-activedescendant` focus or manual DOM focus events.\n */\nexport function useKeyboardSearch(_a) {\n  var items = _a.items,\n    onChange = _a.onChange,\n    onKeyDown = _a.onKeyDown,\n    _b = _a.resetTime,\n    resetTime = _b === void 0 ? DEFAULT_SEARCH_RESET_TIME : _b,\n    searchIndex = _a.searchIndex,\n    _c = _a.valueKey,\n    valueKey = _c === void 0 ? DEFAULT_VALUE_KEY : _c,\n    _d = _a.getItemValue,\n    getItemValue = _d === void 0 ? DEFAULT_GET_ITEM_VALUE : _d,\n    _e = _a.findMatchIndex,\n    findMatchIndex = _e === void 0 ? DEFAULT_FIND_MATCH_INDEX : _e;\n  var _f = __read(useTempValue(\"\", resetTime), 2),\n    value = _f[0],\n    setValue = _f[1];\n  var values = useMemo(function () {\n    return items.map(function (item) {\n      return getItemValue(item, valueKey);\n    });\n  }, [items, getItemValue, valueKey]);\n  var handleKeyDown = useCallback(function (event) {\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n    var key = event.key,\n      altKey = event.altKey,\n      ctrlKey = event.ctrlKey,\n      metaKey = event.metaKey;\n    if (altKey || ctrlKey || metaKey || key.length > 1 || !value.current && key === \" \") {\n      // might need to change this later if other languages have non-meta keys\n      // that are more than 1 letter\n      return;\n    }\n    var nextValue = key;\n    if (value.current !== key) {\n      nextValue = \"\".concat(value.current).concat(key);\n    }\n    setValue(nextValue);\n    var index = findMatchIndex(nextValue, values, searchIndex, true);\n    // don't want to trigger change events if the search didn't match anything\n    // since you normally don't really care about failed matches\n    if (index === searchIndex || index === -1) {\n      return;\n    }\n    var data = {\n      index: index,\n      item: items[index],\n      items: items,\n      query: nextValue,\n      target: event.currentTarget\n    };\n    onChange(data);\n  }, [searchIndex, findMatchIndex, items, onChange, onKeyDown, setValue, value, values]);\n  return handleKeyDown;\n}","map":{"version":3,"names":["useCallback","useMemo","useTempValue","findMatchIndex","DEFAULT_FIND_MATCH_INDEX","DEFAULT_GET_ITEM_VALUE","DEFAULT_SEARCH_RESET_TIME","DEFAULT_VALUE_KEY","useKeyboardSearch","_a","items","onChange","onKeyDown","_b","resetTime","searchIndex","_c","valueKey","_d","getItemValue","_e","_f","__read","value","setValue","values","map","item","handleKeyDown","event","key","altKey","ctrlKey","metaKey","length","current","nextValue","concat","index","data","query","target","currentTarget"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\utils\\src\\search\\useKeyboardSearch.ts"],"sourcesContent":["import { useCallback, useMemo } from \"react\";\n\nimport { useTempValue } from \"../useTempValue\";\nimport type { FindMatchIndex } from \"./findMatchIndex\";\nimport { findMatchIndex as DEFAULT_FIND_MATCH_INDEX } from \"./findMatchIndex\";\nimport type { BaseSearchOptions } from \"./utils\";\nimport {\n  DEFAULT_GET_ITEM_VALUE,\n  DEFAULT_SEARCH_RESET_TIME,\n  DEFAULT_VALUE_KEY,\n} from \"./utils\";\n\n/**\n * The data that is provided to the `onChange` handler when searching. This will\n * be triggered whenever the user types a letter that causes the current search\n * result to change.\n */\nexport interface SearchData<D = unknown, E extends HTMLElement = HTMLElement> {\n  /**\n   * The item that was matched from the latest search.\n   */\n  readonly item: D;\n\n  /**\n   * The current list of items that were provided to be searched.\n   */\n  readonly items: readonly D[];\n\n  /**\n   * The index in the `items` array that the found item appears at. This is\n   * super useful when extending this hook to be used with\n   * `aria-activedescendant` focus movement or manual focus behavior since the\n   * `items` array should normally be the same indexes as the DOM nodes.\n   */\n  readonly index: number;\n\n  /**\n   * The search value that was used to find this item and trigger the change\n   * event.\n   */\n  readonly query: string;\n\n  /**\n   * The current target for the search keydown event.\n   */\n  readonly target: E;\n}\n\nexport type SearchChangeEvent<\n  D = unknown,\n  E extends HTMLElement = HTMLElement\n> = (data: SearchData<D, E>) => void;\n\nexport interface BaseKeyboardSearchOptions<\n  D = unknown,\n  E extends HTMLElement = HTMLElement\n> extends BaseSearchOptions<D> {\n  /**\n   * The list of items that should be searched whenever the user types a letter.\n   */\n  items: readonly D[];\n\n  /**\n   * A required change event handler that will be called whenever a user types a\n   * letter and it causes a new item to be \"found\". This should normally be\n   * something that either updates the `aria-activedescendant` id to the new\n   * found item's id or manually focus the item's DOM node.\n   */\n  onChange: SearchChangeEvent<D, E>;\n\n  /**\n   * An optional `onKeyDown` event handler that should be merged with the search\n   * functionality.\n   *\n   * Note: This will be called **before** the search functionality is triggered.\n   */\n  onKeyDown?: React.KeyboardEventHandler<E>;\n\n  /**\n   * The amount of time that a \"search\" value should be kept before resetting.\n   * The default value works for most cases, but it might be nice to configure\n   * it based on your use case.\n   */\n  resetTime?: number;\n\n  /**\n   * The function used to find a match index within the `items` list. You most\n   * likely won't want to change this.\n   */\n  findMatchIndex?: FindMatchIndex;\n}\n\nexport interface KeyboardSearchOptions<\n  D = unknown,\n  E extends HTMLElement = HTMLElement\n> extends BaseKeyboardSearchOptions<D, E> {\n  /**\n   * The current index that should be \"focused\" due to a keyboard search. This\n   * should be updated whenever the `onChange` callback is fired.\n   */\n  searchIndex: number;\n}\n\ntype ReturnValue<E extends HTMLElement = HTMLElement> =\n  React.KeyboardEventHandler<E>;\n\n/**\n * Adds the accessibility functionality to search a list of items as the user\n * types to trigger `aria-activedescendant` focus or manual DOM focus events.\n */\nexport function useKeyboardSearch<\n  D = unknown,\n  E extends HTMLElement = HTMLElement\n>({\n  items,\n  onChange,\n  onKeyDown,\n  resetTime = DEFAULT_SEARCH_RESET_TIME,\n  searchIndex,\n  valueKey = DEFAULT_VALUE_KEY,\n  getItemValue = DEFAULT_GET_ITEM_VALUE,\n  findMatchIndex = DEFAULT_FIND_MATCH_INDEX,\n}: KeyboardSearchOptions<D, E>): ReturnValue<E> {\n  const [value, setValue] = useTempValue(\"\", resetTime);\n  const values = useMemo(\n    () => items.map((item) => getItemValue(item, valueKey)),\n    [items, getItemValue, valueKey]\n  );\n\n  const handleKeyDown = useCallback<React.KeyboardEventHandler<E>>(\n    (event) => {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      const { key, altKey, ctrlKey, metaKey } = event;\n      if (\n        altKey ||\n        ctrlKey ||\n        metaKey ||\n        key.length > 1 ||\n        (!value.current && key === \" \")\n      ) {\n        // might need to change this later if other languages have non-meta keys\n        // that are more than 1 letter\n        return;\n      }\n\n      let nextValue = key;\n      if (value.current !== key) {\n        nextValue = `${value.current}${key}`;\n      }\n      setValue(nextValue);\n\n      const index = findMatchIndex(nextValue, values, searchIndex, true);\n      // don't want to trigger change events if the search didn't match anything\n      // since you normally don't really care about failed matches\n      if (index === searchIndex || index === -1) {\n        return;\n      }\n\n      const data: SearchData<D, E> = {\n        index,\n        item: items[index],\n        items,\n        query: nextValue,\n        target: event.currentTarget,\n      };\n\n      onChange(data);\n    },\n    [\n      searchIndex,\n      findMatchIndex,\n      items,\n      onChange,\n      onKeyDown,\n      setValue,\n      value,\n      values,\n    ]\n  );\n\n  return handleKeyDown;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}