{"ast":null,"code":"import { getAboveCoord, getBelowCoord, getBottomCoord, getCenterYCoord, getTopCoord } from \"./getCoord\";\nimport { getViewportSize } from \"./getViewportSize\";\n/**\n * Attempts to position the fixed element so that it will appear completely\n * above the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the below position if it\n * can't fit within the viewport above the container element. If it can't fit in\n * the viewport even after being swapped below or swapping is disabled, it will\n * be positioned to the top viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredAbove(config) {\n  var yMargin = config.yMargin,\n    vhMargin = config.vhMargin,\n    screenBottom = config.screenBottom,\n    elHeight = config.elHeight,\n    containerRect = config.containerRect,\n    preventOverlap = config.preventOverlap,\n    disableSwapping = config.disableSwapping,\n    disableVHBounds = config.disableVHBounds;\n  var top = getAboveCoord(config);\n  var actualY = \"above\";\n  if (disableVHBounds) {\n    // can't actually allow a top value as a negative number since browsers\n    // won't scroll upwards pas the normal page top\n    return {\n      actualY: actualY,\n      top: Math.max(0, top)\n    };\n  }\n  if (top > vhMargin) {\n    // don't need to do anything else since the top is still in the viewport and\n    // since it's positioned above, we already know it can't overlap the\n    // container element\n    return {\n      actualY: actualY,\n      top: top\n    };\n  }\n  var swappedTop = getBelowCoord(config);\n  if (disableSwapping || swappedTop + elHeight > screenBottom) {\n    top = Math.min(top, vhMargin);\n  } else {\n    actualY = \"below\";\n    top = swappedTop;\n  }\n  var bottom;\n  if (preventOverlap &&\n  // can't overlap if it's positioned below\n  actualY === \"above\" && top + elHeight > containerRect.top) {\n    bottom = window.innerHeight - containerRect.top + yMargin;\n  }\n  return {\n    actualY: actualY,\n    top: top,\n    bottom: bottom\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear fixed to the\n * top of the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the bottom position if it\n * can't fit within the viewport. If it can't fit in the viewport even after\n * being swapped to the bottom position or swapping is disabled, it will be\n * positioned to the top viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredTop(config) {\n  var vhMargin = config.vhMargin,\n    screenBottom = config.screenBottom,\n    elHeight = config.elHeight,\n    disableSwapping = config.disableSwapping,\n    disableVHBounds = config.disableVHBounds;\n  var top = getTopCoord(config);\n  var actualY = \"top\";\n  if (disableVHBounds || top + elHeight <= screenBottom) {\n    return {\n      actualY: actualY,\n      top: top\n    };\n  }\n  var swappedTop = getBottomCoord(config);\n  if (disableSwapping || swappedTop < vhMargin) {\n    top = Math.max(top, vhMargin);\n  } else {\n    actualY = \"bottom\";\n    top = swappedTop;\n  }\n  return {\n    actualY: actualY,\n    top: top\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear at the center\n * of the container element but also within the viewport boundaries. If the\n * entered element can't fit within the viewport, it'll update the top value\n * to either be the vhMargin or position to the screen bottom boundary\n *\n * @internal\n */\nexport function createAnchoredCenter(config) {\n  var vhMargin = config.vhMargin,\n    screenBottom = config.screenBottom,\n    elHeight = config.elHeight,\n    disableVHBounds = config.disableVHBounds;\n  var top = getCenterYCoord(config);\n  var actualY = \"center\";\n  if (disableVHBounds) {\n    return {\n      actualY: actualY,\n      top: Math.max(0, top)\n    };\n  }\n  top = Math.max(vhMargin, top);\n  if (top + elHeight > screenBottom) {\n    top = screenBottom - elHeight;\n  }\n  return {\n    actualY: actualY,\n    top: top\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear fixed to the\n * bottom of the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the top position if it can't\n * fit within the viewport. If it can't fit in the viewport even after being\n * swapped to the top position or swapping is disabled, it will be positioned to\n * the bottom viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredBottom(config) {\n  var vhMargin = config.vhMargin,\n    screenBottom = config.screenBottom,\n    elHeight = config.elHeight,\n    disableSwapping = config.disableSwapping,\n    disableVHBounds = config.disableVHBounds;\n  var top = getBottomCoord(config);\n  var actualY = \"bottom\";\n  if (disableVHBounds || top > vhMargin) {\n    return {\n      actualY: actualY,\n      top: top\n    };\n  }\n  var swappedTop = getTopCoord(config);\n  if (disableSwapping || swappedTop + elHeight > screenBottom) {\n    top = Math.min(top, screenBottom - elHeight);\n  } else {\n    actualY = \"top\";\n    top = swappedTop;\n  }\n  return {\n    actualY: actualY,\n    top: top\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear completely\n * below the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the above position if it\n * can't fit within the viewport below the container element. If it can't fit in\n * the viewport even after being swapped above or swapping is disabled, it will\n * be positioned to the bottom viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredBelow(config) {\n  var yMargin = config.yMargin,\n    vhMargin = config.vhMargin,\n    elHeight = config.elHeight,\n    screenBottom = config.screenBottom,\n    containerRect = config.containerRect,\n    preventOverlap = config.preventOverlap,\n    disableSwapping = config.disableSwapping,\n    disableVHBounds = config.disableVHBounds;\n  var top = getBelowCoord(config);\n  var actualY = \"below\";\n  if (disableVHBounds || top + elHeight <= screenBottom) {\n    return {\n      actualY: actualY,\n      top: top\n    };\n  }\n  if (preventOverlap) {\n    var availableTop = containerRect.top - yMargin;\n    if (disableSwapping || availableTop < screenBottom - top) {\n      return {\n        actualY: actualY,\n        top: top,\n        bottom: vhMargin\n      };\n    }\n    return {\n      actualY: \"above\",\n      top: Math.max(vhMargin, availableTop - elHeight),\n      // this makes it so that the bottom of the fixed element is the top of the container\n      // element. this ensures that it won't ever overlap the container element\n      bottom: getViewportSize(\"height\") - availableTop\n    };\n  }\n  var swappedTop = getAboveCoord(config);\n  if (disableSwapping || swappedTop < vhMargin) {\n    top = Math.max(top, screenBottom - elHeight);\n  } else {\n    actualY = \"above\";\n    top = swappedTop;\n  }\n  return {\n    actualY: actualY,\n    top: top\n  };\n}\n/**\n * Creates the vertical position for a fixed element with the provided options.\n *\n * @internal\n */\nexport function createVerticalPosition(_a) {\n  var y = _a.y,\n    vh = _a.vh,\n    vhMargin = _a.vhMargin,\n    yMargin = _a.yMargin,\n    elHeight = _a.elHeight,\n    initialY = _a.initialY,\n    containerRect = _a.containerRect,\n    disableSwapping = _a.disableSwapping,\n    preventOverlap = _a.preventOverlap,\n    disableVHBounds = _a.disableVHBounds;\n  if (!disableVHBounds && !preventOverlap && elHeight > vh - vhMargin * 2) {\n    // the element is too big to be displayed in the viewport, so just span the\n    // full viewport excluding margins\n    return {\n      top: vhMargin,\n      bottom: vhMargin,\n      actualY: \"center\"\n    };\n  }\n  var config = {\n    vhMargin: vhMargin,\n    yMargin: yMargin,\n    elHeight: elHeight,\n    initialY: initialY,\n    containerRect: containerRect,\n    screenBottom: vh - vhMargin,\n    preventOverlap: preventOverlap,\n    disableSwapping: disableSwapping,\n    disableVHBounds: disableVHBounds\n  };\n  switch (y) {\n    case \"above\":\n      return createAnchoredAbove(config);\n    case \"top\":\n      return createAnchoredTop(config);\n    case \"center\":\n      return createAnchoredCenter(config);\n    case \"bottom\":\n      return createAnchoredBottom(config);\n    case \"below\":\n      return createAnchoredBelow(config);\n  }\n}","map":{"version":3,"names":["getAboveCoord","getBelowCoord","getBottomCoord","getCenterYCoord","getTopCoord","getViewportSize","createAnchoredAbove","config","yMargin","vhMargin","screenBottom","elHeight","containerRect","preventOverlap","disableSwapping","disableVHBounds","top","actualY","Math","max","swappedTop","min","bottom","window","innerHeight","createAnchoredTop","createAnchoredCenter","createAnchoredBottom","createAnchoredBelow","availableTop","createVerticalPosition","_a","y","vh","initialY"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\utils\\src\\positioning\\createVerticalPosition.ts"],"sourcesContent":["import type { YCoordConfig } from \"./getCoord\";\nimport {\n  getAboveCoord,\n  getBelowCoord,\n  getBottomCoord,\n  getCenterYCoord,\n  getTopCoord,\n} from \"./getCoord\";\nimport { getViewportSize } from \"./getViewportSize\";\nimport type { FixedPositionOptions, VerticalPosition } from \"./types\";\n\n/**\n * @internal\n */\ninterface YPosition {\n  top: number;\n  bottom?: number;\n  actualY: VerticalPosition;\n}\n\n/**\n * @internal\n */\nexport interface FixConfig extends YCoordConfig {\n  vhMargin: number;\n  screenBottom: number;\n  preventOverlap: boolean;\n  disableSwapping: boolean;\n  disableVHBounds: boolean;\n}\n\n/**\n * @internal\n */\ninterface Options\n  extends Required<\n    Pick<\n      FixedPositionOptions,\n      | \"yMargin\"\n      | \"vhMargin\"\n      | \"preventOverlap\"\n      | \"disableSwapping\"\n      | \"disableVHBounds\"\n    >\n  > {\n  y: VerticalPosition;\n  vh: number;\n  initialY?: number;\n  elHeight: number;\n  containerRect: DOMRect;\n}\n\n/**\n * Attempts to position the fixed element so that it will appear completely\n * above the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the below position if it\n * can't fit within the viewport above the container element. If it can't fit in\n * the viewport even after being swapped below or swapping is disabled, it will\n * be positioned to the top viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredAbove(config: FixConfig): YPosition {\n  const {\n    yMargin,\n    vhMargin,\n    screenBottom,\n    elHeight,\n    containerRect,\n    preventOverlap,\n    disableSwapping,\n    disableVHBounds,\n  } = config;\n  let top = getAboveCoord(config);\n  let actualY: VerticalPosition = \"above\";\n\n  if (disableVHBounds) {\n    // can't actually allow a top value as a negative number since browsers\n    // won't scroll upwards pas the normal page top\n    return { actualY, top: Math.max(0, top) };\n  }\n\n  if (top > vhMargin) {\n    // don't need to do anything else since the top is still in the viewport and\n    // since it's positioned above, we already know it can't overlap the\n    // container element\n    return { actualY, top };\n  }\n\n  const swappedTop = getBelowCoord(config);\n  if (disableSwapping || swappedTop + elHeight > screenBottom) {\n    top = Math.min(top, vhMargin);\n  } else {\n    actualY = \"below\";\n    top = swappedTop;\n  }\n\n  let bottom: number | undefined;\n  if (\n    preventOverlap &&\n    // can't overlap if it's positioned below\n    actualY === \"above\" &&\n    top + elHeight > containerRect.top\n  ) {\n    bottom = window.innerHeight - containerRect.top + yMargin;\n  }\n\n  return { actualY, top, bottom };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear fixed to the\n * top of the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the bottom position if it\n * can't fit within the viewport. If it can't fit in the viewport even after\n * being swapped to the bottom position or swapping is disabled, it will be\n * positioned to the top viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredTop(config: FixConfig): YPosition {\n  const { vhMargin, screenBottom, elHeight, disableSwapping, disableVHBounds } =\n    config;\n  let top = getTopCoord(config);\n  let actualY: VerticalPosition = \"top\";\n\n  if (disableVHBounds || top + elHeight <= screenBottom) {\n    return { actualY, top };\n  }\n\n  const swappedTop = getBottomCoord(config);\n  if (disableSwapping || swappedTop < vhMargin) {\n    top = Math.max(top, vhMargin);\n  } else {\n    actualY = \"bottom\";\n    top = swappedTop;\n  }\n\n  return { actualY, top };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear at the center\n * of the container element but also within the viewport boundaries. If the\n * entered element can't fit within the viewport, it'll update the top value\n * to either be the vhMargin or position to the screen bottom boundary\n *\n * @internal\n */\nexport function createAnchoredCenter(config: FixConfig): YPosition {\n  const { vhMargin, screenBottom, elHeight, disableVHBounds } = config;\n  let top = getCenterYCoord(config);\n  const actualY: VerticalPosition = \"center\";\n  if (disableVHBounds) {\n    return { actualY, top: Math.max(0, top) };\n  }\n\n  top = Math.max(vhMargin, top);\n  if (top + elHeight > screenBottom) {\n    top = screenBottom - elHeight;\n  }\n\n  return { actualY, top };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear fixed to the\n * bottom of the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the top position if it can't\n * fit within the viewport. If it can't fit in the viewport even after being\n * swapped to the top position or swapping is disabled, it will be positioned to\n * the bottom viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredBottom(config: FixConfig): YPosition {\n  const { vhMargin, screenBottom, elHeight, disableSwapping, disableVHBounds } =\n    config;\n  let top = getBottomCoord(config);\n  let actualY: VerticalPosition = \"bottom\";\n  if (disableVHBounds || top > vhMargin) {\n    return { actualY, top };\n  }\n\n  const swappedTop = getTopCoord(config);\n  if (disableSwapping || swappedTop + elHeight > screenBottom) {\n    top = Math.min(top, screenBottom - elHeight);\n  } else {\n    actualY = \"top\";\n    top = swappedTop;\n  }\n\n  return { actualY, top };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear completely\n * below the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the above position if it\n * can't fit within the viewport below the container element. If it can't fit in\n * the viewport even after being swapped above or swapping is disabled, it will\n * be positioned to the bottom viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredBelow(config: FixConfig): YPosition {\n  const {\n    yMargin,\n    vhMargin,\n    elHeight,\n    screenBottom,\n    containerRect,\n    preventOverlap,\n    disableSwapping,\n    disableVHBounds,\n  } = config;\n  let top = getBelowCoord(config);\n  let actualY: VerticalPosition = \"below\";\n  if (disableVHBounds || top + elHeight <= screenBottom) {\n    return { actualY, top };\n  }\n\n  if (preventOverlap) {\n    const availableTop = containerRect.top - yMargin;\n    if (disableSwapping || availableTop < screenBottom - top) {\n      return {\n        actualY,\n        top,\n        bottom: vhMargin,\n      };\n    }\n\n    return {\n      actualY: \"above\",\n      top: Math.max(vhMargin, availableTop - elHeight),\n      // this makes it so that the bottom of the fixed element is the top of the container\n      // element. this ensures that it won't ever overlap the container element\n      bottom: getViewportSize(\"height\") - availableTop,\n    };\n  }\n\n  const swappedTop = getAboveCoord(config);\n  if (disableSwapping || swappedTop < vhMargin) {\n    top = Math.max(top, screenBottom - elHeight);\n  } else {\n    actualY = \"above\";\n    top = swappedTop;\n  }\n\n  return { actualY, top };\n}\n\n/**\n * Creates the vertical position for a fixed element with the provided options.\n *\n * @internal\n */\nexport function createVerticalPosition({\n  y,\n  vh,\n  vhMargin,\n  yMargin,\n  elHeight,\n  initialY,\n  containerRect,\n  disableSwapping,\n  preventOverlap,\n  disableVHBounds,\n}: Options): YPosition {\n  if (!disableVHBounds && !preventOverlap && elHeight > vh - vhMargin * 2) {\n    // the element is too big to be displayed in the viewport, so just span the\n    // full viewport excluding margins\n    return {\n      top: vhMargin,\n      bottom: vhMargin,\n      actualY: \"center\",\n    };\n  }\n\n  const config: FixConfig = {\n    vhMargin,\n    yMargin,\n    elHeight,\n    initialY,\n    containerRect,\n    screenBottom: vh - vhMargin,\n    preventOverlap,\n    disableSwapping,\n    disableVHBounds,\n  };\n\n  switch (y) {\n    case \"above\":\n      return createAnchoredAbove(config);\n    case \"top\":\n      return createAnchoredTop(config);\n    case \"center\":\n      return createAnchoredCenter(config);\n    case \"bottom\":\n      return createAnchoredBottom(config);\n    case \"below\":\n      return createAnchoredBelow(config);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}