{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { Children, cloneElement, forwardRef, isValidElement, useCallback, useEffect, useRef, useState } from \"react\";\nimport cn from \"classnames\";\nimport { bem, useEnsuredRef } from \"@react-md/utils\";\nimport { useTabs } from \"./TabsManager\";\nvar block = bem(\"rmd-tab-panels\");\n/**\n * This component allows you to control the visibility of the `TabPanel`\n * components and animating the next and current panels as needed. This works by\n * looping over all the children and getting the current `TabPanel` by the\n * `activeIndex`. This is why the children for this component can only be\n * `TabPanel` and should not be conditional.\n */\nexport var TabPanels = forwardRef(function TabPanels(_a, forwardedRef) {\n  var className = _a.className,\n    children = _a.children,\n    _b = _a.disableScrollFix,\n    disableScrollFix = _b === void 0 ? false : _b,\n    _c = _a.disableTransition,\n    disableTransition = _c === void 0 ? false : _c,\n    _d = _a.persistent,\n    persistent = _d === void 0 ? false : _d,\n    props = __rest(_a, [\"className\", \"children\", \"disableScrollFix\", \"disableTransition\", \"persistent\"]);\n  var _e = useTabs(),\n    tabsId = _e.tabsId,\n    tabs = _e.tabs,\n    activeIndex = _e.activeIndex;\n  var prevIndex = useRef(activeIndex);\n  var _f = __read(useState({\n      previous: activeIndex,\n      incrementing: true\n    }), 2),\n    _g = _f[0],\n    previous = _g.previous,\n    incrementing = _g.incrementing,\n    setState = _f[1];\n  // have to set these in refs since changing these might cause mounting\n  // and unmounting in the Transition group component :/ they should only\n  // be re-evaluated when the activeIndex changes.\n  var transitionable = useRef(!persistent && !disableTransition);\n  var animatable = useRef(persistent && !disableTransition);\n  if (prevIndex.current !== activeIndex) {\n    prevIndex.current = activeIndex;\n    transitionable.current = !persistent && !disableTransition;\n    animatable.current = persistent && !disableTransition;\n  }\n  useEffect(function () {\n    setState(function (_a) {\n      var previous = _a.previous;\n      return {\n        incrementing: previous < activeIndex,\n        previous: disableTransition ? activeIndex : previous\n      };\n    });\n    // this is for only updating the incrementing state and should not be fired\n    // again if the disableTransition prop is changed\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [activeIndex]);\n  var onEntered = useCallback(function () {\n    setState(function (_a) {\n      var incrementing = _a.incrementing;\n      return {\n        incrementing: incrementing,\n        previous: activeIndex\n      };\n    });\n  }, [activeIndex]);\n  var _h = __read(useEnsuredRef(forwardedRef), 2),\n    ref = _h[0],\n    refHandler = _h[1];\n  useEffect(function () {\n    if (!ref.current || disableScrollFix) {\n      return;\n    }\n    ref.current.scrollTop = 0;\n    // don't want it to be triggered if only the disableScrollFix prop has changed\n    // since it might be independent from active indexes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [activeIndex]);\n  return _jsx(\"div\", __assign({}, props, {\n    ref: refHandler,\n    className: cn(block({\n      \"slide-left\": incrementing,\n      \"slide-right\": !incrementing\n    }), className)\n  }, {\n    children: Children.map(children, function (child, index) {\n      if (!isValidElement(child)) {\n        return child;\n      }\n      var panel = Children.only(child);\n      var labelledBy = panel.props[\"aria-labelledby\"];\n      if (!labelledBy && !panel.props[\"aria-label\"] && tabs[index]) {\n        // generally guaranteed to be defined by this point since the TabsManager\n        // will add ids if missing.\n        labelledBy = tabs[index].id;\n      }\n      return cloneElement(child, {\n        \"aria-labelledby\": labelledBy,\n        id: \"\".concat(tabsId, \"-panel-\").concat(index + 1),\n        hidden: persistent && index !== activeIndex && index !== previous,\n        temporary: !persistent,\n        transitionIn: index === activeIndex,\n        timeout: disableTransition ? 0 : panel.props.timeout,\n        onEntered: disableTransition ? undefined : onEntered\n      });\n    })\n  }));\n});","map":{"version":3,"names":["Children","cloneElement","forwardRef","isValidElement","useCallback","useEffect","useRef","useState","cn","bem","useEnsuredRef","useTabs","block","TabPanels","_a","forwardedRef","className","children","_b","disableScrollFix","_c","disableTransition","_d","persistent","props","__rest","_e","tabsId","tabs","activeIndex","prevIndex","_f","__read","previous","incrementing","_g","setState","transitionable","animatable","current","onEntered","_h","ref","refHandler","scrollTop","_jsx","__assign","map","child","index","panel","only","labelledBy","id","concat","hidden","temporary","transitionIn","timeout","undefined"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\tabs\\src\\TabPanels.tsx"],"sourcesContent":["import type { HTMLAttributes } from \"react\";\nimport {\n  Children,\n  cloneElement,\n  forwardRef,\n  isValidElement,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport cn from \"classnames\";\nimport { bem, useEnsuredRef } from \"@react-md/utils\";\n\nimport { useTabs } from \"./TabsManager\";\nimport type { TabPanelProps } from \"./TabPanel\";\n\nexport interface TabPanelsProps extends HTMLAttributes<HTMLDivElement> {\n  /**\n   * Boolean if this component should no longer automatically reset the scrolling\n   * to the top when the panel changes.\n   *\n   * @defaultValue `false`\n   */\n  disableScrollFix?: boolean;\n\n  /**\n   * Boolean if the swiping transition should be disabled. If you want to add\n   * a custom transition, you'll need to wrap the `TabPanel`'s children in a\n   * custom component that does appear and exit animations.\n   *\n   * @defaultValue `false`\n   */\n  disableTransition?: boolean;\n\n  /**\n   * Boolean if the conditional rendering for the active tab panel only should\n   * be disabled. This means that all the children will be visible in the DOM\n   * instead of mounting and unmounting when their active state changes. The\n   * panels will also be updated to ensure that inactive panels can not be\n   * tab focusable.\n   *\n   * @defaultValue `false`\n   */\n  persistent?: boolean;\n}\n\nconst block = bem(\"rmd-tab-panels\");\n\n/**\n * This component allows you to control the visibility of the `TabPanel`\n * components and animating the next and current panels as needed. This works by\n * looping over all the children and getting the current `TabPanel` by the\n * `activeIndex`. This is why the children for this component can only be\n * `TabPanel` and should not be conditional.\n */\nexport const TabPanels = forwardRef<HTMLDivElement, TabPanelsProps>(\n  function TabPanels(\n    {\n      className,\n      children,\n      disableScrollFix = false,\n      disableTransition = false,\n      persistent = false,\n      ...props\n    },\n    forwardedRef\n  ) {\n    const { tabsId, tabs, activeIndex } = useTabs();\n    const prevIndex = useRef(activeIndex);\n    const [{ previous, incrementing }, setState] = useState({\n      previous: activeIndex,\n      incrementing: true,\n    });\n\n    // have to set these in refs since changing these might cause mounting\n    // and unmounting in the Transition group component :/ they should only\n    // be re-evaluated when the activeIndex changes.\n    const transitionable = useRef(!persistent && !disableTransition);\n    const animatable = useRef(persistent && !disableTransition);\n    if (prevIndex.current !== activeIndex) {\n      prevIndex.current = activeIndex;\n      transitionable.current = !persistent && !disableTransition;\n      animatable.current = persistent && !disableTransition;\n    }\n\n    useEffect(() => {\n      setState(({ previous }) => ({\n        incrementing: previous < activeIndex,\n        previous: disableTransition ? activeIndex : previous,\n      }));\n\n      // this is for only updating the incrementing state and should not be fired\n      // again if the disableTransition prop is changed\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [activeIndex]);\n\n    const onEntered = useCallback(() => {\n      setState(({ incrementing }) => ({ incrementing, previous: activeIndex }));\n    }, [activeIndex]);\n\n    const [ref, refHandler] = useEnsuredRef(forwardedRef);\n\n    useEffect(() => {\n      if (!ref.current || disableScrollFix) {\n        return;\n      }\n\n      ref.current.scrollTop = 0;\n      // don't want it to be triggered if only the disableScrollFix prop has changed\n      // since it might be independent from active indexes\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [activeIndex]);\n\n    return (\n      <div\n        {...props}\n        ref={refHandler}\n        className={cn(\n          block({\n            \"slide-left\": incrementing,\n            \"slide-right\": !incrementing,\n          }),\n          className\n        )}\n      >\n        {Children.map(children, (child, index) => {\n          if (!isValidElement<TabPanelProps>(child)) {\n            return child;\n          }\n\n          const panel = Children.only(child);\n          let labelledBy = panel.props[\"aria-labelledby\"];\n          if (!labelledBy && !panel.props[\"aria-label\"] && tabs[index]) {\n            // generally guaranteed to be defined by this point since the TabsManager\n            // will add ids if missing.\n            labelledBy = tabs[index].id;\n          }\n\n          return cloneElement(child, {\n            \"aria-labelledby\": labelledBy,\n            id: `${tabsId}-panel-${index + 1}`,\n            hidden: persistent && index !== activeIndex && index !== previous,\n            temporary: !persistent,\n            transitionIn: index === activeIndex,\n            timeout: disableTransition ? 0 : panel.props.timeout,\n            onEntered: disableTransition ? undefined : onEntered,\n          });\n        })}\n      </div>\n    );\n  }\n);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}