{"ast":null,"code":"export {};","map":{"version":3,"names":[],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\tree\\src\\types.ts"],"sourcesContent":["import type {\n  CSSProperties,\n  Dispatch,\n  ElementType,\n  HTMLAttributes,\n  MutableRefObject,\n  ReactElement,\n  ReactNode,\n  Ref,\n  SetStateAction,\n} from \"react\";\nimport type {\n  ListItemChildrenProps,\n  ListProps,\n  SimpleListItemProps,\n} from \"@react-md/list\";\n\nexport type TreeItemId = string;\nexport type ExpandedIds = readonly TreeItemId[];\nexport type SelectedIds = readonly TreeItemId[];\n\nexport interface TreeItemIds {\n  /**\n   * The unique identifier for an item within the tree. This is used to be able\n   * to link tree items together with parent items as well as selected/expanded\n   * logic.\n   */\n  itemId: TreeItemId;\n\n  /**\n   * This id is used to be able to link tree items together with children and\n   * parents. If the `parentId` is set to `null`, the tree item will appear at\n   * the root of the tree. Otherwise, the tree item will appear as a child of\n   * the referenced tree item by `itemId`\n   */\n  parentId: null | TreeItemId;\n}\n\nexport interface BaseTreeItem extends TreeItemIds, ListItemChildrenProps {\n  /**\n   * Boolean if the provided item is a custom element and will not be rendered\n   * in a `TreeItem` component. This is useful if you want to be able to render\n   * `Divider` or `ListSubheader` components within a tree since they _should_\n   * be able to be rendered without any of the tree functionality.\n   */\n  isCustom?: boolean;\n}\n\n/**\n * This is just a type I use internally for handling tree items with unknown\n * keys.\n *\n * @internal\n */\nexport interface UnknownTreeItem extends BaseTreeItem {\n  [key: string]: unknown;\n}\n\n/**\n * This type represents the data that can be handled by the `Tree` component.\n * This is really just a Map of `itemId -> item` for quick lookups for the logic\n * within the tree.\n */\nexport type TreeData<T extends BaseTreeItem> = Record<TreeItemId, T>;\n\n/**\n * A function to call that will sort the items within the tree for each unique\n * `parentId`. If you have a tree like:\n *\n * ```\n * a\n * ├── a1\n * b\n * ├── b1\n * ├── b2\n * │   └── b2.1\n * c\n * ├── c1\n * ├── c2\n * └── c3\n * ```\n *\n * This function will be called with:\n *\n * - `[a1]`\n * - `[b2.1]`\n * - `[b1, b2]`\n * - `[c1, c2, c3]`\n * - `[a, b, c]`\n */\nexport type TreeItemSorter<T extends BaseTreeItem> = (\n  items: readonly T[]\n) => readonly T[];\n\n/**\n * A render function that allows you to add additional functionality to or\n * custom components within the tree.\n */\nexport type TreeItemRenderer<T extends BaseTreeItem> = (\n  providedProps: ProvidedTreeItemProps,\n  item: T & { visibleIndex: number },\n  treeProps: ProvidedTreeProps\n) => ReactElement | null;\n\n/**\n * A function to get additional props to pass to each tree item. It will be\n * provided the current item and the \"states\" of the item merged together.\n *\n * Note: It is generally recommended to use the `itemRenderer` instead for\n * additional functionality as you will have more control. This prop is more for\n * applying custom styles or display data on the item.\n */\nexport type GetItemProps<T extends TreeItemIds> = (\n  item: T & TreeItemStates\n) => ConfigurableTreeItemProps | undefined;\n\nexport interface TreeItemExpansionIcon {\n  /**\n   * The icon to show within each item within the tree that helps show that\n   * there are child items.\n   *\n   * NOTE: This will override the `rightAddon` prop if defined on each item by\n   * default so they can't be used. If the `expanderLeft` prop is enabled, the\n   * `leftAddon` will be overridden instead.\n   */\n  expanderIcon?: ReactNode;\n\n  /**\n   * Boolean if the expander icon should appear to the left instead of the\n   * right.\n   */\n  expanderLeft?: boolean;\n}\n\nexport interface TreeItemExpansion {\n  /**\n   * The list of expanded ids within the tree. These ids should reference\n   * `itemId`s for tree items.\n   */\n  expandedIds: ExpandedIds;\n\n  /**\n   * A function to call that will update the `expandedIds` to collapse or expand\n   * a clicked item.\n   */\n  onItemExpansion(itemId: TreeItemId, expanded: boolean): void;\n\n  /**\n   * A function to call when the user presses the asterisk key (*) that will\n   * expand all tree items at the same level as the currently focused item.\n   *\n   * @remarks \\@since 4.0.1 Allows for callback behavior to get current\n   * `expandedIds`.\n   */\n  onMultiItemExpansion: Dispatch<SetStateAction<ExpandedIds>>;\n}\n\nexport interface TreeItemSelection {\n  /**\n   * Boolean if multiple items within the tree can be selected at once.\n   */\n  multiSelect?: boolean;\n\n  /**\n   * The list of selected ids within the tree. If you only want to allow a\n   * single item to be selected at a time within a tree, keep this as either an\n   * empty list (no selections) or a single `itemId`.\n   */\n  selectedIds: SelectedIds;\n\n  /**\n   * A function to call that will update the `selectedIds` to include `itemId`\n   * of the newly selected tree item. This will be triggered when:\n   *\n   * - the user clicks a tree item with mouse or touch\n   * - user presses the space or enter key while keyboard focusing a tree item\n   *\n   * Note: If you are using the `useTreeItemSelection` hook, this will always\n   * cause the `selectedIds` to be a list of just the selected `itemId` unless\n   * the `multiSelect` (second argument) is enabled.\n   */\n  onItemSelect: (itemId: TreeItemId) => void;\n\n  /**\n   * A function to  call that will update the `selectedIds` for \"batch\"\n   * selection updates. This will always be called with a unique list of\n   * `itemId`s that contained the previous `itemId`s including the new\n   * `itemId`s. This will only be called when the `multiSelect` prop has been\n   * enabled and:\n   *\n   * - the user `Shift + Click`s items within the tree\n   * - triggers \"select-to\" keyboard functionality with `Control+Shift+Home` or\n   *   `Control+Shift+End`\n   */\n  onMultiItemSelect: (itemIds: SelectedIds) => void;\n}\n\nexport interface TreeItemStates {\n  /**\n   * Boolean if the tree item is currently selected.\n   */\n  selected: boolean;\n\n  /**\n   * Boolean if the tree item is expanded. When this is true, it should add\n   * `aria-expanded=\"true\"` to the tree item.\n   */\n  expanded: boolean;\n\n  /**\n   * Boolean if the tree item is the current keyboard focus.\n   */\n  focused: boolean;\n}\n\nexport interface TreeItemProps\n  extends HTMLAttributes<HTMLLIElement>,\n    TreeItemStates,\n    TreeItemExpansionIcon,\n    ListItemChildrenProps,\n    Pick<SimpleListItemProps, \"threeLines\" | \"height\"> {\n  /**\n   * A DOM id for the tree item. This is required for a11y since this id should\n   * reflect the `aria-activedescendant` value on the base `Tree` component to\n   * show current keyboard focus.\n   */\n  id: string;\n\n  /**\n   * The current depth that the tree item is being rendered at. This will be a\n   * number starting from `1` since it should be directly mapped to\n   * `\"aria-posinset\"`.\n   */\n  depth: number;\n\n  /**\n   * The current tree item's index within its list at the provided depth. This\n   * will be a number starting from `1` since it should be directly mapped to\n   * `\"aria-posinset\"`.\n   */\n  itemIndex: number;\n\n  /**\n   * The current total list size for the tree item at the provided depth. This\n   * should be mapped directly into `\"aria-setsize\"`.\n   */\n  listSize: number;\n\n  /**\n   * This function will only be provided when the tree item has child tree\n   * items. This function should only be called within the exported `TreeGroup`\n   * component or in a component that has the `role=\"group\"` for accessibility.\n   */\n  renderChildItems?: () => ReactNode;\n\n  /**\n   * An optional `style` to apply to the surrounding `<li>` element for the tree\n   * item. The `style` prop is actually passed to the `contentComponent` element\n   * instead since you normally don't want to apply styles to the surrounding\n   * element.\n   */\n  liStyle?: CSSProperties;\n\n  /**\n   * An optional `className` to apply to the surrounding `<li>` element for the\n   * tree item. The `className` prop is actually passed to the\n   * `contentComponent` element instead since you normally don't want to apply\n   * styles to the surrounding element.\n   */\n  liClassName?: string;\n\n  /**\n   * An optional ref to apply to the content of the tree item.\n   */\n  liRef?: Ref<HTMLLIElement>;\n\n  /**\n   * Boolean if the `TreeItem` is a link component which changes up how the\n   * accessibility attributes are applied to the DOM. The default behavior is to\n   * check if the `contentComponent` is to consider it a link if it is not a\n   * string (custom component) or the string: `\"a\"`. Since this might cause some\n   * false-positives, you can set this flag instead which will always be used\n   * instead.\n   */\n  isLink?: boolean;\n\n  /**\n   * The component to render the item's content in. This should normally stay as\n   * the default `\"span\"` element, but if you'd like to make a navigation tree,\n   * this can be set as a `Link` component from a routing library.\n   *\n   * Example:\n   * ```\n   * <TreeItem href=\"#\" contentComponent=\"a\" />\n   *\n   * <TreeItem to=\"/example-url\" contentComponent={Link} exact />\n   * ```\n   */\n  contentComponent?: ElementType;\n\n  /**\n   * Boolean if the tree item is read only. Not sure why this was added though\n   * since `<li>` elements don't support `readOnly`.\n   */\n  readOnly?: boolean;\n\n  /**\n   * Boolean if the tree item is disabled which will prevent it from being\n   * interactable. It will still be \"keyboard focusable\" while disabled, but\n   * clicking or selecting won't work.\n   */\n  disabled?: boolean;\n}\n\nexport interface TreeItemWithContentComponentProps extends TreeItemProps {\n  /**\n   * Since I allow the `contentComponent` prop for handling rendering `<a>` tags\n   * from other routing libraries, I unfortunately need an index key so that\n   * those props can be passed down correctly.\n   */\n  [key: string]: unknown;\n}\n\nexport type ConfigurableTreeItemProps = Omit<\n  TreeItemProps,\n  | \"id\"\n  | \"depth\"\n  | \"itemIndex\"\n  | \"listSize\"\n  | \"selected\"\n  | \"expanded\"\n  | \"focused\"\n  | \"renderChildItems\"\n> & { children?: ReactNode };\n\ntype TreeItemKeys =\n  | \"id\"\n  | \"depth\"\n  | \"itemIndex\"\n  | \"listSize\"\n  | \"selected\"\n  | \"expanded\"\n  | \"focused\"\n  | \"renderChildItems\";\n\nexport interface ProvidedTreeItemProps\n  extends Pick<TreeItemProps, TreeItemKeys> {\n  /**\n   * React `key`s aren't really \"props\", but it will be provided to each\n   * `TreeItem` automatically.\n   */\n  key: string;\n\n  /**\n   * A ref that **must** be passed down to each `TreeItem` so that keyboard\n   * accessibility works.  This will be omitted when the `isCustom` key is\n   * enabled on the item.\n   */\n  liRef?: MutableRefObject<HTMLLIElement | null>;\n\n  /**\n   * A click handler that allows for the item to be selected or expanded. This\n   * will be omitted when the `isCustom` key is enabled on the item.\n   */\n  onClick?: React.MouseEventHandler<HTMLLIElement>;\n}\n\nexport interface TreeProps<T extends BaseTreeItem = UnknownTreeItem>\n  extends ListProps,\n    TreeItemExpansionIcon,\n    TreeItemExpansion,\n    TreeItemSelection {\n  /**\n   * The id for the tree element. This is required for a lot of accessibility features.\n   */\n  id: string;\n\n  /**\n   * An optional label string that describes this tree. Either this or the\n   * `aria-labelledby` prop are required for a11y.\n   */\n  \"aria-label\"?: string;\n\n  /**\n   * An optional id that points to an element that labels this tree. Either this\n   * or the `aria-label` prop are required for a11y.\n   */\n  \"aria-labelledby\"?: string;\n\n  /**\n   * The data to render within the tree.\n   */\n  data: TreeData<T>;\n\n  /**\n   * An optional id to use to determine the root items within the tree. You'll\n   * most likely want to keep this as the default of `null`, but it can also be\n   * used if you have a different identifier for root items.\n   */\n  rootId?: null | TreeItemId;\n\n  /**\n   * @see TreeItemSorter\n   */\n  sort?: TreeItemSorter<T>;\n\n  /**\n   * A function that gets called to render each `TreeItem` within the tree. This\n   * can be overridden if you need to add additional functionality around the\n   * `TreeItem` (such as drag and drop). The default behavior is to extract the\n   * `ListItem` props:\n   *\n   * - `leftAddon`\n   * - `leftAddonType`\n   * - `leftAddonPosition`\n   * - `rightAddon`\n   * - `rightAddonType`\n   * - `rightAddonPosition`\n   * - `children`\n   * - `to` / `href`\n   * - `isLink`\n   *\n   * and try to render as a `TreeItem` with those props. It will also override\n   * the `expanderLeft` and `expanderIcon` on the `TreeItem` with whatever was\n   * provided to the `Tree` component.\n   */\n  itemRenderer?: TreeItemRenderer<T>;\n\n  /**\n   * The key to use to extract a renderable label from each tree item. This will\n   * be displayed in the DOM as the `children` in each tree item.\n   */\n  labelKey?: string;\n\n  /**\n   * The key to use to extract a text string from each tree item. This is used\n   * for keyboard accessibility and being able to \"search\" the tree for items\n   * starting with the typed letters.\n   */\n  valueKey?: string;\n\n  /**\n   * A function to extract the renderable label from each tree item. The default\n   * behavior will be to just return `item[labelKey]`.\n   */\n  getItemLabel?: (item: T, labelKey: string) => ReactNode;\n\n  /**\n   * A function to extract the text string from each tree item. The default\n   * behavior will be to return the `item[valueKey]` and stringify it.\n   */\n  getItemValue?: (item: T, valueKey: string) => string;\n\n  /**\n   * @see GetItemProps\n   */\n  getItemProps?: GetItemProps<T>;\n\n  /**\n   * The component to use for any treeitem that has a `to`, `href`, or `isLink`\n   * attribute. This is a nice way to be able to update treeitems to be links\n   * instead of storing the `contentComponent` in the tree's data.\n   */\n  linkComponent?: ElementType;\n}\n\nexport type ProvidedTreeProps = Pick<TreeProps, \"linkComponent\" | \"id\"> &\n  Required<\n    Pick<\n      TreeProps,\n      | \"rootId\"\n      | \"multiSelect\"\n      | \"labelKey\"\n      | \"valueKey\"\n      | \"getItemLabel\"\n      | \"getItemValue\"\n      | \"getItemProps\"\n      | \"expanderLeft\"\n      | \"expanderIcon\"\n    >\n  >;\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}