{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { forwardRef } from \"react\";\nimport cn from \"classnames\";\nimport { useInteractionStates } from \"@react-md/states\";\nimport { bem } from \"@react-md/utils\";\nimport { Label } from \"../label/Label\";\nimport { useFocusState } from \"../useFocusState\";\nimport { ToggleContainer } from \"./ToggleContainer\";\nimport { InputToggleIcon } from \"./InputToggleIcon\";\nvar block = bem(\"rmd-toggle\");\nexport var InputToggle = forwardRef(function InputToggle(allProps, ref) {\n  var _a = allProps,\n    style = _a.style,\n    className = _a.className,\n    iconStyle = _a.iconStyle,\n    iconClassName = _a.iconClassName,\n    toggleStyle = _a.toggleStyle,\n    propToggleClassName = _a.toggleClassName,\n    inputStyle = _a.inputStyle,\n    inputClassName = _a.inputClassName,\n    icon = _a.icon,\n    propOnFocus = _a.onFocus,\n    propOnBlur = _a.onBlur,\n    _b = _a.error,\n    error = _b === void 0 ? false : _b,\n    _c = _a.inline,\n    inline = _c === void 0 ? false : _c,\n    _d = _a.stacked,\n    stacked = _d === void 0 ? false : _d,\n    _e = _a.disabled,\n    disabled = _e === void 0 ? false : _e,\n    label = _a.label,\n    labelStyle = _a.labelStyle,\n    labelClassName = _a.labelClassName,\n    labelDisabled = _a.labelDisabled,\n    _f = _a.iconAfter,\n    iconAfter = _f === void 0 ? false : _f,\n    _g = _a.disableIconOverlay,\n    disableIconOverlay = _g === void 0 ? false : _g,\n    disableRipple = _a.disableRipple,\n    disableProgrammaticRipple = _a.disableProgrammaticRipple,\n    rippleTimeout = _a.rippleTimeout,\n    rippleClassNames = _a.rippleClassNames,\n    children = _a.children,\n    indeterminate = _a.indeterminate,\n    props = __rest(_a, [\"style\", \"className\", \"iconStyle\", \"iconClassName\", \"toggleStyle\", \"toggleClassName\", \"inputStyle\", \"inputClassName\", \"icon\", \"onFocus\", \"onBlur\", \"error\", \"inline\", \"stacked\", \"disabled\", \"label\", \"labelStyle\", \"labelClassName\", \"labelDisabled\", \"iconAfter\", \"disableIconOverlay\", \"disableRipple\", \"disableProgrammaticRipple\", \"rippleTimeout\", \"rippleClassNames\", \"children\", \"indeterminate\"]);\n  var id = props.id,\n    type = props.type;\n  var _h = useInteractionStates({\n      handlers: props,\n      disabled: disabled,\n      className: propToggleClassName,\n      disableRipple: disableRipple,\n      disableProgrammaticRipple: disableProgrammaticRipple,\n      rippleTimeout: rippleTimeout,\n      rippleClassNames: rippleClassNames\n    }),\n    ripples = _h.ripples,\n    handlers = _h.handlers,\n    toggleClassName = _h.className;\n  var _j = __read(useFocusState({\n      onFocus: propOnFocus,\n      onBlur: propOnBlur\n    }), 3),\n    focused = _j[0],\n    onFocus = _j[1],\n    onBlur = _j[2];\n  var labelEl = _jsx(Label, __assign({\n    style: labelStyle,\n    className: labelClassName,\n    htmlFor: id,\n    error: error,\n    disabled: typeof labelDisabled === \"boolean\" ? labelDisabled : disabled\n  }, {\n    children: label\n  }));\n  return _jsxs(ToggleContainer, __assign({\n    style: style,\n    className: className,\n    inline: inline,\n    stacked: stacked\n  }, {\n    children: [iconAfter && labelEl, _jsxs(\"span\", __assign({\n      style: toggleStyle,\n      className: cn(block({\n        focused: focused,\n        disabled: disabled\n      }), toggleClassName)\n    }, {\n      children: [_jsx(\"input\", __assign({}, props, handlers, {\n        ref: ref,\n        style: inputStyle,\n        disabled: disabled,\n        onFocus: onFocus,\n        onBlur: onBlur,\n        className: cn(block(\"input\"), inputClassName)\n      })), _jsx(InputToggleIcon, __assign({\n        circle: !disableIconOverlay && type === \"radio\",\n        disabled: disabled,\n        overlay: !disableIconOverlay,\n        indeterminate: indeterminate,\n        style: iconStyle,\n        className: iconClassName\n      }, {\n        children: icon\n      })), ripples, children]\n    })), !iconAfter && labelEl]\n  }));\n});","map":{"version":3,"names":["forwardRef","cn","useInteractionStates","bem","Label","useFocusState","ToggleContainer","InputToggleIcon","block","InputToggle","allProps","ref","_a","style","className","iconStyle","iconClassName","toggleStyle","propToggleClassName","toggleClassName","inputStyle","inputClassName","icon","propOnFocus","onFocus","propOnBlur","onBlur","_b","error","_c","inline","_d","stacked","_e","disabled","label","labelStyle","labelClassName","labelDisabled","_f","iconAfter","_g","disableIconOverlay","disableRipple","disableProgrammaticRipple","rippleTimeout","rippleClassNames","children","indeterminate","props","__rest","id","type","_h","handlers","ripples","_j","__read","focused","labelEl","_jsx","__assign","htmlFor","_jsxs","circle","overlay"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\form\\src\\toggle\\InputToggle.tsx"],"sourcesContent":["import type { CSSProperties, InputHTMLAttributes, ReactNode } from \"react\";\nimport { forwardRef } from \"react\";\nimport cn from \"classnames\";\nimport type { InteractionStatesOptions } from \"@react-md/states\";\nimport { useInteractionStates } from \"@react-md/states\";\nimport { bem } from \"@react-md/utils\";\n\nimport { Label } from \"../label/Label\";\nimport { useFocusState } from \"../useFocusState\";\nimport { ToggleContainer } from \"./ToggleContainer\";\nimport { InputToggleIcon } from \"./InputToggleIcon\";\n\n/**\n * The props for a checkbox or radio input element.\n *\n * Note: The `readOnly` attribute is not valid for these input types since they\n * update the `checked` property while `readOnly` is specific to `value` itself.\n */\nexport interface InputToggleProps\n  extends Omit<InputHTMLAttributes<HTMLInputElement>, \"type\" | \"readOnly\">,\n    Pick<\n      InteractionStatesOptions,\n      | \"rippleTimeout\"\n      | \"disableRipple\"\n      | \"disableProgrammaticRipple\"\n      | \"disablePressedFallback\"\n      | \"rippleClassNames\"\n    > {\n  /**\n   * The id for the radio or checkbox. This is required for a11y and will be\n   * used as the `for` attribute if the `label` prop is provided.\n   */\n  id: string;\n\n  /**\n   * The icon to use for either a radio or a checkbox.\n   */\n  icon?: ReactNode;\n\n  /**\n   * An optional style to apply to the `<span>` surrounding the toggle icon.\n   */\n  iconStyle?: CSSProperties;\n\n  /**\n   * An optional className to apply to the `<span>` surrounding the toggle icon.\n   */\n  iconClassName?: string;\n\n  /**\n   * An optional style to apply to the toggle `<span>` element. The `style` prop\n   * will be applied to the container `<div>` element instead.\n   */\n  toggleStyle?: CSSProperties;\n\n  /**\n   * An optional className to apply to the toggle `<span>` element. The\n   * `className` prop will be applied to the container `<div>` element instead.\n   */\n  toggleClassName?: string;\n\n  /**\n   * An optional `style` to provide to the invisible `<input>` element that is\n   * used to toggle the checked state. This prop is only available since the\n   * `style` prop is passed to the container element, but you probably shouldn't\n   * really style this element anyways.\n   *\n   * @remarks \\@since 2.2.0\n   */\n  inputStyle?: CSSProperties;\n\n  /**\n   * An optional `className` to provide to the invisible `<input>` element that\n   * is used to toggle the checked state. This prop does not have many uses and\n   * is really just provided since the `className` is passed to the container\n   * element instead of the `<input>`. However, this can be used to update the\n   * icon styles if needed using the `:checked` state:\n   *\n   * ```scss\n   * .custom-toggle-icon {\n   *   // styles\n   * }\n   *\n   * .custom-input:checked + .custom-toggle-icon {\n   *   // custom checked styles\n   * }\n   * ```\n   *\n   * @remarks \\@since 2.2.0\n   */\n  inputClassName?: string;\n\n  /**\n   * Boolean if the icon's overlay should be disabled. The way the Checkbox and\n   * Radio input elements work is by applying different opacity to the\n   * `::before` and `::after` pseudo selectors and animating it. If you want to\n   * use a custom icon that is not a material-icon checkbox outline or radio\n   * button, you should probably enable this prop.\n   */\n  disableIconOverlay?: boolean;\n\n  /**\n   * Boolean if the input toggle is currently errored. This will update the\n   * label and the input to gain error colors.\n   */\n  error?: boolean;\n\n  /**\n   * Boolean if the container element should be rendered as `inline-flex`\n   * instead of `flex`.\n   */\n  inline?: boolean;\n\n  /**\n   * Boolean if the label should be stacked above/below the input toggle instead\n   * of inline.\n   */\n  stacked?: boolean;\n\n  /**\n   * An optional label to display with the input. If this prop is omitted, you\n   * **should** apply an `aria-label` or `aria-labelledby` for a11y.\n   */\n  label?: ReactNode;\n\n  /**\n   * An optional style to apply to the `<label>` when the `label` prop is used.\n   */\n  labelStyle?: CSSProperties;\n\n  /**\n   * An optional className to apply to the `<label>` when the `label` prop is\n   * used.\n   */\n  labelClassName?: string;\n\n  /**\n   * An optional boolean if the label should gain the disabled style. When this\n   * is `undefined`, the `disabled` prop will be used instead. This is really\n   * just useful when you want to disable the switch from being toggled while\n   * some async action is being called, but not changing styles during the wait.\n   */\n  labelDisabled?: boolean;\n\n  /**\n   * Boolean if the input toggle should appear after the label instead of\n   * before.\n   */\n  iconAfter?: boolean;\n\n  /**\n   * Optional content to render after the icon element.\n   */\n  children?: ReactNode;\n}\n\ntype Props = InputToggleProps &\n  ({ type: \"radio\" } | { type: \"checkbox\"; indeterminate?: boolean });\ntype CheckboxOrRadioProps = InputToggleProps & {\n  type: \"checkbox\" | \"radio\";\n  indeterminate?: boolean;\n};\n\nconst block = bem(\"rmd-toggle\");\n\nexport const InputToggle = forwardRef<HTMLInputElement, Props>(\n  function InputToggle(allProps, ref) {\n    const {\n      style,\n      className,\n      iconStyle,\n      iconClassName,\n      toggleStyle,\n      toggleClassName: propToggleClassName,\n      inputStyle,\n      inputClassName,\n      icon,\n      onFocus: propOnFocus,\n      onBlur: propOnBlur,\n      error = false,\n      inline = false,\n      stacked = false,\n      disabled = false,\n      label,\n      labelStyle,\n      labelClassName,\n      labelDisabled,\n      iconAfter = false,\n      disableIconOverlay = false,\n      disableRipple,\n      disableProgrammaticRipple,\n      rippleTimeout,\n      rippleClassNames,\n      children,\n      indeterminate,\n      ...props\n    } = allProps as CheckboxOrRadioProps;\n\n    const { id, type } = props;\n\n    const {\n      ripples,\n      handlers,\n      className: toggleClassName,\n    } = useInteractionStates({\n      handlers: props,\n      disabled,\n      className: propToggleClassName,\n      disableRipple,\n      disableProgrammaticRipple,\n      rippleTimeout,\n      rippleClassNames,\n    });\n    const [focused, onFocus, onBlur] = useFocusState({\n      onFocus: propOnFocus,\n      onBlur: propOnBlur,\n    });\n\n    const labelEl = (\n      <Label\n        style={labelStyle}\n        className={labelClassName}\n        htmlFor={id}\n        error={error}\n        disabled={typeof labelDisabled === \"boolean\" ? labelDisabled : disabled}\n      >\n        {label}\n      </Label>\n    );\n\n    return (\n      <ToggleContainer\n        style={style}\n        className={className}\n        inline={inline}\n        stacked={stacked}\n      >\n        {iconAfter && labelEl}\n        <span\n          style={toggleStyle}\n          className={cn(\n            block({\n              focused,\n              disabled,\n            }),\n            toggleClassName\n          )}\n        >\n          <input\n            {...props}\n            {...handlers}\n            ref={ref}\n            style={inputStyle}\n            disabled={disabled}\n            onFocus={onFocus}\n            onBlur={onBlur}\n            className={cn(block(\"input\"), inputClassName)}\n          />\n          <InputToggleIcon\n            circle={!disableIconOverlay && type === \"radio\"}\n            disabled={disabled}\n            overlay={!disableIconOverlay}\n            indeterminate={indeterminate}\n            style={iconStyle}\n            className={iconClassName}\n          >\n            {icon}\n          </InputToggleIcon>\n          {ripples}\n          {children}\n        </span>\n        {!iconAfter && labelEl}\n      </ToggleContainer>\n    );\n  }\n);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}