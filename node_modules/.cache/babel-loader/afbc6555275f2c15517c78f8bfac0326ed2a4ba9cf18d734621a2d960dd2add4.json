{"ast":null,"code":"import { useEffect, useRef } from \"react\";\n/**\n * This hook is used to focus the previous element when a component unmounts.\n * The default behavior is to store the current activeElement within the\n * document when the component mounts and then try to focus it again when the\n * component unmounts.  You can also provide your own HTMLElement to focus when\n * unmounting.\n *\n * During the unmount phase, it will wait for an animation frame before checking\n * if the fallback element still exists within the page. If it doesn't, it will\n * use the fallback query/element/function to attempt to find another element to\n * focus. If the element exists within the page, it will then finally be\n * focused.\n *\n * The animation frame is unfortunately required for keyboard users as pressing\n * enter key will click the previous element immediately on focus as well.\n *\n * @param disabled - Boolean if the focus behavior should be disabled.\n * @param fallback - The fallback query, element, or function to use if the\n * previous element no longer exists in the DOM.\n * @param previousElement - An optional previous element to focus. If this is\n * omitted, the `document.activeElement` will be used instead.\n */\nexport function usePreviousFocus(disabled, fallback, previousElement) {\n  if (fallback === void 0) {\n    fallback = undefined;\n  }\n  if (previousElement === void 0) {\n    previousElement = null;\n  }\n  var options = useRef({\n    disabled: disabled,\n    fallback: fallback\n  });\n  useEffect(function () {\n    options.current = {\n      disabled: disabled,\n      fallback: fallback\n    };\n  });\n  useEffect(function () {\n    if (disabled) {\n      return;\n    }\n    var element = previousElement || document.activeElement;\n    // i'll need to think of a better way to handle this flow. There's just a\n    // weird one where if going from a menu to a dialog, we get lost without\n    // specifying a fallback. So if we are in a menu, try to find the\n    // corresponding menu button for this flow to fallback to.\n    var menu = element.closest('[role=\"menu\"]');\n    var menuButton = null;\n    if (menu) {\n      // first try to get the button by using the menu's id minus the trailing\n      // -menu since that's the normal pattern within react-md.\n      menuButton = document.getElementById(menu.id.replace(/-menu$/, \"\"));\n      if (!menuButton) {\n        // if no menu button, try to see if the `aria-labelledby` points to the\n        // button... but since the `aria-labelledby` is a space-delimitated\n        // string of ids, have to check each one\n        var labelledBy = menu.getAttribute(\"aria-labelledby\") || \"\";\n        var query = labelledBy.split(\" \").map(function (id) {\n          return \"#\".concat(id, \"[tabindex]\");\n        }).join(\",\");\n        menuButton = query ? document.querySelector(query) : null;\n      }\n    }\n    return function () {\n      var _a = options.current,\n        fallback = _a.fallback,\n        disabled = _a.disabled;\n      if (disabled) {\n        // this has been added just for support for scrolling menus out of view.\n        // It is not ideal since keyboard focus is lost at this point, but\n        // _technically_ shouldn't be able to reach this flow with keyboard\n        // movement\n        return;\n      }\n      if (menu && menuButton && !previousElement && !fallback && !document.contains(element) && document.contains(menuButton)) {\n        menuButton.focus();\n        return;\n      }\n      var el = element;\n      if (!document.contains(el)) {\n        el = previousElement && document.contains(previousElement) ? previousElement : null;\n      }\n      if (!el && fallback) {\n        switch (typeof fallback) {\n          case \"string\":\n            el = document.querySelector(fallback);\n            break;\n          case \"function\":\n            el = fallback();\n            break;\n          default:\n            el = fallback;\n        }\n      }\n      if (el && !document.contains(el)) {\n        el = null;\n      }\n      if (el) {\n        el.focus();\n      }\n    };\n    // disabled since useRefCache and don't wnt to update on disabled change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n}","map":{"version":3,"names":["useEffect","useRef","usePreviousFocus","disabled","fallback","previousElement","undefined","options","current","element","document","activeElement","menu","closest","menuButton","getElementById","id","replace","labelledBy","getAttribute","query","split","map","concat","join","querySelector","_a","contains","focus","el"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\utils\\src\\wia-aria\\usePreviousFocus.ts"],"sourcesContent":["import { useEffect, useRef } from \"react\";\n\n/**\n * This can either be a query selector string, a specific HTMLElement, or a\n * function that finds a specific HTMLElement to focus.\n */\nexport type FocusFallback =\n  | string\n  | HTMLElement\n  | (() => HTMLElement | null)\n  | null\n  | undefined;\n\n/**\n * This hook is used to focus the previous element when a component unmounts.\n * The default behavior is to store the current activeElement within the\n * document when the component mounts and then try to focus it again when the\n * component unmounts.  You can also provide your own HTMLElement to focus when\n * unmounting.\n *\n * During the unmount phase, it will wait for an animation frame before checking\n * if the fallback element still exists within the page. If it doesn't, it will\n * use the fallback query/element/function to attempt to find another element to\n * focus. If the element exists within the page, it will then finally be\n * focused.\n *\n * The animation frame is unfortunately required for keyboard users as pressing\n * enter key will click the previous element immediately on focus as well.\n *\n * @param disabled - Boolean if the focus behavior should be disabled.\n * @param fallback - The fallback query, element, or function to use if the\n * previous element no longer exists in the DOM.\n * @param previousElement - An optional previous element to focus. If this is\n * omitted, the `document.activeElement` will be used instead.\n */\nexport function usePreviousFocus(\n  disabled: boolean,\n  fallback: FocusFallback = undefined,\n  previousElement: HTMLElement | null = null\n): void {\n  const options = useRef({\n    disabled,\n    fallback,\n  });\n\n  useEffect(() => {\n    options.current = {\n      disabled,\n      fallback,\n    };\n  });\n\n  useEffect(() => {\n    if (disabled) {\n      return;\n    }\n\n    const element = previousElement || (document.activeElement as HTMLElement);\n\n    // i'll need to think of a better way to handle this flow. There's just a\n    // weird one where if going from a menu to a dialog, we get lost without\n    // specifying a fallback. So if we are in a menu, try to find the\n    // corresponding menu button for this flow to fallback to.\n    const menu = element.closest('[role=\"menu\"]');\n    let menuButton: HTMLElement | null = null;\n    if (menu) {\n      // first try to get the button by using the menu's id minus the trailing\n      // -menu since that's the normal pattern within react-md.\n      menuButton = document.getElementById(menu.id.replace(/-menu$/, \"\"));\n      if (!menuButton) {\n        // if no menu button, try to see if the `aria-labelledby` points to the\n        // button... but since the `aria-labelledby` is a space-delimitated\n        // string of ids, have to check each one\n        const labelledBy = menu.getAttribute(\"aria-labelledby\") || \"\";\n        const query = labelledBy\n          .split(\" \")\n          .map((id) => `#${id}[tabindex]`)\n          .join(\",\");\n\n        menuButton = query ? document.querySelector<HTMLElement>(query) : null;\n      }\n    }\n\n    return () => {\n      const { fallback, disabled } = options.current;\n      if (disabled) {\n        // this has been added just for support for scrolling menus out of view.\n        // It is not ideal since keyboard focus is lost at this point, but\n        // _technically_ shouldn't be able to reach this flow with keyboard\n        // movement\n        return;\n      }\n\n      if (\n        menu &&\n        menuButton &&\n        !previousElement &&\n        !fallback &&\n        !document.contains(element) &&\n        document.contains(menuButton)\n      ) {\n        menuButton.focus();\n        return;\n      }\n\n      let el: HTMLElement | null = element;\n      if (!document.contains(el)) {\n        el =\n          previousElement && document.contains(previousElement)\n            ? previousElement\n            : null;\n      }\n\n      if (!el && fallback) {\n        switch (typeof fallback) {\n          case \"string\":\n            el = document.querySelector<HTMLElement>(fallback);\n            break;\n          case \"function\":\n            el = fallback();\n            break;\n          default:\n            el = fallback;\n        }\n      }\n\n      if (el && !document.contains(el)) {\n        el = null;\n      }\n\n      if (el) {\n        el.focus();\n      }\n    };\n    // disabled since useRefCache and don't wnt to update on disabled change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n}\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAazC;;;;;;;;;;;;;;;;;;;;;;AAsBA,OAAM,SAAUC,gBAAgBA,CAC9BC,QAAiB,EACjBC,QAAmC,EACnCC,eAA0C;EAD1C,IAAAD,QAAA;IAAAA,QAAA,GAAAE,SAAmC;EAAA;EACnC,IAAAD,eAAA;IAAAA,eAAA,OAA0C;EAAA;EAE1C,IAAME,OAAO,GAAGN,MAAM,CAAC;IACrBE,QAAQ,EAAAA,QAAA;IACRC,QAAQ,EAAAA;GACT,CAAC;EAEFJ,SAAS,CAAC;IACRO,OAAO,CAACC,OAAO,GAAG;MAChBL,QAAQ,EAAAA,QAAA;MACRC,QAAQ,EAAAA;KACT;EACH,CAAC,CAAC;EAEFJ,SAAS,CAAC;IACR,IAAIG,QAAQ,EAAE;MACZ;;IAGF,IAAMM,OAAO,GAAGJ,eAAe,IAAKK,QAAQ,CAACC,aAA6B;IAE1E;IACA;IACA;IACA;IACA,IAAMC,IAAI,GAAGH,OAAO,CAACI,OAAO,CAAC,eAAe,CAAC;IAC7C,IAAIC,UAAU,GAAuB,IAAI;IACzC,IAAIF,IAAI,EAAE;MACR;MACA;MACAE,UAAU,GAAGJ,QAAQ,CAACK,cAAc,CAACH,IAAI,CAACI,EAAE,CAACC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;MACnE,IAAI,CAACH,UAAU,EAAE;QACf;QACA;QACA;QACA,IAAMI,UAAU,GAAGN,IAAI,CAACO,YAAY,CAAC,iBAAiB,CAAC,IAAI,EAAE;QAC7D,IAAMC,KAAK,GAAGF,UAAU,CACrBG,KAAK,CAAC,GAAG,CAAC,CACVC,GAAG,CAAC,UAACN,EAAE;UAAK,WAAAO,MAAA,CAAIP,EAAE,eAAY;QAAlB,CAAkB,CAAC,CAC/BQ,IAAI,CAAC,GAAG,CAAC;QAEZV,UAAU,GAAGM,KAAK,GAAGV,QAAQ,CAACe,aAAa,CAAcL,KAAK,CAAC,GAAG,IAAI;;;IAI1E,OAAO;MACC,IAAAM,EAAA,GAAyBnB,OAAO,CAACC,OAAO;QAAtCJ,QAAQ,GAAAsB,EAAA,CAAAtB,QAAA;QAAED,QAAQ,GAAAuB,EAAA,CAAAvB,QAAoB;MAC9C,IAAIA,QAAQ,EAAE;QACZ;QACA;QACA;QACA;QACA;;MAGF,IACES,IAAI,IACJE,UAAU,IACV,CAACT,eAAe,IAChB,CAACD,QAAQ,IACT,CAACM,QAAQ,CAACiB,QAAQ,CAAClB,OAAO,CAAC,IAC3BC,QAAQ,CAACiB,QAAQ,CAACb,UAAU,CAAC,EAC7B;QACAA,UAAU,CAACc,KAAK,EAAE;QAClB;;MAGF,IAAIC,EAAE,GAAuBpB,OAAO;MACpC,IAAI,CAACC,QAAQ,CAACiB,QAAQ,CAACE,EAAE,CAAC,EAAE;QAC1BA,EAAE,GACAxB,eAAe,IAAIK,QAAQ,CAACiB,QAAQ,CAACtB,eAAe,CAAC,GACjDA,eAAe,GACf,IAAI;;MAGZ,IAAI,CAACwB,EAAE,IAAIzB,QAAQ,EAAE;QACnB,QAAQ,OAAOA,QAAQ;UACrB,KAAK,QAAQ;YACXyB,EAAE,GAAGnB,QAAQ,CAACe,aAAa,CAAcrB,QAAQ,CAAC;YAClD;UACF,KAAK,UAAU;YACbyB,EAAE,GAAGzB,QAAQ,EAAE;YACf;UACF;YACEyB,EAAE,GAAGzB,QAAQ;;;MAInB,IAAIyB,EAAE,IAAI,CAACnB,QAAQ,CAACiB,QAAQ,CAACE,EAAE,CAAC,EAAE;QAChCA,EAAE,GAAG,IAAI;;MAGX,IAAIA,EAAE,EAAE;QACNA,EAAE,CAACD,KAAK,EAAE;;IAEd,CAAC;IACD;IACA;EACF,CAAC,EAAE,EAAE,CAAC;AACR"},"metadata":{},"sourceType":"module","externalDependencies":[]}