{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useEffect, useMemo, useRef } from \"react\";\nimport { DEFAULT_DESKTOP_LARGE_MIN_WIDTH, DEFAULT_DESKTOP_MIN_WIDTH, DEFAULT_PHONE_MAX_WIDTH, DEFAULT_TABLET_MAX_WIDTH, DEFAULT_TABLET_MIN_WIDTH } from \"./constants\";\nimport { AppSizeContext } from \"./useAppSize\";\nimport { DEFAULT_APP_SIZE, useAppSizeMedia } from \"./useAppSizeMedia\";\n/**\n * This component should be mounted near the top of your app as it will keep\n * track of the current app size based on the provided breakpoint widths.\n */\nexport function AppSizeListener(_a) {\n  var children = _a.children,\n    onChange = _a.onChange,\n    _b = _a.phoneMaxWidth,\n    phoneMaxWidth = _b === void 0 ? DEFAULT_PHONE_MAX_WIDTH : _b,\n    _c = _a.tabletMinWidth,\n    tabletMinWidth = _c === void 0 ? DEFAULT_TABLET_MIN_WIDTH : _c,\n    _d = _a.tabletMaxWidth,\n    tabletMaxWidth = _d === void 0 ? DEFAULT_TABLET_MAX_WIDTH : _d,\n    _e = _a.desktopMinWidth,\n    desktopMinWidth = _e === void 0 ? DEFAULT_DESKTOP_MIN_WIDTH : _e,\n    _f = _a.desktopLargeMinWidth,\n    desktopLargeMinWidth = _f === void 0 ? DEFAULT_DESKTOP_LARGE_MIN_WIDTH : _f,\n    _g = _a.defaultSize,\n    defaultSize = _g === void 0 ? DEFAULT_APP_SIZE : _g;\n  var appSize = useAppSizeMedia({\n    phoneMaxWidth: phoneMaxWidth,\n    tabletMaxWidth: tabletMaxWidth,\n    tabletMinWidth: tabletMinWidth,\n    desktopMinWidth: desktopMinWidth,\n    desktopLargeMinWidth: desktopLargeMinWidth,\n    defaultSize: defaultSize\n  });\n  var lastValue = useRef(appSize);\n  useEffect(function () {\n    // trigger the onChange prop on mount only if there is a difference between\n    // the defaultSize and the mounted size.\n    if (onChange && (defaultSize.isPhone !== appSize.isPhone || defaultSize.isTablet !== appSize.isTablet || defaultSize.isDesktop !== appSize.isDesktop || defaultSize.isLargeDesktop !== appSize.isLargeDesktop || defaultSize.isLandscape !== appSize.isLandscape)) {\n      onChange(appSize, defaultSize);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  useEffect(function () {\n    if (lastValue.current !== appSize) {\n      if (onChange) {\n        onChange(appSize, lastValue.current);\n      }\n      lastValue.current = appSize;\n    }\n  });\n  var value = useMemo(function () {\n    return __assign(__assign({}, appSize), {\n      __initialized: true\n    });\n  }, [appSize]);\n  return _jsx(AppSizeContext.Provider, __assign({\n    value: value\n  }, {\n    children: children\n  }));\n}","map":{"version":3,"names":["useEffect","useMemo","useRef","DEFAULT_DESKTOP_LARGE_MIN_WIDTH","DEFAULT_DESKTOP_MIN_WIDTH","DEFAULT_PHONE_MAX_WIDTH","DEFAULT_TABLET_MAX_WIDTH","DEFAULT_TABLET_MIN_WIDTH","AppSizeContext","DEFAULT_APP_SIZE","useAppSizeMedia","AppSizeListener","_a","children","onChange","_b","phoneMaxWidth","_c","tabletMinWidth","_d","tabletMaxWidth","_e","desktopMinWidth","_f","desktopLargeMinWidth","_g","defaultSize","appSize","lastValue","isPhone","isTablet","isDesktop","isLargeDesktop","isLandscape","current","value","__assign","__initialized","_jsx","Provider"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\utils\\src\\sizing\\AppSizeListener.tsx"],"sourcesContent":["import type { ReactElement, ReactNode } from \"react\";\nimport { useEffect, useMemo, useRef } from \"react\";\n\nimport {\n  DEFAULT_DESKTOP_LARGE_MIN_WIDTH,\n  DEFAULT_DESKTOP_MIN_WIDTH,\n  DEFAULT_PHONE_MAX_WIDTH,\n  DEFAULT_TABLET_MAX_WIDTH,\n  DEFAULT_TABLET_MIN_WIDTH,\n} from \"./constants\";\nimport { AppSizeContext } from \"./useAppSize\";\nimport type { AppSize, AppSizeOptions } from \"./useAppSizeMedia\";\nimport { DEFAULT_APP_SIZE, useAppSizeMedia } from \"./useAppSizeMedia\";\n\nexport interface AppSizeListenerProps extends AppSizeOptions {\n  children: ReactNode;\n\n  /**\n   * An change handler for the app size. This will be called each time the app\n   * size changes based on a window resize event and will be provided the next\n   * size and the previous size.\n   */\n  onChange?: (nextSize: AppSize, lastSize: AppSize) => void;\n}\n\n/**\n * This component should be mounted near the top of your app as it will keep\n * track of the current app size based on the provided breakpoint widths.\n */\nexport function AppSizeListener({\n  children,\n  onChange,\n  phoneMaxWidth = DEFAULT_PHONE_MAX_WIDTH,\n  tabletMinWidth = DEFAULT_TABLET_MIN_WIDTH,\n  tabletMaxWidth = DEFAULT_TABLET_MAX_WIDTH,\n  desktopMinWidth = DEFAULT_DESKTOP_MIN_WIDTH,\n  desktopLargeMinWidth = DEFAULT_DESKTOP_LARGE_MIN_WIDTH,\n  defaultSize = DEFAULT_APP_SIZE,\n}: AppSizeListenerProps): ReactElement {\n  const appSize = useAppSizeMedia({\n    phoneMaxWidth,\n    tabletMaxWidth,\n    tabletMinWidth,\n    desktopMinWidth,\n    desktopLargeMinWidth,\n    defaultSize,\n  });\n  const lastValue = useRef(appSize);\n\n  useEffect(() => {\n    // trigger the onChange prop on mount only if there is a difference between\n    // the defaultSize and the mounted size.\n    if (\n      onChange &&\n      (defaultSize.isPhone !== appSize.isPhone ||\n        defaultSize.isTablet !== appSize.isTablet ||\n        defaultSize.isDesktop !== appSize.isDesktop ||\n        defaultSize.isLargeDesktop !== appSize.isLargeDesktop ||\n        defaultSize.isLandscape !== appSize.isLandscape)\n    ) {\n      onChange(appSize, defaultSize);\n    }\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  useEffect(() => {\n    if (lastValue.current !== appSize) {\n      if (onChange) {\n        onChange(appSize, lastValue.current);\n      }\n\n      lastValue.current = appSize;\n    }\n  });\n\n  const value = useMemo(\n    () => ({\n      ...appSize,\n      __initialized: true,\n    }),\n    [appSize]\n  );\n  return (\n    <AppSizeContext.Provider value={value}>{children}</AppSizeContext.Provider>\n  );\n}\n"],"mappings":";;;;;;;;;;;AACA,SAASA,SAAS,EAAEC,OAAO,EAAEC,MAAM,QAAQ,OAAO;AAElD,SACEC,+BAA+B,EAC/BC,yBAAyB,EACzBC,uBAAuB,EACvBC,wBAAwB,EACxBC,wBAAwB,QACnB,aAAa;AACpB,SAASC,cAAc,QAAQ,cAAc;AAE7C,SAASC,gBAAgB,EAAEC,eAAe,QAAQ,mBAAmB;AAarE;;;;AAIA,OAAM,SAAUC,eAAeA,CAACC,EAST;MARrBC,QAAQ,GAAAD,EAAA,CAAAC,QAAA;IACRC,QAAQ,GAAAF,EAAA,CAAAE,QAAA;IACRC,EAAA,GAAAH,EAAA,CAAAI,aAAuC;IAAvCA,aAAa,GAAAD,EAAA,cAAGV,uBAAuB,GAAAU,EAAA;IACvCE,EAAA,GAAAL,EAAA,CAAAM,cAAyC;IAAzCA,cAAc,GAAAD,EAAA,cAAGV,wBAAwB,GAAAU,EAAA;IACzCE,EAAA,GAAAP,EAAA,CAAAQ,cAAyC;IAAzCA,cAAc,GAAAD,EAAA,cAAGb,wBAAwB,GAAAa,EAAA;IACzCE,EAAA,GAAAT,EAAA,CAAAU,eAA2C;IAA3CA,eAAe,GAAAD,EAAA,cAAGjB,yBAAyB,GAAAiB,EAAA;IAC3CE,EAAA,GAAAX,EAAA,CAAAY,oBAAsD;IAAtDA,oBAAoB,GAAAD,EAAA,cAAGpB,+BAA+B,GAAAoB,EAAA;IACtDE,EAAA,GAAAb,EAAA,CAAAc,WAA8B;IAA9BA,WAAW,GAAAD,EAAA,cAAGhB,gBAAgB,GAAAgB,EAAA;EAE9B,IAAME,OAAO,GAAGjB,eAAe,CAAC;IAC9BM,aAAa,EAAAA,aAAA;IACbI,cAAc,EAAAA,cAAA;IACdF,cAAc,EAAAA,cAAA;IACdI,eAAe,EAAAA,eAAA;IACfE,oBAAoB,EAAAA,oBAAA;IACpBE,WAAW,EAAAA;GACZ,CAAC;EACF,IAAME,SAAS,GAAG1B,MAAM,CAACyB,OAAO,CAAC;EAEjC3B,SAAS,CAAC;IACR;IACA;IACA,IACEc,QAAQ,KACPY,WAAW,CAACG,OAAO,KAAKF,OAAO,CAACE,OAAO,IACtCH,WAAW,CAACI,QAAQ,KAAKH,OAAO,CAACG,QAAQ,IACzCJ,WAAW,CAACK,SAAS,KAAKJ,OAAO,CAACI,SAAS,IAC3CL,WAAW,CAACM,cAAc,KAAKL,OAAO,CAACK,cAAc,IACrDN,WAAW,CAACO,WAAW,KAAKN,OAAO,CAACM,WAAW,CAAC,EAClD;MACAnB,QAAQ,CAACa,OAAO,EAAED,WAAW,CAAC;;IAGhC;EACF,CAAC,EAAE,EAAE,CAAC;EAEN1B,SAAS,CAAC;IACR,IAAI4B,SAAS,CAACM,OAAO,KAAKP,OAAO,EAAE;MACjC,IAAIb,QAAQ,EAAE;QACZA,QAAQ,CAACa,OAAO,EAAEC,SAAS,CAACM,OAAO,CAAC;;MAGtCN,SAAS,CAACM,OAAO,GAAGP,OAAO;;EAE/B,CAAC,CAAC;EAEF,IAAMQ,KAAK,GAAGlC,OAAO,CACnB;IAAM,OAAAmC,QAAA,CAAAA,QAAA,KACDT,OAAO;MACVU,aAAa,EAAE;IAAI;EAFf,CAGJ,EACF,CAACV,OAAO,CAAC,CACV;EACD,OACEW,IAAA,CAAC9B,cAAc,CAAC+B,QAAQ,EAAAH,QAAA;IAACD,KAAK,EAAEA;EAAK;IAAAtB,QAAA,EAAGA;EAAQ,GAA2B;AAE/E"},"metadata":{},"sourceType":"module","externalDependencies":[]}