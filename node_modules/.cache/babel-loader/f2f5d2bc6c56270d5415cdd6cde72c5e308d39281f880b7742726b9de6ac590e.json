{"ast":null,"code":"import { getCenterXCoord, getInnerLeftCoord, getInnerRightCoord, getLeftCoord, getRightCoord } from \"./getCoord\";\n/**\n * Attempts to position the fixed element so that it will appear to the left of\n * the container element but also within the viewport boundaries. When swapping\n * is enabled, it will attempt to swap to the right position if it can't fit\n * within the viewport to the left. If it can't fit in the viewport even after\n * being swapped to the right or swapping is disabled, it will be positioned to\n * the viewport left boundary.\n *\n * @internal\n */\nexport function createAnchoredLeft(config) {\n  var vwMargin = config.vwMargin,\n    screenRight = config.screenRight,\n    elWidth = config.elWidth,\n    disableSwapping = config.disableSwapping;\n  var left = getLeftCoord(config);\n  var actualX = \"left\";\n  if (left >= vwMargin) {\n    return {\n      actualX: actualX,\n      left: left\n    };\n  }\n  var swappedLeft = getRightCoord(config);\n  if (disableSwapping || swappedLeft + elWidth > screenRight) {\n    left = vwMargin;\n  } else {\n    left = swappedLeft;\n    actualX = \"right\";\n  }\n  return {\n    actualX: actualX,\n    left: left\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear to the\n * inner-left of the container element but also within the viewport boundaries.\n * When swapping is enabled, it will attempt to swap to the right position if it\n * can't fit within the viewport to the left. If it can't fit in the viewport\n * even after being swapped to the right or swapping is disabled, it will be\n * positioned to the viewport left boundary.\n *\n * @internal\n */\nexport function createAnchoredInnerLeft(config) {\n  var vwMargin = config.vwMargin,\n    screenRight = config.screenRight,\n    elWidth = config.elWidth,\n    disableSwapping = config.disableSwapping;\n  var left = getInnerLeftCoord(config);\n  var actualX = \"inner-left\";\n  if (left + elWidth <= screenRight && left >= vwMargin) {\n    return {\n      actualX: actualX,\n      left: left\n    };\n  }\n  if (disableSwapping) {\n    if (left + elWidth > screenRight) {\n      left = screenRight - elWidth;\n    } else {\n      left = vwMargin;\n    }\n    return {\n      actualX: actualX,\n      left: left\n    };\n  }\n  var swappedLeft = getInnerRightCoord(config);\n  if (swappedLeft < vwMargin) {\n    left = vwMargin;\n  } else if (swappedLeft + elWidth > screenRight) {\n    left = screenRight - elWidth;\n    actualX = \"inner-right\";\n  } else {\n    left = swappedLeft;\n    actualX = \"inner-right\";\n  }\n  return {\n    actualX: actualX,\n    left: left\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear at the center\n * of the container element but also within the viewport boundaries. If the\n * centered element can't fit within the viewport, it will use the vwMargin\n * value if it overflowed to the left, it'll position to the screen right\n * boundary.\n *\n * @internal\n */\nexport function createAnchoredCenter(config) {\n  var vwMargin = config.vwMargin,\n    screenRight = config.screenRight,\n    elWidth = config.elWidth;\n  var left = getCenterXCoord(config);\n  if (left < vwMargin) {\n    left = vwMargin;\n  } else if (left + elWidth > screenRight || left < vwMargin) {\n    left = screenRight - elWidth;\n  }\n  return {\n    actualX: \"center\",\n    left: left\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear to the\n * inner-right of the container element but also within the viewport boundaries.\n * When swapping is enabled, it will attempt to swap to the inner-left position\n * if it can't fit within the viewport to the right. If it can't fit in the\n * viewport even after being swapped to the left or swapping is disabled, it\n * will be positioned to the viewport right boundary.\n *\n * @internal\n */\nexport function createAnchoredInnerRight(config) {\n  var screenRight = config.screenRight,\n    vwMargin = config.vwMargin,\n    elWidth = config.elWidth,\n    disableSwapping = config.disableSwapping;\n  var left = getInnerRightCoord(config);\n  var actualX = \"inner-right\";\n  if (left >= vwMargin) {\n    return {\n      actualX: actualX,\n      left: Math.min(left, screenRight - elWidth)\n    };\n  }\n  var swappedLeft = getInnerLeftCoord(config);\n  if (disableSwapping || swappedLeft + elWidth > screenRight) {\n    left = vwMargin;\n  } else {\n    left = Math.max(swappedLeft, vwMargin);\n    actualX = \"inner-left\";\n  }\n  return {\n    actualX: actualX,\n    left: left\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear to the right of\n * the container element but also within the viewport boundaries. When swapping\n * is enabled, it will attempt to swap to the left position if it can't fit\n * within the viewport to the right. If it can't fit in the viewport even after\n * being swapped to the left or swapping is disabled, it will be positioned to\n * the viewport right boundary.\n *\n * @internal\n */\nexport function createAnchoredRight(config) {\n  var screenRight = config.screenRight,\n    vwMargin = config.vwMargin,\n    elWidth = config.elWidth,\n    disableSwapping = config.disableSwapping;\n  var left = getRightCoord(config);\n  var actualX = \"right\";\n  if (left + elWidth <= screenRight) {\n    return {\n      actualX: actualX,\n      left: left\n    };\n  }\n  var swappedLeft = getLeftCoord(config);\n  if (disableSwapping || swappedLeft < vwMargin) {\n    left = screenRight - elWidth;\n  } else {\n    left = swappedLeft;\n    actualX = \"left\";\n  }\n  return {\n    actualX: actualX,\n    left: left\n  };\n}\n/**\n * @internal\n */\nexport function createEqualWidth(_a) {\n  var x = _a.x,\n    vw = _a.vw,\n    elWidth = _a.elWidth,\n    xMargin = _a.xMargin,\n    vwMargin = _a.vwMargin,\n    initialX = _a.initialX,\n    containerRect = _a.containerRect,\n    isMinWidth = _a.isMinWidth;\n  var left = initialX !== null && initialX !== void 0 ? initialX : containerRect.left + xMargin;\n  var width = containerRect.width - xMargin * 2;\n  var minWidth;\n  var right;\n  if (isMinWidth) {\n    minWidth = width;\n    width = undefined;\n    if (left + elWidth > vw - vwMargin) {\n      right = vwMargin;\n    }\n  }\n  // going to assume that the container element is visible in the DOM and just\n  // make the fixed element have the same left and right corners\n  return {\n    left: left,\n    right: right,\n    width: width,\n    minWidth: minWidth,\n    actualX: x\n  };\n}\n/**\n * Creates the horizontal position for a fixed element with the provided\n * options.\n * @internal\n */\nexport function createHorizontalPosition(_a) {\n  var x = _a.x,\n    vw = _a.vw,\n    vwMargin = _a.vwMargin,\n    xMargin = _a.xMargin,\n    width = _a.width,\n    elWidth = _a.elWidth,\n    initialX = _a.initialX,\n    containerRect = _a.containerRect,\n    disableSwapping = _a.disableSwapping;\n  if (width === \"min\" || width === \"equal\") {\n    return createEqualWidth({\n      x: x,\n      vw: vw,\n      vwMargin: vwMargin,\n      xMargin: xMargin,\n      elWidth: elWidth,\n      initialX: initialX,\n      containerRect: containerRect,\n      isMinWidth: width === \"min\"\n    });\n  }\n  if (elWidth > vw - vwMargin * 2) {\n    // if the element's width is greater than the viewport's width minus the\n    // margin on both sides, just make the element span the entire viewport with\n    // the margin\n    return {\n      left: vwMargin,\n      right: vwMargin,\n      actualX: x\n    };\n  }\n  var config = {\n    vwMargin: vwMargin,\n    xMargin: xMargin,\n    elWidth: elWidth,\n    initialX: initialX,\n    screenRight: vw - vwMargin,\n    containerRect: containerRect,\n    disableSwapping: disableSwapping\n  };\n  switch (x) {\n    case \"left\":\n      return createAnchoredLeft(config);\n    case \"inner-left\":\n      return createAnchoredInnerLeft(config);\n    case \"center\":\n      return createAnchoredCenter(config);\n    case \"inner-right\":\n      return createAnchoredInnerRight(config);\n    case \"right\":\n      return createAnchoredRight(config);\n  }\n}","map":{"version":3,"names":["getCenterXCoord","getInnerLeftCoord","getInnerRightCoord","getLeftCoord","getRightCoord","createAnchoredLeft","config","vwMargin","screenRight","elWidth","disableSwapping","left","actualX","swappedLeft","createAnchoredInnerLeft","createAnchoredCenter","createAnchoredInnerRight","Math","min","max","createAnchoredRight","createEqualWidth","_a","x","vw","xMargin","initialX","containerRect","isMinWidth","width","minWidth","right","undefined","createHorizontalPosition"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\utils\\src\\positioning\\createHorizontalPosition.ts"],"sourcesContent":["import type { XCoordConfig } from \"./getCoord\";\nimport {\n  getCenterXCoord,\n  getInnerLeftCoord,\n  getInnerRightCoord,\n  getLeftCoord,\n  getRightCoord,\n} from \"./getCoord\";\nimport type { FixedPositionOptions, HorizontalPosition } from \"./types\";\n\n/**\n * @internal\n */\ninterface XPosition {\n  left: number;\n  right?: number;\n  width?: number;\n  minWidth?: number;\n  actualX: HorizontalPosition;\n}\n\n/**\n * @internal\n */\nexport interface FixConfig extends XCoordConfig {\n  vwMargin: number;\n  screenRight: number;\n  disableSwapping: boolean;\n}\n\n/**\n * @internal\n */\ninterface Options\n  extends Required<\n    Pick<\n      FixedPositionOptions,\n      \"vwMargin\" | \"xMargin\" | \"width\" | \"disableSwapping\"\n    >\n  > {\n  x: HorizontalPosition;\n  vw: number;\n  elWidth: number;\n  initialX?: number;\n  containerRect: DOMRect;\n}\n\n/**\n * Attempts to position the fixed element so that it will appear to the left of\n * the container element but also within the viewport boundaries. When swapping\n * is enabled, it will attempt to swap to the right position if it can't fit\n * within the viewport to the left. If it can't fit in the viewport even after\n * being swapped to the right or swapping is disabled, it will be positioned to\n * the viewport left boundary.\n *\n * @internal\n */\nexport function createAnchoredLeft(config: FixConfig): XPosition {\n  const { vwMargin, screenRight, elWidth, disableSwapping } = config;\n\n  let left = getLeftCoord(config);\n  let actualX: HorizontalPosition = \"left\";\n  if (left >= vwMargin) {\n    return { actualX, left };\n  }\n\n  const swappedLeft = getRightCoord(config);\n  if (disableSwapping || swappedLeft + elWidth > screenRight) {\n    left = vwMargin;\n  } else {\n    left = swappedLeft;\n    actualX = \"right\";\n  }\n\n  return { actualX, left };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear to the\n * inner-left of the container element but also within the viewport boundaries.\n * When swapping is enabled, it will attempt to swap to the right position if it\n * can't fit within the viewport to the left. If it can't fit in the viewport\n * even after being swapped to the right or swapping is disabled, it will be\n * positioned to the viewport left boundary.\n *\n * @internal\n */\nexport function createAnchoredInnerLeft(config: FixConfig): XPosition {\n  const { vwMargin, screenRight, elWidth, disableSwapping } = config;\n\n  let left = getInnerLeftCoord(config);\n  let actualX: HorizontalPosition = \"inner-left\";\n  if (left + elWidth <= screenRight && left >= vwMargin) {\n    return { actualX, left };\n  }\n\n  if (disableSwapping) {\n    if (left + elWidth > screenRight) {\n      left = screenRight - elWidth;\n    } else {\n      left = vwMargin;\n    }\n\n    return { actualX, left };\n  }\n\n  const swappedLeft = getInnerRightCoord(config);\n  if (swappedLeft < vwMargin) {\n    left = vwMargin;\n  } else if (swappedLeft + elWidth > screenRight) {\n    left = screenRight - elWidth;\n    actualX = \"inner-right\";\n  } else {\n    left = swappedLeft;\n    actualX = \"inner-right\";\n  }\n\n  return { actualX, left };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear at the center\n * of the container element but also within the viewport boundaries. If the\n * centered element can't fit within the viewport, it will use the vwMargin\n * value if it overflowed to the left, it'll position to the screen right\n * boundary.\n *\n * @internal\n */\nexport function createAnchoredCenter(config: FixConfig): XPosition {\n  const { vwMargin, screenRight, elWidth } = config;\n  let left = getCenterXCoord(config);\n  if (left < vwMargin) {\n    left = vwMargin;\n  } else if (left + elWidth > screenRight || left < vwMargin) {\n    left = screenRight - elWidth;\n  }\n\n  return { actualX: \"center\", left };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear to the\n * inner-right of the container element but also within the viewport boundaries.\n * When swapping is enabled, it will attempt to swap to the inner-left position\n * if it can't fit within the viewport to the right. If it can't fit in the\n * viewport even after being swapped to the left or swapping is disabled, it\n * will be positioned to the viewport right boundary.\n *\n * @internal\n */\nexport function createAnchoredInnerRight(config: FixConfig): XPosition {\n  const { screenRight, vwMargin, elWidth, disableSwapping } = config;\n\n  let left = getInnerRightCoord(config);\n  let actualX: HorizontalPosition = \"inner-right\";\n  if (left >= vwMargin) {\n    return { actualX, left: Math.min(left, screenRight - elWidth) };\n  }\n\n  const swappedLeft = getInnerLeftCoord(config);\n  if (disableSwapping || swappedLeft + elWidth > screenRight) {\n    left = vwMargin;\n  } else {\n    left = Math.max(swappedLeft, vwMargin);\n    actualX = \"inner-left\";\n  }\n\n  return { actualX, left };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear to the right of\n * the container element but also within the viewport boundaries. When swapping\n * is enabled, it will attempt to swap to the left position if it can't fit\n * within the viewport to the right. If it can't fit in the viewport even after\n * being swapped to the left or swapping is disabled, it will be positioned to\n * the viewport right boundary.\n *\n * @internal\n */\nexport function createAnchoredRight(config: FixConfig): XPosition {\n  const { screenRight, vwMargin, elWidth, disableSwapping } = config;\n\n  let left = getRightCoord(config);\n  let actualX: HorizontalPosition = \"right\";\n  if (left + elWidth <= screenRight) {\n    return { actualX, left };\n  }\n\n  const swappedLeft = getLeftCoord(config);\n  if (disableSwapping || swappedLeft < vwMargin) {\n    left = screenRight - elWidth;\n  } else {\n    left = swappedLeft;\n    actualX = \"left\";\n  }\n\n  return { actualX, left };\n}\n\ninterface EqualWidthOptions\n  extends Pick<\n    Options,\n    | \"x\"\n    | \"vw\"\n    | \"elWidth\"\n    | \"xMargin\"\n    | \"vwMargin\"\n    | \"containerRect\"\n    | \"initialX\"\n  > {\n  isMinWidth: boolean;\n}\n\n/**\n * @internal\n */\nexport function createEqualWidth({\n  x,\n  vw,\n  elWidth,\n  xMargin,\n  vwMargin,\n  initialX,\n  containerRect,\n  isMinWidth,\n}: EqualWidthOptions): XPosition {\n  const left = initialX ?? containerRect.left + xMargin;\n\n  let width: number | undefined = containerRect.width - xMargin * 2;\n  let minWidth: number | undefined;\n  let right: number | undefined;\n  if (isMinWidth) {\n    minWidth = width;\n    width = undefined;\n    if (left + elWidth > vw - vwMargin) {\n      right = vwMargin;\n    }\n  }\n\n  // going to assume that the container element is visible in the DOM and just\n  // make the fixed element have the same left and right corners\n  return {\n    left,\n    right,\n    width,\n    minWidth,\n    actualX: x,\n  };\n}\n\n/**\n * Creates the horizontal position for a fixed element with the provided\n * options.\n * @internal\n */\nexport function createHorizontalPosition({\n  x,\n  vw,\n  vwMargin,\n  xMargin,\n  width,\n  elWidth,\n  initialX,\n  containerRect,\n  disableSwapping,\n}: Options): XPosition {\n  if (width === \"min\" || width === \"equal\") {\n    return createEqualWidth({\n      x,\n      vw,\n      vwMargin,\n      xMargin,\n      elWidth,\n      initialX,\n      containerRect,\n      isMinWidth: width === \"min\",\n    });\n  }\n\n  if (elWidth > vw - vwMargin * 2) {\n    // if the element's width is greater than the viewport's width minus the\n    // margin on both sides, just make the element span the entire viewport with\n    // the margin\n    return {\n      left: vwMargin,\n      right: vwMargin,\n      actualX: x,\n    };\n  }\n\n  const config: FixConfig = {\n    vwMargin,\n    xMargin,\n    elWidth,\n    initialX,\n    screenRight: vw - vwMargin,\n    containerRect,\n    disableSwapping,\n  };\n\n  switch (x) {\n    case \"left\":\n      return createAnchoredLeft(config);\n    case \"inner-left\":\n      return createAnchoredInnerLeft(config);\n    case \"center\":\n      return createAnchoredCenter(config);\n    case \"inner-right\":\n      return createAnchoredInnerRight(config);\n    case \"right\":\n      return createAnchoredRight(config);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}