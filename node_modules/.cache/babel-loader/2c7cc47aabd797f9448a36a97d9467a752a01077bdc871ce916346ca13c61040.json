{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { applyRef, useDir, useIsomorphicLayoutEffect } from \"@react-md/utils\";\nimport { DEFAULT_SLIDER_ANIMATION_TIME } from \"./constants\";\nimport { getDragPercentage, getDragValue, isMouseEvent, isRangeSlider, isTouchEvent } from \"./utils\";\nvar VALID_KEYS = [\"ArrowDown\", \"ArrowUp\", \"ArrowLeft\", \"ArrowRight\", \"Home\", \"End\", \"PageUp\", \"PageDown\"];\n/**\n * This hook provides all the logic for updating the slider's when the user\n * interacts with the slider.\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport function useSliderControls(_a) {\n  var _b, _c;\n  var ref = _a.ref,\n    propThumb1Ref = _a.thumb1Ref,\n    propThumb2Ref = _a.thumb2Ref,\n    min = _a.min,\n    max = _a.max,\n    step = _a.step,\n    _d = _a.disabled,\n    disabled = _d === void 0 ? false : _d,\n    _e = _a.vertical,\n    vertical = _e === void 0 ? false : _e,\n    onBlur = _a.onBlur,\n    onKeyDown = _a.onKeyDown,\n    onMouseDown = _a.onMouseDown,\n    onTouchStart = _a.onTouchStart,\n    _f = _a.animationDuration,\n    animationDuration = _f === void 0 ? DEFAULT_SLIDER_ANIMATION_TIME : _f,\n    controls = __rest(_a, [\"ref\", \"thumb1Ref\", \"thumb2Ref\", \"min\", \"max\", \"step\", \"disabled\", \"vertical\", \"onBlur\", \"onKeyDown\", \"onMouseDown\", \"onTouchStart\", \"animationDuration\"]);\n  var trackRef = useRef(null);\n  var thumb1Ref = useRef(null);\n  var thumb2Ref = useRef(null);\n  var _g = __read(useState(false), 2),\n    dragging = _g[0],\n    setDragging = _g[1];\n  var _h = __read(useState(min), 2),\n    dragValue = _h[0],\n    setDragValue = _h[1];\n  var _j = __read(useState(null), 2),\n    draggingBy = _j[0],\n    setDraggingBy = _j[1];\n  var _k = __read(useState(null), 2),\n    draggingIndex = _k[0],\n    setDraggingIndex = _k[1];\n  var controlsRef = useRef(controls);\n  useIsomorphicLayoutEffect(function () {\n    controlsRef.current = controls;\n  });\n  var dir = useDir().dir;\n  var isRtl = dir === \"rtl\";\n  var thumb1Value;\n  var thumb1Percentage;\n  var thumb2Value;\n  var thumb2Percentage;\n  if (isRangeSlider(controls)) {\n    _b = __read(controls.value, 2), thumb1Value = _b[0], thumb2Value = _b[1];\n    _c = getDragPercentage({\n      min: min,\n      max: max,\n      thumb1Value: thumb1Value,\n      thumb2Value: thumb2Value,\n      dragging: dragging,\n      dragValue: dragValue,\n      draggingIndex: draggingIndex\n    }), thumb1Percentage = _c.thumb1Percentage, thumb2Percentage = _c.thumb2Percentage;\n  } else {\n    thumb1Value = controls.value;\n    thumb1Percentage = getDragPercentage({\n      min: min,\n      max: max,\n      thumb1Value: thumb1Value,\n      dragging: dragging,\n      dragValue: dragValue,\n      draggingIndex: draggingIndex\n    }).thumb1Percentage;\n  }\n  /**\n   * The main handler for updating the value of the slider. To help keep the\n   * drag experience smooth, some values are stored in refs to prevent the\n   * `useEffect` from being run during renders which adds and removes the move\n   * event handlers\n   */\n  var drag = useCallback(function (event) {\n    var track = trackRef.current;\n    var slider1 = thumb1Ref.current;\n    var slider2 = thumb2Ref.current;\n    var altKey = event.altKey,\n      ctrlKey = event.ctrlKey,\n      metaKey = event.metaKey,\n      shiftKey = event.shiftKey;\n    if (altKey || ctrlKey || metaKey || shiftKey || disabled || !track || !slider1 || isMouseEvent(event) && event.button !== 0 || isTouchEvent(event) && event.changedTouches.length !== 1 || !isMouseEvent(event) && !isTouchEvent(event)) {\n      return;\n    }\n    // prevent text from being highlighted on desktop or the page from\n    // scrolling on mobile while dragging\n    if (!isTouchEvent(event) || event.type === \"touchmove\") {\n      event.preventDefault();\n    }\n    event.stopPropagation();\n    // get the current mouse/touch position to help determine hwo far the\n    // slider is being dragged\n    var clientX;\n    var clientY;\n    if (isMouseEvent(event)) {\n      clientX = event.clientX, clientY = event.clientY;\n    } else {\n      var touch = event.changedTouches[0];\n      clientX = touch.clientX, clientY = touch.clientY;\n    }\n    var index = 0;\n    var slider = slider1;\n    if (slider2) {\n      // if we aren't dragging yet, try to find the slider closest to the\n      // mouse/touch position and use that one\n      if (draggingIndex === null) {\n        var x1 = slider1.getBoundingClientRect().x;\n        var x2 = slider2.getBoundingClientRect().x;\n        var y1 = slider1.getBoundingClientRect().y;\n        var y2 = slider2.getBoundingClientRect().y;\n        if (vertical) {\n          index = Math.abs(clientY - y1) < Math.abs(clientY - y2) ? 0 : 1;\n        } else {\n          index = Math.abs(clientX - x1) < Math.abs(clientX - x2) ? 0 : 1;\n        }\n      } else {\n        index = draggingIndex;\n      }\n      slider = index === 0 ? slider1 : slider2;\n    }\n    // if we aren't dragging yet, want to focus the slider element to make it\n    // easier to switch between mouse dragging and keyboard \"dragging\"\n    if (draggingIndex !== index) {\n      slider.focus();\n      setDraggingIndex(index);\n    }\n    setDraggingBy(isMouseEvent(event) ? \"mouse\" : \"touch\");\n    var _a = track.getBoundingClientRect(),\n      left = _a.left,\n      top = _a.top,\n      height = _a.height,\n      width = _a.width;\n    var options = {\n      min: min,\n      max: max,\n      step: step,\n      vertical: vertical,\n      clientX: clientX,\n      clientY: clientY,\n      left: left,\n      top: top,\n      height: height,\n      width: width,\n      isRtl: isRtl,\n      minValue: min,\n      maxValue: max\n    };\n    var controls = controlsRef.current;\n    if (isRangeSlider(controls)) {\n      var _b = __read(controls.value, 2),\n        thumb1Value_1 = _b[0],\n        thumb2Value_1 = _b[1];\n      var _c = getDragValue(__assign(__assign({}, options), {\n          minValue: index === 0 ? min : thumb1Value_1 + step,\n          maxValue: index === 1 ? max : thumb2Value_1 - step\n        })),\n        value = _c.value,\n        current = _c.current;\n      setDragValue(current);\n      controls.setValue(index === 0 ? [value, thumb2Value_1] : [thumb1Value_1, value]);\n    } else {\n      var _d = getDragValue(options),\n        value = _d.value,\n        current = _d.current;\n      setDragValue(current);\n      controls.setValue(value);\n    }\n  }, [disabled, isRtl, draggingIndex, max, min, step, vertical]);\n  var stop = useCallback(function () {\n    controlsRef.current.persist();\n    setDragging(false);\n    setDraggingIndex(null);\n    setDraggingBy(null);\n  }, []);\n  useEffect(function () {\n    if (draggingBy === null) {\n      return;\n    }\n    if (draggingBy === \"mouse\") {\n      window.addEventListener(\"mousemove\", drag);\n      window.addEventListener(\"mouseup\", stop);\n    } else {\n      window.addEventListener(\"touchmove\", drag, {\n        passive: false\n      });\n      window.addEventListener(\"touchend\", stop);\n    }\n    return function () {\n      if (draggingBy === \"mouse\") {\n        window.removeEventListener(\"mousemove\", drag);\n        window.removeEventListener(\"mouseup\", stop);\n      } else {\n        window.removeEventListener(\"touchmove\", drag);\n        window.removeEventListener(\"touchend\", stop);\n      }\n    };\n  }, [draggingBy, drag, stop]);\n  useEffect(function () {\n    if (draggingIndex === null && draggingBy === null) {\n      return;\n    }\n    // I don't know how to reach this flow.. so maybe can be removed?\n    /* istanbul ignore if */\n    if (draggingIndex === null) {\n      setDragging(false);\n      return;\n    }\n    var timeout = window.setTimeout(function () {\n      setDragging(true);\n    }, animationDuration);\n    return function () {\n      window.clearTimeout(timeout);\n    };\n  }, [draggingIndex, draggingBy, animationDuration]);\n  var handleBlur = useCallback(function (event) {\n    if (onBlur) {\n      onBlur(event);\n    }\n    controlsRef.current.persist();\n  }, [onBlur]);\n  /**\n   * Note: this should be attached to the `SliderTrack` component.\n   */\n  var handleMouseDown = useCallback(function (event) {\n    if (onMouseDown) {\n      onMouseDown(event);\n    }\n    // only call drag again when the dragging by isn't null since it can cause\n    // the \"drag\" events to be re-started if the mouse appears over the slider\n    // thumb again\n    if (draggingBy === null) {\n      drag(event);\n    }\n  }, [drag, draggingBy, onMouseDown]);\n  /**\n   * Note: this should be attached to the `SliderTrack` component.\n   */\n  var handleTouchStart = useCallback(function (event) {\n    if (onTouchStart) {\n      onTouchStart(event);\n    }\n    // only call drag again when the dragging by isn't null since it can cause\n    // the \"drag\" events to be re-started if the user's finger appears over\n    // the slider thumb again\n    if (draggingBy === null) {\n      drag(event);\n    }\n  }, [drag, draggingBy, onTouchStart]);\n  /**\n   * Note: this should be attached to each `SliderThumb` component.\n   */\n  var handleKeyDown = useCallback(function (event) {\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n    var key = event.key,\n      altKey = event.altKey,\n      ctrlKey = event.ctrlKey,\n      metaKey = event.metaKey,\n      shiftKey = event.shiftKey;\n    if (altKey || ctrlKey || metaKey || shiftKey || disabled || !VALID_KEYS.includes(key)) {\n      return;\n    }\n    var controls;\n    if (isRangeSlider(controlsRef.current)) {\n      var _a = controlsRef.current,\n        increment_1 = _a.increment,\n        incrementJump_1 = _a.incrementJump,\n        decrement_1 = _a.decrement,\n        decrementJump_1 = _a.decrementJump,\n        minimum_1 = _a.minimum,\n        maximum_1 = _a.maximum;\n      var index = event.currentTarget === thumb2Ref.current ? 1 : 0;\n      controls = {\n        increment: increment_1.bind(null, index),\n        incrementJump: incrementJump_1.bind(null, index),\n        decrement: decrement_1.bind(null, index),\n        decrementJump: decrementJump_1.bind(null, index),\n        minimum: minimum_1.bind(null, index),\n        maximum: maximum_1.bind(null, index)\n      };\n    } else {\n      controls = controlsRef.current;\n    }\n    var increment = controls.increment,\n      incrementJump = controls.incrementJump,\n      decrement = controls.decrement,\n      decrementJump = controls.decrementJump,\n      minimum = controls.minimum,\n      maximum = controls.maximum;\n    event.preventDefault();\n    event.stopPropagation();\n    switch (key) {\n      case \"ArrowUp\":\n      case \"ArrowRight\":\n        increment();\n        break;\n      case \"ArrowDown\":\n      case \"ArrowLeft\":\n        decrement();\n        break;\n      case \"Home\":\n        minimum();\n        break;\n      case \"End\":\n        maximum();\n        break;\n      case \"PageUp\":\n        incrementJump();\n        break;\n      case \"PageDown\":\n        decrementJump();\n        break;\n    }\n  }, [onKeyDown, disabled]);\n  var trackRefHandler = useCallback(function (instance) {\n    applyRef(instance, ref);\n    trackRef.current = instance;\n  }, [ref]);\n  var thumb1RefHandler = useCallback(function (instance) {\n    applyRef(instance, propThumb1Ref);\n    thumb1Ref.current = instance;\n  }, [propThumb1Ref]);\n  var thumb2RefHandler = useCallback(function (instance) {\n    applyRef(instance, propThumb2Ref);\n    thumb2Ref.current = instance;\n  }, [propThumb2Ref]);\n  return {\n    thumb1Ref: thumb1RefHandler,\n    thumb1Value: thumb1Value,\n    thumb1Percentage: thumb1Percentage,\n    thumb2Ref: thumb2RefHandler,\n    thumb2Value: thumb2Value,\n    thumb2Percentage: thumb2Percentage,\n    dragging: dragging,\n    draggingIndex: draggingIndex,\n    ref: trackRefHandler,\n    onBlur: handleBlur,\n    onKeyDown: handleKeyDown,\n    onMouseDown: handleMouseDown,\n    onTouchStart: handleTouchStart\n  };\n}","map":{"version":3,"names":["useCallback","useEffect","useRef","useState","applyRef","useDir","useIsomorphicLayoutEffect","DEFAULT_SLIDER_ANIMATION_TIME","getDragPercentage","getDragValue","isMouseEvent","isRangeSlider","isTouchEvent","VALID_KEYS","useSliderControls","_a","ref","propThumb1Ref","thumb1Ref","propThumb2Ref","thumb2Ref","min","max","step","_d","disabled","_e","vertical","onBlur","onKeyDown","onMouseDown","onTouchStart","_f","animationDuration","controls","__rest","trackRef","_g","__read","dragging","setDragging","_h","dragValue","setDragValue","_j","draggingBy","setDraggingBy","_k","draggingIndex","setDraggingIndex","controlsRef","current","dir","isRtl","thumb1Value","thumb1Percentage","thumb2Value","thumb2Percentage","_b","value","_c","drag","event","track","slider1","slider2","altKey","ctrlKey","metaKey","shiftKey","button","changedTouches","length","type","preventDefault","stopPropagation","clientX","clientY","touch","index","slider","x1","getBoundingClientRect","x","x2","y1","y","y2","Math","abs","focus","left","top","height","width","options","minValue","maxValue","thumb1Value_1","thumb2Value_1","__assign","setValue","stop","persist","window","addEventListener","passive","removeEventListener","timeout","setTimeout","clearTimeout","handleBlur","handleMouseDown","handleTouchStart","handleKeyDown","key","includes","increment_1","increment","incrementJump_1","incrementJump","decrement_1","decrement","decrementJump_1","decrementJump","minimum_1","minimum","maximum_1","maximum","currentTarget","bind","trackRefHandler","instance","thumb1RefHandler","thumb2RefHandler"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\form\\src\\slider\\useSliderControls.ts"],"sourcesContent":["import type {\n  KeyboardEventHandler,\n  MouseEventHandler,\n  FocusEventHandler,\n  Ref,\n  RefCallback,\n  TouchEventHandler,\n} from \"react\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { applyRef, useDir, useIsomorphicLayoutEffect } from \"@react-md/utils\";\n\nimport { DEFAULT_SLIDER_ANIMATION_TIME } from \"./constants\";\nimport type {\n  DefinedSliderValueOptions,\n  SliderControls,\n  SliderDragEvent,\n  SliderDraggingBy,\n  SliderEventHandlers,\n  SliderPresentation,\n  SliderThumbIndex,\n  ThumbIndex,\n} from \"./types\";\nimport type { CombinedSliderControls, SliderDragValues } from \"./utils\";\nimport {\n  getDragPercentage,\n  getDragValue,\n  isMouseEvent,\n  isRangeSlider,\n  isTouchEvent,\n} from \"./utils\";\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport type SliderControlsOptions = CombinedSliderControls &\n  SliderPresentation &\n  SliderEventHandlers &\n  DefinedSliderValueOptions & {\n    ref?: Ref<HTMLSpanElement | null>;\n    thumb1Ref?: Ref<HTMLSpanElement | null>;\n    thumb2Ref?: Ref<HTMLSpanElement | null>;\n    animationDuration?: number;\n  };\n\nconst VALID_KEYS = [\n  \"ArrowDown\",\n  \"ArrowUp\",\n  \"ArrowLeft\",\n  \"ArrowRight\",\n  \"Home\",\n  \"End\",\n  \"PageUp\",\n  \"PageDown\",\n];\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport interface SliderAndRangeSliderControls {\n  thumb1Ref: RefCallback<HTMLSpanElement | null>;\n  thumb1Value: number;\n  thumb1Percentage: string;\n  thumb2Ref: RefCallback<HTMLSpanElement | null>;\n  thumb2Value?: number;\n  thumb2Percentage?: string;\n  dragging: boolean;\n  draggingIndex: SliderThumbIndex;\n  ref: RefCallback<HTMLSpanElement | null>;\n  onBlur: FocusEventHandler<HTMLSpanElement>;\n  onKeyDown: KeyboardEventHandler<HTMLSpanElement>;\n  onMouseDown: MouseEventHandler<HTMLSpanElement>;\n  onTouchStart: TouchEventHandler<HTMLSpanElement>;\n}\n\n/**\n * This hook provides all the logic for updating the slider's when the user\n * interacts with the slider.\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport function useSliderControls({\n  ref,\n  thumb1Ref: propThumb1Ref,\n  thumb2Ref: propThumb2Ref,\n  min,\n  max,\n  step,\n  disabled = false,\n  vertical = false,\n  onBlur,\n  onKeyDown,\n  onMouseDown,\n  onTouchStart,\n  animationDuration = DEFAULT_SLIDER_ANIMATION_TIME,\n  ...controls\n}: SliderControlsOptions): SliderAndRangeSliderControls {\n  const trackRef = useRef<HTMLSpanElement | null>(null);\n  const thumb1Ref = useRef<HTMLSpanElement | null>(null);\n  const thumb2Ref = useRef<HTMLSpanElement | null>(null);\n  const [dragging, setDragging] = useState(false);\n  const [dragValue, setDragValue] = useState<number>(min);\n  const [draggingBy, setDraggingBy] = useState<SliderDraggingBy>(null);\n  const [draggingIndex, setDraggingIndex] = useState<SliderThumbIndex>(null);\n  const controlsRef = useRef(controls);\n  useIsomorphicLayoutEffect(() => {\n    controlsRef.current = controls;\n  });\n\n  const { dir } = useDir();\n  const isRtl = dir === \"rtl\";\n\n  let thumb1Value: number;\n  let thumb1Percentage: string;\n  let thumb2Value: number | undefined;\n  let thumb2Percentage: string | undefined;\n  if (isRangeSlider(controls)) {\n    [thumb1Value, thumb2Value] = controls.value;\n    ({ thumb1Percentage, thumb2Percentage } = getDragPercentage({\n      min,\n      max,\n      thumb1Value,\n      thumb2Value,\n      dragging,\n      dragValue,\n      draggingIndex,\n    }));\n  } else {\n    thumb1Value = controls.value;\n    ({ thumb1Percentage } = getDragPercentage({\n      min,\n      max,\n      thumb1Value,\n      dragging,\n      dragValue,\n      draggingIndex,\n    }));\n  }\n\n  /**\n   * The main handler for updating the value of the slider. To help keep the\n   * drag experience smooth, some values are stored in refs to prevent the\n   * `useEffect` from being run during renders which adds and removes the move\n   * event handlers\n   */\n  const drag = useCallback(\n    (event: SliderDragEvent) => {\n      const track = trackRef.current;\n      const slider1 = thumb1Ref.current;\n      const slider2 = thumb2Ref.current;\n      const { altKey, ctrlKey, metaKey, shiftKey } = event;\n      if (\n        altKey ||\n        ctrlKey ||\n        metaKey ||\n        shiftKey ||\n        disabled ||\n        !track ||\n        !slider1 ||\n        (isMouseEvent(event) && event.button !== 0) ||\n        (isTouchEvent(event) && event.changedTouches.length !== 1) ||\n        (!isMouseEvent(event) && !isTouchEvent(event))\n      ) {\n        return;\n      }\n\n      // prevent text from being highlighted on desktop or the page from\n      // scrolling on mobile while dragging\n      if (!isTouchEvent(event) || event.type === \"touchmove\") {\n        event.preventDefault();\n      }\n      event.stopPropagation();\n\n      // get the current mouse/touch position to help determine hwo far the\n      // slider is being dragged\n      let clientX: number;\n      let clientY: number;\n      if (isMouseEvent(event)) {\n        ({ clientX, clientY } = event);\n      } else {\n        const touch = event.changedTouches[0];\n        ({ clientX, clientY } = touch);\n      }\n\n      let index: ThumbIndex = 0;\n      let slider: HTMLSpanElement = slider1;\n      if (slider2) {\n        // if we aren't dragging yet, try to find the slider closest to the\n        // mouse/touch position and use that one\n        if (draggingIndex === null) {\n          const x1 = slider1.getBoundingClientRect().x;\n          const x2 = slider2.getBoundingClientRect().x;\n          const y1 = slider1.getBoundingClientRect().y;\n          const y2 = slider2.getBoundingClientRect().y;\n          if (vertical) {\n            index = Math.abs(clientY - y1) < Math.abs(clientY - y2) ? 0 : 1;\n          } else {\n            index = Math.abs(clientX - x1) < Math.abs(clientX - x2) ? 0 : 1;\n          }\n        } else {\n          index = draggingIndex;\n        }\n\n        slider = index === 0 ? slider1 : slider2;\n      }\n\n      // if we aren't dragging yet, want to focus the slider element to make it\n      // easier to switch between mouse dragging and keyboard \"dragging\"\n      if (draggingIndex !== index) {\n        slider.focus();\n        setDraggingIndex(index);\n      }\n\n      setDraggingBy(isMouseEvent(event) ? \"mouse\" : \"touch\");\n\n      const { left, top, height, width } = track.getBoundingClientRect();\n      const options: SliderDragValues = {\n        min,\n        max,\n        step,\n        vertical,\n        clientX,\n        clientY,\n        left,\n        top,\n        height,\n        width,\n        isRtl,\n        minValue: min,\n        maxValue: max,\n      };\n\n      const controls = controlsRef.current;\n      if (isRangeSlider(controls)) {\n        const [thumb1Value, thumb2Value] = controls.value;\n        const { value, current } = getDragValue({\n          ...options,\n          minValue: index === 0 ? min : thumb1Value + step,\n          maxValue: index === 1 ? max : thumb2Value - step,\n        });\n        setDragValue(current);\n        controls.setValue(\n          index === 0 ? [value, thumb2Value] : [thumb1Value, value]\n        );\n      } else {\n        const { value, current } = getDragValue(options);\n        setDragValue(current);\n        controls.setValue(value);\n      }\n    },\n    [disabled, isRtl, draggingIndex, max, min, step, vertical]\n  );\n  const stop = useCallback(() => {\n    controlsRef.current.persist();\n    setDragging(false);\n    setDraggingIndex(null);\n    setDraggingBy(null);\n  }, []);\n\n  useEffect(() => {\n    if (draggingBy === null) {\n      return;\n    }\n\n    if (draggingBy === \"mouse\") {\n      window.addEventListener(\"mousemove\", drag);\n      window.addEventListener(\"mouseup\", stop);\n    } else {\n      window.addEventListener(\"touchmove\", drag, { passive: false });\n      window.addEventListener(\"touchend\", stop);\n    }\n\n    return () => {\n      if (draggingBy === \"mouse\") {\n        window.removeEventListener(\"mousemove\", drag);\n        window.removeEventListener(\"mouseup\", stop);\n      } else {\n        window.removeEventListener(\"touchmove\", drag);\n        window.removeEventListener(\"touchend\", stop);\n      }\n    };\n  }, [draggingBy, drag, stop]);\n\n  useEffect(() => {\n    if (draggingIndex === null && draggingBy === null) {\n      return;\n    }\n\n    // I don't know how to reach this flow.. so maybe can be removed?\n    /* istanbul ignore if */\n    if (draggingIndex === null) {\n      setDragging(false);\n      return;\n    }\n\n    const timeout = window.setTimeout(() => {\n      setDragging(true);\n    }, animationDuration);\n\n    return () => {\n      window.clearTimeout(timeout);\n    };\n  }, [draggingIndex, draggingBy, animationDuration]);\n\n  const handleBlur = useCallback<FocusEventHandler<HTMLSpanElement>>(\n    (event) => {\n      if (onBlur) {\n        onBlur(event);\n      }\n\n      controlsRef.current.persist();\n    },\n    [onBlur]\n  );\n\n  /**\n   * Note: this should be attached to the `SliderTrack` component.\n   */\n  const handleMouseDown = useCallback<MouseEventHandler<HTMLSpanElement>>(\n    (event) => {\n      if (onMouseDown) {\n        onMouseDown(event);\n      }\n\n      // only call drag again when the dragging by isn't null since it can cause\n      // the \"drag\" events to be re-started if the mouse appears over the slider\n      // thumb again\n      if (draggingBy === null) {\n        drag(event);\n      }\n    },\n    [drag, draggingBy, onMouseDown]\n  );\n\n  /**\n   * Note: this should be attached to the `SliderTrack` component.\n   */\n  const handleTouchStart = useCallback<TouchEventHandler<HTMLSpanElement>>(\n    (event) => {\n      if (onTouchStart) {\n        onTouchStart(event);\n      }\n\n      // only call drag again when the dragging by isn't null since it can cause\n      // the \"drag\" events to be re-started if the user's finger appears over\n      // the slider thumb again\n      if (draggingBy === null) {\n        drag(event);\n      }\n    },\n    [drag, draggingBy, onTouchStart]\n  );\n\n  /**\n   * Note: this should be attached to each `SliderThumb` component.\n   */\n  const handleKeyDown = useCallback<KeyboardEventHandler<HTMLSpanElement>>(\n    (event) => {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      const { key, altKey, ctrlKey, metaKey, shiftKey } = event;\n      if (\n        altKey ||\n        ctrlKey ||\n        metaKey ||\n        shiftKey ||\n        disabled ||\n        !VALID_KEYS.includes(key)\n      ) {\n        return;\n      }\n\n      let controls: Omit<SliderControls, \"setValue\" | \"value\" | \"persist\">;\n      if (isRangeSlider(controlsRef.current)) {\n        const {\n          increment,\n          incrementJump,\n          decrement,\n          decrementJump,\n          minimum,\n          maximum,\n        } = controlsRef.current;\n        const index = event.currentTarget === thumb2Ref.current ? 1 : 0;\n        controls = {\n          increment: increment.bind(null, index),\n          incrementJump: incrementJump.bind(null, index),\n          decrement: decrement.bind(null, index),\n          decrementJump: decrementJump.bind(null, index),\n          minimum: minimum.bind(null, index),\n          maximum: maximum.bind(null, index),\n        };\n      } else {\n        controls = controlsRef.current;\n      }\n\n      const {\n        increment,\n        incrementJump,\n        decrement,\n        decrementJump,\n        minimum,\n        maximum,\n      } = controls;\n      event.preventDefault();\n      event.stopPropagation();\n      switch (key) {\n        case \"ArrowUp\":\n        case \"ArrowRight\":\n          increment();\n          break;\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n          decrement();\n          break;\n        case \"Home\":\n          minimum();\n          break;\n        case \"End\":\n          maximum();\n          break;\n        case \"PageUp\":\n          incrementJump();\n          break;\n        case \"PageDown\":\n          decrementJump();\n          break;\n      }\n    },\n    [onKeyDown, disabled]\n  );\n\n  const trackRefHandler = useCallback(\n    (instance: HTMLSpanElement | null) => {\n      applyRef(instance, ref);\n      trackRef.current = instance;\n    },\n    [ref]\n  );\n\n  const thumb1RefHandler = useCallback(\n    (instance: HTMLSpanElement | null) => {\n      applyRef(instance, propThumb1Ref);\n      thumb1Ref.current = instance;\n    },\n    [propThumb1Ref]\n  );\n\n  const thumb2RefHandler = useCallback(\n    (instance: HTMLSpanElement | null) => {\n      applyRef(instance, propThumb2Ref);\n      thumb2Ref.current = instance;\n    },\n    [propThumb2Ref]\n  );\n\n  return {\n    thumb1Ref: thumb1RefHandler,\n    thumb1Value,\n    thumb1Percentage,\n    thumb2Ref: thumb2RefHandler,\n    thumb2Value,\n    thumb2Percentage,\n    dragging,\n    draggingIndex,\n    ref: trackRefHandler,\n    onBlur: handleBlur,\n    onKeyDown: handleKeyDown,\n    onMouseDown: handleMouseDown,\n    onTouchStart: handleTouchStart,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}