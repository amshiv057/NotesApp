{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { Children, cloneElement, forwardRef, isValidElement } from \"react\";\nimport cn from \"classnames\";\nimport { bem } from \"../bem\";\nimport { useAppSize } from \"../sizing/useAppSize\";\nimport { GridCell } from \"./GridCell\";\n/**\n * This CSS Variable allows you to override the number of columns that should be\n * displayed in the grid. This is automatically updated with media queries with\n * the default grid implementation, but is used here to add additional\n * inline-style overrides.\n *\n * @internal\n */\nexport var GRID_COLUMNS_VAR = \"--rmd-grid-cols\";\n/**\n * This CSS Variable allows you to override the gutter (grid-gap) between each\n * cell in the grid.\n *\n * @internal\n */\nexport var GRID_GUTTER_VAR = \"--rmd-grid-gutter\";\nvar block = bem(\"rmd-grid\");\n/**\n * The grid component is generally used for a base layout in your app to provide\n * nice padding and spacing between each item.\n *\n * Note: This component relies on the `AppSizeListener` as a parent component to\n * work and will throw an error if it does not exist as a parent.\n */\nexport var Grid = forwardRef(function Grid(_a, ref) {\n  var _b;\n  var style = _a.style,\n    className = _a.className,\n    children = _a.children,\n    _c = _a.clone,\n    clone = _c === void 0 ? false : _c,\n    _d = _a.cloneStyles,\n    cloneStyles = _d === void 0 ? false : _d,\n    _e = _a.wrapOnly,\n    wrapOnly = _e === void 0 ? false : _e,\n    columns = _a.columns,\n    phoneColumns = _a.phoneColumns,\n    tabletColumns = _a.tabletColumns,\n    desktopColumns = _a.desktopColumns,\n    largeDesktopColumns = _a.largeDesktopColumns,\n    padding = _a.padding,\n    gutter = _a.gutter,\n    minCellWidth = _a.minCellWidth,\n    props = __rest(_a, [\"style\", \"className\", \"children\", \"clone\", \"cloneStyles\", \"wrapOnly\", \"columns\", \"phoneColumns\", \"tabletColumns\", \"desktopColumns\", \"largeDesktopColumns\", \"padding\", \"gutter\", \"minCellWidth\"]);\n  var _f = useAppSize(),\n    isPhone = _f.isPhone,\n    isTablet = _f.isTablet,\n    isDesktop = _f.isDesktop,\n    isLargeDesktop = _f.isLargeDesktop;\n  var mergedStyle = __assign(__assign({\n    padding: padding !== 0 && padding || undefined,\n    gridTemplateColumns: minCellWidth ? \"repeat(auto-fill, minmax(\".concat(minCellWidth, \", 1fr))\") : undefined\n  }, style), (_b = {}, _b[GRID_COLUMNS_VAR] = isPhone && phoneColumns || isTablet && tabletColumns || isLargeDesktop && largeDesktopColumns || isDesktop && desktopColumns || columns, _b[GRID_GUTTER_VAR] = gutter, _b));\n  var mergedClassName = cn(block({\n    \"no-padding\": padding === 0\n  }), className);\n  if (cloneStyles && isValidElement(children)) {\n    var child = Children.only(children);\n    return cloneElement(child, {\n      style: __assign(__assign({}, mergedStyle), child.props.style),\n      className: cn(mergedClassName, child.props.className)\n    });\n  }\n  var content = children;\n  if (clone || wrapOnly) {\n    content = Children.map(children, function (child) {\n      return child && _jsx(GridCell, __assign({\n        clone: clone\n      }, {\n        children: child\n      }));\n    });\n  }\n  return _jsx(\"div\", __assign({}, props, {\n    ref: ref,\n    style: mergedStyle,\n    className: mergedClassName\n  }, {\n    children: content\n  }));\n});","map":{"version":3,"names":["Children","cloneElement","forwardRef","isValidElement","cn","bem","useAppSize","GridCell","GRID_COLUMNS_VAR","GRID_GUTTER_VAR","block","Grid","_a","ref","style","className","children","_c","clone","_d","cloneStyles","_e","wrapOnly","columns","phoneColumns","tabletColumns","desktopColumns","largeDesktopColumns","padding","gutter","minCellWidth","props","__rest","_f","isPhone","isTablet","isDesktop","isLargeDesktop","mergedStyle","__assign","undefined","gridTemplateColumns","concat","_b","mergedClassName","child","only","content","map","_jsx"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\utils\\src\\layout\\Grid.tsx"],"sourcesContent":["import type { HTMLAttributes } from \"react\";\nimport { Children, cloneElement, forwardRef, isValidElement } from \"react\";\nimport cn from \"classnames\";\n\nimport { bem } from \"../bem\";\nimport { useAppSize } from \"../sizing/useAppSize\";\nimport { GridCell } from \"./GridCell\";\n\n/**\n * This CSS Variable allows you to override the number of columns that should be\n * displayed in the grid. This is automatically updated with media queries with\n * the default grid implementation, but is used here to add additional\n * inline-style overrides.\n *\n * @internal\n */\nexport const GRID_COLUMNS_VAR = \"--rmd-grid-cols\";\n\n/**\n * This CSS Variable allows you to override the gutter (grid-gap) between each\n * cell in the grid.\n *\n * @internal\n */\nexport const GRID_GUTTER_VAR = \"--rmd-grid-gutter\";\n\nexport interface GridProps extends HTMLAttributes<HTMLDivElement> {\n  /**\n   * Boolean if the `children` should have the grid `style` and `className`\n   * props cloned using `React.cloneElement`. This is useful if you just want to\n   * use the grid styles without the additional wrapper `<div>`.\n   *\n   * Note: if this prop is provided, all of the `HTMLAttributes` props will be\n   * ignored as well as the `clone` and `wrapOnly` props.\n   *\n   * @remarks \\@since 2.3.0\n   */\n  cloneStyles?: boolean;\n\n  /**\n   * Boolean if the `children` should be updated to be wrapped in the `GridCell`\n   * component and clone the `className` into each child automatically. This is\n   * really just a convenience prop so you don't always need to import both the\n   * `Grid` and `GridCell` components to create a grid.\n   */\n  clone?: boolean;\n\n  /**\n   * Boolean if the `children` should be updated to be wrapped in the `GridCell`\n   * component.  This is really just a convenience prop so you don't always need\n   * to import both the `Grid` and `GridCell` components to create a grid/\n   */\n  wrapOnly?: boolean;\n\n  /**\n   * This prop allows you to generate your grid with a dynamic amount of columns\n   * instead of a static size. This will update the grid to ignore all the\n   * `columns` props and update the grid to show as many columns as possible by\n   * updating the `grid-template-columns` style to be:\n   *\n   * ```scss\n   * grid-template-columns: repeat(auto-fill, minmax($min-cell-width, 1fr));\n   * ```\n   *\n   * This **needs to be a number with a unit**. Check out the documentation on\n   * the `minmax` css function for some more info.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/minmax\n   */\n  minCellWidth?: \"min-content\" | \"max-content\" | \"auto\" | string;\n\n  /**\n   * An optional number of columns to apply for all media types. Providing one\n   * of the media-specific column props will override this value for those\n   * breakpoints still.\n   */\n  columns?: number;\n\n  /**\n   * An optional number of columns to display for phones.\n   */\n  phoneColumns?: number;\n\n  /**\n   * An optional number of columns to display for tablets.\n   */\n  tabletColumns?: number;\n\n  /**\n   * An optional number of columns to display for desktop screens.\n   */\n  desktopColumns?: number;\n\n  /**\n   * An optional number of columns to display for large desktop screens.\n   */\n  largeDesktopColumns?: number;\n\n  /**\n   * This is really just a pass-through of the `style` prop that allows you to\n   * quickly update the base padding for the grid.\n   */\n  padding?: number | string;\n\n  /**\n   * This will override the default grid cell's gutter value (the space between\n   * each cell). This **needs to be a number with a unit** since it is set to a\n   * css variable. Examples:\n   *\n   * - `1rem`\n   * - `16px`\n   * - `1em`\n   * - `5%`\n   */\n  gutter?: string;\n}\n\ntype CSSProperties = React.CSSProperties & {\n  [GRID_GUTTER_VAR]?: string;\n  [GRID_COLUMNS_VAR]?: number;\n};\n\nconst block = bem(\"rmd-grid\");\n\n/**\n * The grid component is generally used for a base layout in your app to provide\n * nice padding and spacing between each item.\n *\n * Note: This component relies on the `AppSizeListener` as a parent component to\n * work and will throw an error if it does not exist as a parent.\n */\nexport const Grid = forwardRef<HTMLDivElement, GridProps>(function Grid(\n  {\n    style,\n    className,\n    children,\n    clone = false,\n    cloneStyles = false,\n    wrapOnly = false,\n    columns,\n    phoneColumns,\n    tabletColumns,\n    desktopColumns,\n    largeDesktopColumns,\n    padding,\n    gutter,\n    minCellWidth,\n    ...props\n  },\n  ref\n) {\n  const { isPhone, isTablet, isDesktop, isLargeDesktop } = useAppSize();\n\n  const mergedStyle: CSSProperties = {\n    padding: (padding !== 0 && padding) || undefined,\n    gridTemplateColumns: minCellWidth\n      ? `repeat(auto-fill, minmax(${minCellWidth}, 1fr))`\n      : undefined,\n    ...style,\n    [GRID_COLUMNS_VAR]:\n      (isPhone && phoneColumns) ||\n      (isTablet && tabletColumns) ||\n      (isLargeDesktop && largeDesktopColumns) ||\n      (isDesktop && desktopColumns) ||\n      columns,\n    [GRID_GUTTER_VAR]: gutter,\n  };\n  const mergedClassName = cn(block({ \"no-padding\": padding === 0 }), className);\n\n  if (cloneStyles && isValidElement(children)) {\n    const child = Children.only(children);\n\n    return cloneElement(child, {\n      style: { ...mergedStyle, ...child.props.style },\n      className: cn(mergedClassName, child.props.className),\n    });\n  }\n\n  let content = children;\n  if (clone || wrapOnly) {\n    content = Children.map(\n      children,\n      (child) => child && <GridCell clone={clone}>{child}</GridCell>\n    );\n  }\n\n  return (\n    <div {...props} ref={ref} style={mergedStyle} className={mergedClassName}>\n      {content}\n    </div>\n  );\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}