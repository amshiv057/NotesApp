{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { useMemo } from \"react\";\nimport { getTreeItemId } from \"./getTreeItemId\";\nfunction flatten(_a) {\n  var list = _a.list,\n    item = _a.item,\n    index = _a.index,\n    baseId = _a.baseId,\n    parentIndexes = _a.parentIndexes,\n    valueKey = _a.valueKey,\n    getItemValue = _a.getItemValue;\n  if (item.isCustom) {\n    return list;\n  }\n  var id = getTreeItemId(baseId, index, parentIndexes);\n  var value = getItemValue(item, valueKey);\n  var itemId = item.itemId,\n    parentId = item.parentId,\n    childItems = item.childItems;\n  list.push({\n    id: id,\n    itemId: itemId,\n    parentId: parentId,\n    isParent: !!childItems,\n    value: value\n  });\n  if (!childItems) {\n    return list;\n  }\n  var nextIndexes = __spreadArray(__spreadArray([], __read(parentIndexes), false), [index + 1], false);\n  childItems.forEach(function (child, childIndex) {\n    flatten({\n      list: list,\n      item: child,\n      index: childIndex,\n      valueKey: valueKey,\n      getItemValue: getItemValue,\n      baseId: baseId,\n      parentIndexes: nextIndexes\n    });\n  });\n  return list;\n}\n/**\n * Creates a flattened and ordered list of all the tree items that are current visible\n * in the DOM based on the expanded ids. This is only required for handling keyboard\n * navigation with `aria-activedescendant` movement so the items can be \"focused\" with\n * typeahead and keyboard movement since the keyboard movement API requires DOM refs\n * to be passed to each element.\n *\n * This flattened list will remove the `childItems` (if it existed) on each item for\n * simplicity and the child items aren't needed for this flattened list.\n *\n * @internal\n */\nexport function useFlattenedTreeList(_a) {\n  var id = _a.id,\n    items = _a.items,\n    rootId = _a.rootId,\n    expandedIds = _a.expandedIds,\n    valueKey = _a.valueKey,\n    getItemValue = _a.getItemValue;\n  var flattenedItems = useMemo(function () {\n    return items.reduce(function (list, item, index) {\n      return flatten({\n        list: list,\n        item: item,\n        index: index,\n        valueKey: valueKey,\n        getItemValue: getItemValue,\n        baseId: id,\n        parentIndexes: []\n      });\n    }, []);\n  }, [getItemValue, id, items, valueKey]);\n  var _b = useMemo(function () {\n      var index = 0;\n      return flattenedItems.reduce(function (collection, item) {\n        var _a, _b;\n        var parentId = item.parentId,\n          itemId = item.itemId;\n        var isVisible = parentId === rootId;\n        if (parentId !== null && expandedIds.includes(parentId)) {\n          // need to also make sure that the parent is visible\n          isVisible = ((_b = (_a = collection.itemRefs[parentId]) === null || _a === void 0 ? void 0 : _a.visibleIndex) !== null && _b !== void 0 ? _b : -1) !== -1;\n        }\n        collection.itemRefs[itemId] = {\n          id: item.id,\n          ref: {\n            current: null\n          },\n          visibleIndex: isVisible ? index : -1\n        };\n        if (isVisible) {\n          index += 1;\n          collection.visibleItems.push(item);\n        }\n        return collection;\n      }, {\n        visibleItems: [],\n        itemRefs: {}\n      });\n    }, [expandedIds, flattenedItems, rootId]),\n    visibleItems = _b.visibleItems,\n    itemRefs = _b.itemRefs;\n  return [visibleItems, itemRefs, flattenedItems];\n}","map":{"version":3,"names":["useMemo","getTreeItemId","flatten","_a","list","item","index","baseId","parentIndexes","valueKey","getItemValue","isCustom","id","value","itemId","parentId","childItems","push","isParent","nextIndexes","__spreadArray","__read","forEach","child","childIndex","useFlattenedTreeList","items","rootId","expandedIds","flattenedItems","reduce","_b","collection","isVisible","includes","itemRefs","visibleIndex","ref","current","visibleItems"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\tree\\src\\useFlattenedTreeList.ts"],"sourcesContent":["import type { MutableRefObject } from \"react\";\nimport { useMemo } from \"react\";\n\nimport { getTreeItemId } from \"./getTreeItemId\";\nimport type {\n  ExpandedIds,\n  TreeItemId,\n  TreeProps,\n  UnknownTreeItem,\n} from \"./types\";\nimport type { NestedTreeItem } from \"./useNestedTreeList\";\n\nexport interface SearchableTreeItem {\n  /**\n   * A DOM Node `id` to use.\n   */\n  id: string;\n\n  /**\n   * A searchable value for the tree item.\n   */\n  value: string;\n\n  isParent: boolean;\n  itemId: TreeItemId;\n  parentId: TreeItemId | null;\n}\n\ntype TreeConfig = Required<\n  Pick<TreeProps<UnknownTreeItem>, \"valueKey\" | \"getItemValue\">\n>;\n\ninterface FlattenOptions extends TreeConfig {\n  list: SearchableTreeItem[];\n  item: NestedTreeItem<UnknownTreeItem>;\n  index: number;\n  baseId: string;\n  parentIndexes: number[];\n}\n\nfunction flatten({\n  list,\n  item,\n  index,\n  baseId,\n  parentIndexes,\n  valueKey,\n  getItemValue,\n}: FlattenOptions): SearchableTreeItem[] {\n  if (item.isCustom) {\n    return list;\n  }\n\n  const id = getTreeItemId(baseId, index, parentIndexes);\n  const value = getItemValue(item, valueKey);\n  const { itemId, parentId, childItems } = item;\n  list.push({\n    id,\n    itemId,\n    parentId,\n    isParent: !!childItems,\n    value,\n  });\n\n  if (!childItems) {\n    return list;\n  }\n\n  const nextIndexes = [...parentIndexes, index + 1];\n  childItems.forEach((child, childIndex) => {\n    flatten({\n      list,\n      item: child,\n      index: childIndex,\n      valueKey,\n      getItemValue,\n      baseId,\n      parentIndexes: nextIndexes,\n    });\n  });\n\n  return list;\n}\n\ninterface Options extends TreeConfig {\n  id: string;\n  items: readonly NestedTreeItem<UnknownTreeItem>[];\n  expandedIds: ExpandedIds;\n  rootId: TreeItemId | null;\n}\n\nexport type TreeItemRef = MutableRefObject<HTMLLIElement | null>;\nexport interface ItemMetadata {\n  id: string;\n  ref: TreeItemRef;\n  visibleIndex: number;\n}\n\nexport type MetadataRecord = Record<TreeItemId, ItemMetadata>;\n\ninterface ItemCollection {\n  itemRefs: MetadataRecord;\n  visibleItems: SearchableTreeItem[];\n}\n\ntype ReturnValue = [SearchableTreeItem[], MetadataRecord, SearchableTreeItem[]];\n\n/**\n * Creates a flattened and ordered list of all the tree items that are current visible\n * in the DOM based on the expanded ids. This is only required for handling keyboard\n * navigation with `aria-activedescendant` movement so the items can be \"focused\" with\n * typeahead and keyboard movement since the keyboard movement API requires DOM refs\n * to be passed to each element.\n *\n * This flattened list will remove the `childItems` (if it existed) on each item for\n * simplicity and the child items aren't needed for this flattened list.\n *\n * @internal\n */\nexport function useFlattenedTreeList({\n  id,\n  items,\n  rootId,\n  expandedIds,\n  valueKey,\n  getItemValue,\n}: Options): ReturnValue {\n  const flattenedItems = useMemo(\n    () =>\n      items.reduce<SearchableTreeItem[]>(\n        (list, item, index) =>\n          flatten({\n            list,\n            item,\n            index,\n            valueKey,\n            getItemValue,\n            baseId: id,\n            parentIndexes: [],\n          }),\n        []\n      ),\n    [getItemValue, id, items, valueKey]\n  );\n\n  const { visibleItems, itemRefs } = useMemo(() => {\n    let index = 0;\n    return flattenedItems.reduce<ItemCollection>(\n      (collection, item) => {\n        const { parentId, itemId } = item;\n        let isVisible = parentId === rootId;\n        if (parentId !== null && expandedIds.includes(parentId)) {\n          // need to also make sure that the parent is visible\n          isVisible =\n            (collection.itemRefs[parentId]?.visibleIndex ?? -1) !== -1;\n        }\n\n        collection.itemRefs[itemId] = {\n          id: item.id,\n          ref: { current: null },\n          visibleIndex: isVisible ? index : -1,\n        };\n        if (isVisible) {\n          index += 1;\n          collection.visibleItems.push(item);\n        }\n        return collection;\n      },\n      { visibleItems: [], itemRefs: {} }\n    );\n  }, [expandedIds, flattenedItems, rootId]);\n\n  return [visibleItems, itemRefs, flattenedItems];\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAASA,OAAO,QAAQ,OAAO;AAE/B,SAASC,aAAa,QAAQ,iBAAiB;AAqC/C,SAASC,OAAOA,CAACC,EAQA;MAPfC,IAAI,GAAAD,EAAA,CAAAC,IAAA;IACJC,IAAI,GAAAF,EAAA,CAAAE,IAAA;IACJC,KAAK,GAAAH,EAAA,CAAAG,KAAA;IACLC,MAAM,GAAAJ,EAAA,CAAAI,MAAA;IACNC,aAAa,GAAAL,EAAA,CAAAK,aAAA;IACbC,QAAQ,GAAAN,EAAA,CAAAM,QAAA;IACRC,YAAY,GAAAP,EAAA,CAAAO,YAAA;EAEZ,IAAIL,IAAI,CAACM,QAAQ,EAAE;IACjB,OAAOP,IAAI;;EAGb,IAAMQ,EAAE,GAAGX,aAAa,CAACM,MAAM,EAAED,KAAK,EAAEE,aAAa,CAAC;EACtD,IAAMK,KAAK,GAAGH,YAAY,CAACL,IAAI,EAAEI,QAAQ,CAAC;EAClC,IAAAK,MAAM,GAA2BT,IAAI,CAAAS,MAA/B;IAAEC,QAAQ,GAAiBV,IAAI,CAAAU,QAArB;IAAEC,UAAU,GAAKX,IAAI,CAAAW,UAAT;EACpCZ,IAAI,CAACa,IAAI,CAAC;IACRL,EAAE,EAAAA,EAAA;IACFE,MAAM,EAAAA,MAAA;IACNC,QAAQ,EAAAA,QAAA;IACRG,QAAQ,EAAE,CAAC,CAACF,UAAU;IACtBH,KAAK,EAAAA;GACN,CAAC;EAEF,IAAI,CAACG,UAAU,EAAE;IACf,OAAOZ,IAAI;;EAGb,IAAMe,WAAW,GAAAC,aAAA,CAAAA,aAAA,KAAAC,MAAA,CAAOb,aAAa,YAAEF,KAAK,GAAG,CAAC,SAAC;EACjDU,UAAU,CAACM,OAAO,CAAC,UAACC,KAAK,EAAEC,UAAU;IACnCtB,OAAO,CAAC;MACNE,IAAI,EAAAA,IAAA;MACJC,IAAI,EAAEkB,KAAK;MACXjB,KAAK,EAAEkB,UAAU;MACjBf,QAAQ,EAAAA,QAAA;MACRC,YAAY,EAAAA,YAAA;MACZH,MAAM,EAAAA,MAAA;MACNC,aAAa,EAAEW;KAChB,CAAC;EACJ,CAAC,CAAC;EAEF,OAAOf,IAAI;AACb;AAyBA;;;;;;;;;;;;AAYA,OAAM,SAAUqB,oBAAoBA,CAACtB,EAO3B;MANRS,EAAE,GAAAT,EAAA,CAAAS,EAAA;IACFc,KAAK,GAAAvB,EAAA,CAAAuB,KAAA;IACLC,MAAM,GAAAxB,EAAA,CAAAwB,MAAA;IACNC,WAAW,GAAAzB,EAAA,CAAAyB,WAAA;IACXnB,QAAQ,GAAAN,EAAA,CAAAM,QAAA;IACRC,YAAY,GAAAP,EAAA,CAAAO,YAAA;EAEZ,IAAMmB,cAAc,GAAG7B,OAAO,CAC5B;IACE,OAAA0B,KAAK,CAACI,MAAM,CACV,UAAC1B,IAAI,EAAEC,IAAI,EAAEC,KAAK;MAChB,OAAAJ,OAAO,CAAC;QACNE,IAAI,EAAAA,IAAA;QACJC,IAAI,EAAAA,IAAA;QACJC,KAAK,EAAAA,KAAA;QACLG,QAAQ,EAAAA,QAAA;QACRC,YAAY,EAAAA,YAAA;QACZH,MAAM,EAAEK,EAAE;QACVJ,aAAa,EAAE;OAChB,CAAC;IARF,CAQE,EACJ,EAAE,CACH;EAZD,CAYC,EACH,CAACE,YAAY,EAAEE,EAAE,EAAEc,KAAK,EAAEjB,QAAQ,CAAC,CACpC;EAEK,IAAAsB,EAAA,GAA6B/B,OAAO,CAAC;MACzC,IAAIM,KAAK,GAAG,CAAC;MACb,OAAOuB,cAAc,CAACC,MAAM,CAC1B,UAACE,UAAU,EAAE3B,IAAI;;QACP,IAAAU,QAAQ,GAAaV,IAAI,CAAAU,QAAjB;UAAED,MAAM,GAAKT,IAAI,CAAAS,MAAT;QACxB,IAAImB,SAAS,GAAGlB,QAAQ,KAAKY,MAAM;QACnC,IAAIZ,QAAQ,KAAK,IAAI,IAAIa,WAAW,CAACM,QAAQ,CAACnB,QAAQ,CAAC,EAAE;UACvD;UACAkB,SAAS,GACP,CAAC,CAAAF,EAAA,IAAA5B,EAAA,GAAA6B,UAAU,CAACG,QAAQ,CAACpB,QAAQ,CAAC,cAAAZ,EAAA,uBAAAA,EAAA,CAAEiC,YAAY,cAAAL,EAAA,cAAAA,EAAA,GAAI,CAAC,CAAC,MAAM,CAAC,CAAC;;QAG9DC,UAAU,CAACG,QAAQ,CAACrB,MAAM,CAAC,GAAG;UAC5BF,EAAE,EAAEP,IAAI,CAACO,EAAE;UACXyB,GAAG,EAAE;YAAEC,OAAO,EAAE;UAAI,CAAE;UACtBF,YAAY,EAAEH,SAAS,GAAG3B,KAAK,GAAG,CAAC;SACpC;QACD,IAAI2B,SAAS,EAAE;UACb3B,KAAK,IAAI,CAAC;UACV0B,UAAU,CAACO,YAAY,CAACtB,IAAI,CAACZ,IAAI,CAAC;;QAEpC,OAAO2B,UAAU;MACnB,CAAC,EACD;QAAEO,YAAY,EAAE,EAAE;QAAEJ,QAAQ,EAAE;MAAE,CAAE,CACnC;IACH,CAAC,EAAE,CAACP,WAAW,EAAEC,cAAc,EAAEF,MAAM,CAAC,CAAC;IAzBjCY,YAAY,GAAAR,EAAA,CAAAQ,YAAA;IAAEJ,QAAQ,GAAAJ,EAAA,CAAAI,QAyBW;EAEzC,OAAO,CAACI,YAAY,EAAEJ,QAAQ,EAAEN,cAAc,CAAC;AACjD"},"metadata":{},"sourceType":"module","externalDependencies":[]}