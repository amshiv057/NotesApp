{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { useRef, useState } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"../useIsomorphicLayoutEffect\";\n/**\n * @internal\n */\nvar TOUCH_TIMEOUT = 1200;\n/**\n * This hook helps determine the current interaction mode by attaching the\n * required event listeners to the window. The `mode` will always be defaulted\n * to `mouse` at first since it has the least possibilities of causing errors\n * with styles since the mouse-only styles are normally just `:hover` effects.\n *\n * ## Switching between modes:\n *\n * ### While in `mouse` mode:\n *\n * - any `keydown` event will switch to `keyboard` mode\n *   - this does have the side effect of meta keys also causing the switch over,\n *     but it feels fine since it helps show the current focus in the document\n *     as well\n * - any `touchstart` event will switch to `touch` mode\n *\n * ### While in `keyboard` mode:\n *\n * - any `mousedown` event will switch to `mouse` mode\n *   - it is perfectly okay to move the mouse while in keyboard mode, but still\n *     want to keep the keyboard styles until the user actually starts clicking\n * - any `touchstart` event will switch to `touch` mode\n *\n * ### While in `touch` mode:\n *\n * - any `mousemove` event will switch to `mouse` mode, but **only** if there\n *   hasn't been a `contextmenu` event within the last `1.2s`\n *   - you can really only switch back to `mouse` mode if you are using the\n *     devtools to emulate devices OR using a touch-desktop. I don't know how\n *     common this really is though.\n *   - touching the screen will always fire a `mousemove` event (which is why\n *     the `:hover` styles are normally with `rmd-utils-mouse-only`) and even\n *     after the `contextmenu` event. Normally want to go back to `mouse` mode\n *     when the mouse re-enters the `window`\n *\n * Note: It's currently impossible to switch from `touch` to `keyboard`\n * immediately. You'd first need to switch to `mouse` and then to `keyboard`. I\n * don't really know of any use-cases other than the weird touch-desktop stuff\n * and I have no experience using them.\n *\n * @internal\n */\nexport function useInteractionMode() {\n  var _a = __read(useState(\"mouse\"), 2),\n    mode = _a[0],\n    setMode = _a[1];\n  var lastTouchTime = useRef(0);\n  var isTouchContextMenu = useRef(false);\n  useIsomorphicLayoutEffect(function () {\n    var enableMouseMode = function () {\n      return setMode(\"mouse\");\n    };\n    var enableKeyboardMode = function () {\n      return setMode(\"keyboard\");\n    };\n    var handleTouchStart = function () {\n      lastTouchTime.current = Date.now();\n      isTouchContextMenu.current = false;\n      setMode(\"touch\");\n    };\n    var handleMouseMove = function () {\n      if (isTouchContextMenu.current || Date.now() - lastTouchTime.current < TOUCH_TIMEOUT) {\n        isTouchContextMenu.current = false;\n        return;\n      }\n      enableMouseMode();\n    };\n    var handleContextMenu = function () {\n      isTouchContextMenu.current = true;\n    };\n    var className = \"rmd-utils--\".concat(mode);\n    document.body.classList.add(className);\n    window.addEventListener(\"touchstart\", handleTouchStart, true);\n    if (mode === \"mouse\") {\n      window.addEventListener(\"keydown\", enableKeyboardMode, true);\n    } else if (mode === \"keyboard\") {\n      window.addEventListener(\"mousedown\", enableMouseMode, true);\n    } else {\n      window.addEventListener(\"mousemove\", handleMouseMove, true);\n      window.addEventListener(\"contextmenu\", handleContextMenu, true);\n    }\n    return function () {\n      document.body.classList.remove(className);\n      window.removeEventListener(\"touchstart\", handleTouchStart, true);\n      if (mode === \"mouse\") {\n        window.removeEventListener(\"keydown\", enableKeyboardMode, true);\n      } else if (mode === \"keyboard\") {\n        window.removeEventListener(\"mousedown\", enableMouseMode, true);\n      } else {\n        window.removeEventListener(\"mousemove\", handleMouseMove, true);\n        window.removeEventListener(\"contextmenu\", handleContextMenu, true);\n      }\n    };\n  }, [mode]);\n  return mode;\n}","map":{"version":3,"names":["useRef","useState","useIsomorphicLayoutEffect","TOUCH_TIMEOUT","useInteractionMode","_a","__read","mode","setMode","lastTouchTime","isTouchContextMenu","enableMouseMode","enableKeyboardMode","handleTouchStart","current","Date","now","handleMouseMove","handleContextMenu","className","concat","document","body","classList","add","window","addEventListener","remove","removeEventListener"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\utils\\src\\mode\\useInteractionMode.ts"],"sourcesContent":["import { useRef, useState } from \"react\";\n\nimport type { UserInteractionMode } from \"./types\";\nimport { useIsomorphicLayoutEffect } from \"../useIsomorphicLayoutEffect\";\n\n/**\n * @internal\n */\nconst TOUCH_TIMEOUT = 1200;\n\n/**\n * This hook helps determine the current interaction mode by attaching the\n * required event listeners to the window. The `mode` will always be defaulted\n * to `mouse` at first since it has the least possibilities of causing errors\n * with styles since the mouse-only styles are normally just `:hover` effects.\n *\n * ## Switching between modes:\n *\n * ### While in `mouse` mode:\n *\n * - any `keydown` event will switch to `keyboard` mode\n *   - this does have the side effect of meta keys also causing the switch over,\n *     but it feels fine since it helps show the current focus in the document\n *     as well\n * - any `touchstart` event will switch to `touch` mode\n *\n * ### While in `keyboard` mode:\n *\n * - any `mousedown` event will switch to `mouse` mode\n *   - it is perfectly okay to move the mouse while in keyboard mode, but still\n *     want to keep the keyboard styles until the user actually starts clicking\n * - any `touchstart` event will switch to `touch` mode\n *\n * ### While in `touch` mode:\n *\n * - any `mousemove` event will switch to `mouse` mode, but **only** if there\n *   hasn't been a `contextmenu` event within the last `1.2s`\n *   - you can really only switch back to `mouse` mode if you are using the\n *     devtools to emulate devices OR using a touch-desktop. I don't know how\n *     common this really is though.\n *   - touching the screen will always fire a `mousemove` event (which is why\n *     the `:hover` styles are normally with `rmd-utils-mouse-only`) and even\n *     after the `contextmenu` event. Normally want to go back to `mouse` mode\n *     when the mouse re-enters the `window`\n *\n * Note: It's currently impossible to switch from `touch` to `keyboard`\n * immediately. You'd first need to switch to `mouse` and then to `keyboard`. I\n * don't really know of any use-cases other than the weird touch-desktop stuff\n * and I have no experience using them.\n *\n * @internal\n */\nexport function useInteractionMode(): UserInteractionMode {\n  const [mode, setMode] = useState<UserInteractionMode>(\"mouse\");\n  const lastTouchTime = useRef(0);\n  const isTouchContextMenu = useRef(false);\n\n  useIsomorphicLayoutEffect(() => {\n    const enableMouseMode = (): void => setMode(\"mouse\");\n    const enableKeyboardMode = (): void => setMode(\"keyboard\");\n\n    const handleTouchStart = (): void => {\n      lastTouchTime.current = Date.now();\n      isTouchContextMenu.current = false;\n      setMode(\"touch\");\n    };\n\n    const handleMouseMove = (): void => {\n      if (\n        isTouchContextMenu.current ||\n        Date.now() - lastTouchTime.current < TOUCH_TIMEOUT\n      ) {\n        isTouchContextMenu.current = false;\n        return;\n      }\n\n      enableMouseMode();\n    };\n    const handleContextMenu = (): void => {\n      isTouchContextMenu.current = true;\n    };\n\n    const className = `rmd-utils--${mode}`;\n    document.body.classList.add(className);\n    window.addEventListener(\"touchstart\", handleTouchStart, true);\n    if (mode === \"mouse\") {\n      window.addEventListener(\"keydown\", enableKeyboardMode, true);\n    } else if (mode === \"keyboard\") {\n      window.addEventListener(\"mousedown\", enableMouseMode, true);\n    } else {\n      window.addEventListener(\"mousemove\", handleMouseMove, true);\n      window.addEventListener(\"contextmenu\", handleContextMenu, true);\n    }\n\n    return () => {\n      document.body.classList.remove(className);\n      window.removeEventListener(\"touchstart\", handleTouchStart, true);\n      if (mode === \"mouse\") {\n        window.removeEventListener(\"keydown\", enableKeyboardMode, true);\n      } else if (mode === \"keyboard\") {\n        window.removeEventListener(\"mousedown\", enableMouseMode, true);\n      } else {\n        window.removeEventListener(\"mousemove\", handleMouseMove, true);\n        window.removeEventListener(\"contextmenu\", handleContextMenu, true);\n      }\n    };\n  }, [mode]);\n\n  return mode;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAGxC,SAASC,yBAAyB,QAAQ,8BAA8B;AAExE;;;AAGA,IAAMC,aAAa,GAAG,IAAI;AAE1B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CA,OAAM,SAAUC,kBAAkBA,CAAA;EAC1B,IAAAC,EAAA,GAAAC,MAAA,CAAkBL,QAAQ,CAAsB,OAAO,CAAC;IAAvDM,IAAI,GAAAF,EAAA;IAAEG,OAAO,GAAAH,EAAA,GAA0C;EAC9D,IAAMI,aAAa,GAAGT,MAAM,CAAC,CAAC,CAAC;EAC/B,IAAMU,kBAAkB,GAAGV,MAAM,CAAC,KAAK,CAAC;EAExCE,yBAAyB,CAAC;IACxB,IAAMS,eAAe,GAAG,SAAAA,CAAA;MAAY,OAAAH,OAAO,CAAC,OAAO,CAAC;IAAhB,CAAgB;IACpD,IAAMI,kBAAkB,GAAG,SAAAA,CAAA;MAAY,OAAAJ,OAAO,CAAC,UAAU,CAAC;IAAnB,CAAmB;IAE1D,IAAMK,gBAAgB,GAAG,SAAAA,CAAA;MACvBJ,aAAa,CAACK,OAAO,GAAGC,IAAI,CAACC,GAAG,EAAE;MAClCN,kBAAkB,CAACI,OAAO,GAAG,KAAK;MAClCN,OAAO,CAAC,OAAO,CAAC;IAClB,CAAC;IAED,IAAMS,eAAe,GAAG,SAAAA,CAAA;MACtB,IACEP,kBAAkB,CAACI,OAAO,IAC1BC,IAAI,CAACC,GAAG,EAAE,GAAGP,aAAa,CAACK,OAAO,GAAGX,aAAa,EAClD;QACAO,kBAAkB,CAACI,OAAO,GAAG,KAAK;QAClC;;MAGFH,eAAe,EAAE;IACnB,CAAC;IACD,IAAMO,iBAAiB,GAAG,SAAAA,CAAA;MACxBR,kBAAkB,CAACI,OAAO,GAAG,IAAI;IACnC,CAAC;IAED,IAAMK,SAAS,GAAG,cAAAC,MAAA,CAAcb,IAAI,CAAE;IACtCc,QAAQ,CAACC,IAAI,CAACC,SAAS,CAACC,GAAG,CAACL,SAAS,CAAC;IACtCM,MAAM,CAACC,gBAAgB,CAAC,YAAY,EAAEb,gBAAgB,EAAE,IAAI,CAAC;IAC7D,IAAIN,IAAI,KAAK,OAAO,EAAE;MACpBkB,MAAM,CAACC,gBAAgB,CAAC,SAAS,EAAEd,kBAAkB,EAAE,IAAI,CAAC;KAC7D,MAAM,IAAIL,IAAI,KAAK,UAAU,EAAE;MAC9BkB,MAAM,CAACC,gBAAgB,CAAC,WAAW,EAAEf,eAAe,EAAE,IAAI,CAAC;KAC5D,MAAM;MACLc,MAAM,CAACC,gBAAgB,CAAC,WAAW,EAAET,eAAe,EAAE,IAAI,CAAC;MAC3DQ,MAAM,CAACC,gBAAgB,CAAC,aAAa,EAAER,iBAAiB,EAAE,IAAI,CAAC;;IAGjE,OAAO;MACLG,QAAQ,CAACC,IAAI,CAACC,SAAS,CAACI,MAAM,CAACR,SAAS,CAAC;MACzCM,MAAM,CAACG,mBAAmB,CAAC,YAAY,EAAEf,gBAAgB,EAAE,IAAI,CAAC;MAChE,IAAIN,IAAI,KAAK,OAAO,EAAE;QACpBkB,MAAM,CAACG,mBAAmB,CAAC,SAAS,EAAEhB,kBAAkB,EAAE,IAAI,CAAC;OAChE,MAAM,IAAIL,IAAI,KAAK,UAAU,EAAE;QAC9BkB,MAAM,CAACG,mBAAmB,CAAC,WAAW,EAAEjB,eAAe,EAAE,IAAI,CAAC;OAC/D,MAAM;QACLc,MAAM,CAACG,mBAAmB,CAAC,WAAW,EAAEX,eAAe,EAAE,IAAI,CAAC;QAC9DQ,MAAM,CAACG,mBAAmB,CAAC,aAAa,EAAEV,iBAAiB,EAAE,IAAI,CAAC;;IAEtE,CAAC;EACH,CAAC,EAAE,CAACX,IAAI,CAAC,CAAC;EAEV,OAAOA,IAAI;AACb"},"metadata":{},"sourceType":"module","externalDependencies":[]}