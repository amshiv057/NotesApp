{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { useFixedPositioning } from \"@react-md/transition\";\nimport { MovementPresets, scrollIntoView, useActiveDescendantMovement, useCloseOnOutsideClick, useEnsuredRef, useIsUserInteractionMode, useToggle } from \"@react-md/utils\";\nimport { getFilterFunction } from \"./utils\";\n/**\n * This hook handles all the autocomplete's \"logic\" and behavior.\n *\n * @internal\n */\nexport function useAutoComplete(_a) {\n  var _b;\n  var suggestionsId = _a.suggestionsId,\n    data = _a.data,\n    propValue = _a.propValue,\n    _c = _a.defaultValue,\n    defaultValue = _c === void 0 ? \"\" : _c,\n    filterFn = _a.filter,\n    filterOptions = _a.filterOptions,\n    filterOnNoValue = _a.filterOnNoValue,\n    valueKey = _a.valueKey,\n    getResultId = _a.getResultId,\n    getResultValue = _a.getResultValue,\n    onBlur = _a.onBlur,\n    onFocus = _a.onFocus,\n    onClick = _a.onClick,\n    onChange = _a.onChange,\n    onKeyDown = _a.onKeyDown,\n    forwardedRef = _a.forwardedRef,\n    onAutoComplete = _a.onAutoComplete,\n    clearOnAutoComplete = _a.clearOnAutoComplete,\n    anchor = _a.anchor,\n    xMargin = _a.xMargin,\n    yMargin = _a.yMargin,\n    vwMargin = _a.vwMargin,\n    vhMargin = _a.vhMargin,\n    transformOrigin = _a.transformOrigin,\n    listboxWidth = _a.listboxWidth,\n    listboxStyle = _a.listboxStyle,\n    preventOverlap = _a.preventOverlap,\n    disableSwapping = _a.disableSwapping,\n    disableVHBounds = _a.disableVHBounds,\n    closeOnResize = _a.closeOnResize,\n    closeOnScroll = _a.closeOnScroll,\n    propDisableShowOnFocus = _a.disableShowOnFocus,\n    isListAutocomplete = _a.isListAutocomplete,\n    isInlineAutocomplete = _a.isInlineAutocomplete;\n  var _d = __read(useEnsuredRef(forwardedRef), 2),\n    ref = _d[0],\n    refHandler = _d[1];\n  var filter = getFilterFunction(filterFn);\n  var _e = __read(useState(function () {\n      var _a;\n      var options = __assign(__assign({}, filterOptions), {\n        valueKey: valueKey,\n        getItemValue: getResultValue,\n        startsWith: (_a = filterOptions === null || filterOptions === void 0 ? void 0 : filterOptions.startsWith) !== null && _a !== void 0 ? _a : isInlineAutocomplete\n      });\n      var value = propValue !== null && propValue !== void 0 ? propValue : defaultValue;\n      var filteredData = filterOnNoValue || value ? filter(value, data, options) : data;\n      var match = value;\n      if (isInlineAutocomplete && filteredData.length) {\n        match = getResultValue(filteredData[0], valueKey);\n      }\n      return {\n        value: value,\n        match: match,\n        filteredData: filteredData\n      };\n    }), 2),\n    _f = _e[0],\n    stateValue = _f.value,\n    match = _f.match,\n    stateFilteredData = _f.filteredData,\n    setState = _e[1];\n  var filteredData = filterFn === \"none\" ? data : stateFilteredData;\n  var startsWith = (_b = filterOptions === null || filterOptions === void 0 ? void 0 : filterOptions.startsWith) !== null && _b !== void 0 ? _b : isInlineAutocomplete;\n  var value = propValue !== null && propValue !== void 0 ? propValue : stateValue;\n  var setValue = useCallback(function (nextValue) {\n    var isBackspace = value.length > nextValue.length || !!match && value.length === nextValue.length;\n    var filtered = data;\n    if (nextValue || filterOnNoValue) {\n      var options = __assign(__assign({}, filterOptions), {\n        valueKey: valueKey,\n        getItemValue: getResultValue,\n        startsWith: startsWith\n      });\n      filtered = filter(nextValue, data, options);\n    }\n    var nextMatch = nextValue;\n    if (isInlineAutocomplete && filtered.length && !isBackspace) {\n      nextMatch = getResultValue(filtered[0], valueKey);\n      var input = ref.current;\n      if (input && !isBackspace) {\n        input.value = nextMatch;\n        input.setSelectionRange(nextValue.length, nextMatch.length);\n      }\n    }\n    setState({\n      value: nextValue,\n      match: nextMatch,\n      filteredData: filtered\n    });\n  }, [ref, data, filter, filterOnNoValue, filterOptions, isInlineAutocomplete, getResultValue, value, match, startsWith, valueKey]);\n  // this is really just a hacky way to make sure that once a value has been\n  // autocompleted, the menu doesn't immediately re-appear due to the hook below\n  // for showing when the value/ filtered data list change\n  var autocompleted = useRef(false);\n  var handleChange = useCallback(function (event) {\n    if (onChange) {\n      onChange(event);\n    }\n    autocompleted.current = false;\n    setValue(event.currentTarget.value);\n  }, [setValue, onChange]);\n  var _g = __read(useToggle(false), 3),\n    visible = _g[0],\n    show = _g[1],\n    hide = _g[2];\n  var isTouch = useIsUserInteractionMode(\"touch\");\n  var disableShowOnFocus = propDisableShowOnFocus !== null && propDisableShowOnFocus !== void 0 ? propDisableShowOnFocus : isTouch;\n  var focused = useRef(false);\n  var handleBlur = useCallback(function (event) {\n    if (onBlur) {\n      onBlur(event);\n    }\n    focused.current = false;\n  }, [onBlur]);\n  var handleFocus = useCallback(function (event) {\n    if (onFocus) {\n      onFocus(event);\n    }\n    if (disableShowOnFocus) {\n      return;\n    }\n    focused.current = true;\n    if (isListAutocomplete && filteredData.length) {\n      show();\n    }\n  }, [filteredData, isListAutocomplete, onFocus, show, disableShowOnFocus]);\n  var handleClick = useCallback(function (event) {\n    if (onClick) {\n      onClick(event);\n    }\n    // since click events also trigger focus events right beforehand, want to\n    // skip the first click handler and require a second click to show it.\n    // this is why the focused.current isn't set onFocus for\n    // disableShowOnFocus\n    if (disableShowOnFocus && !focused.current) {\n      focused.current = true;\n      return;\n    }\n    if (isListAutocomplete && filteredData.length) {\n      show();\n    }\n  }, [disableShowOnFocus, filteredData.length, isListAutocomplete, onClick, show]);\n  var handleAutoComplete = useCallback(function (index) {\n    var result = filteredData[index];\n    var resultValue = getResultValue(result, valueKey);\n    if (onAutoComplete) {\n      onAutoComplete({\n        value: resultValue,\n        index: index,\n        result: result,\n        dataIndex: data.findIndex(function (datum) {\n          return getResultValue(datum, valueKey) === resultValue;\n        }),\n        filteredData: filteredData\n      });\n    }\n    setValue(clearOnAutoComplete ? \"\" : resultValue);\n    autocompleted.current = true;\n  }, [clearOnAutoComplete, data, filteredData, getResultValue, onAutoComplete, valueKey, setValue]);\n  var nodeRef = useRef(null);\n  var _h = useActiveDescendantMovement(__assign(__assign({}, MovementPresets.VERTICAL_COMBOBOX), {\n      getId: getResultId,\n      items: filteredData,\n      baseId: suggestionsId,\n      onChange: function (_a, itemRefs) {\n        var index = _a.index,\n          items = _a.items,\n          target = _a.target;\n        // the default scroll into view behavior for aria-activedescendant\n        // movement won't work here since the \"target\" element will actually be\n        // the input element instead of the listbox. So need to implement the\n        // scroll into view behavior manually from the listbox instead.\n        var item = itemRefs[index] && itemRefs[index].current;\n        var listbox = nodeRef.current;\n        if (item && listbox && listbox.scrollHeight > listbox.offsetHeight) {\n          scrollIntoView(listbox, item);\n        }\n        if (!isInlineAutocomplete) {\n          return;\n        }\n        var nextMatch = getResultValue(items[index], valueKey);\n        target.value = nextMatch;\n        target.setSelectionRange(0, nextMatch.length);\n        setState(function (prevState) {\n          return __assign(__assign({}, prevState), {\n            value: nextMatch,\n            match: nextMatch\n          });\n        });\n      },\n      onKeyDown: function (event) {\n        if (onKeyDown) {\n          onKeyDown(event);\n        }\n        var input = event.currentTarget;\n        switch (event.key) {\n          case \"ArrowDown\":\n            if (isListAutocomplete && event.altKey && !visible && filteredData.length) {\n              // don't want the cursor to move if there is text\n              event.preventDefault();\n              event.stopPropagation();\n              show();\n              setFocusedIndex(-1);\n            }\n            break;\n          case \"ArrowUp\":\n            if (isListAutocomplete && event.altKey && visible) {\n              // don't want the cursor to move if there is text\n              event.preventDefault();\n              event.stopPropagation();\n              hide();\n            }\n            break;\n          case \"Tab\":\n            event.stopPropagation();\n            hide();\n            break;\n          case \"ArrowRight\":\n            if (isInlineAutocomplete && input.selectionStart !== input.selectionEnd) {\n              var index = focusedIndex !== -1 ? focusedIndex : 0;\n              hide();\n              handleAutoComplete(index);\n            }\n            break;\n          case \"Enter\":\n            if (visible && focusedIndex >= 0) {\n              event.preventDefault();\n              event.stopPropagation();\n              handleAutoComplete(focusedIndex);\n              hide();\n            }\n            break;\n          case \"Escape\":\n            if (visible) {\n              event.stopPropagation();\n              hide();\n            } else if (value) {\n              event.stopPropagation();\n              setValue(\"\");\n            }\n            break;\n          // no default\n        }\n      }\n    })),\n    activeId = _h.activeId,\n    itemRefs = _h.itemRefs,\n    handleKeyDown = _h.onKeyDown,\n    focusedIndex = _h.focusedIndex,\n    setFocusedIndex = _h.setFocusedIndex;\n  useCloseOnOutsideClick({\n    enabled: visible,\n    element: ref.current,\n    onOutsideClick: hide\n  });\n  var _j = useFixedPositioning({\n      fixedTo: ref,\n      nodeRef: nodeRef,\n      anchor: anchor,\n      onScroll: function (_event, _a) {\n        var visible = _a.visible;\n        if (closeOnScroll || !visible) {\n          hide();\n        }\n      },\n      onResize: closeOnResize ? hide : undefined,\n      width: listboxWidth,\n      xMargin: xMargin,\n      yMargin: yMargin,\n      vwMargin: vwMargin,\n      vhMargin: vhMargin,\n      transformOrigin: transformOrigin,\n      preventOverlap: preventOverlap,\n      disableSwapping: disableSwapping,\n      disableVHBounds: disableVHBounds\n    }),\n    listboxRef = _j.ref,\n    style = _j.style,\n    callbacks = _j.callbacks,\n    updateStyle = _j.updateStyle;\n  useEffect(function () {\n    if (!focused.current || autocompleted.current) {\n      return;\n    }\n    if (filteredData.length && !visible && value.length && isListAutocomplete) {\n      show();\n    } else if (!filteredData.length && visible) {\n      hide();\n    }\n    // this effect is just for toggling the visibility states as needed if the\n    // value or filter data list changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [filteredData, value]);\n  useEffect(function () {\n    if (!visible) {\n      setFocusedIndex(-1);\n      return;\n    }\n    updateStyle();\n    // only want to trigger on data changes and setFocusedIndex shouldn't change\n    // anyways\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [visible, filteredData]);\n  return {\n    ref: refHandler,\n    value: value,\n    match: match,\n    visible: visible,\n    activeId: activeId,\n    itemRefs: itemRefs,\n    filteredData: filteredData,\n    fixedStyle: __assign(__assign({}, style), listboxStyle),\n    transitionHooks: callbacks,\n    listboxRef: listboxRef,\n    handleBlur: handleBlur,\n    handleFocus: handleFocus,\n    handleClick: handleClick,\n    handleChange: handleChange,\n    handleKeyDown: handleKeyDown,\n    handleAutoComplete: handleAutoComplete\n  };\n}","map":{"version":3,"names":["useCallback","useEffect","useRef","useState","useFixedPositioning","MovementPresets","scrollIntoView","useActiveDescendantMovement","useCloseOnOutsideClick","useEnsuredRef","useIsUserInteractionMode","useToggle","getFilterFunction","useAutoComplete","_a","suggestionsId","data","propValue","_c","defaultValue","filterFn","filter","filterOptions","filterOnNoValue","valueKey","getResultId","getResultValue","onBlur","onFocus","onClick","onChange","onKeyDown","forwardedRef","onAutoComplete","clearOnAutoComplete","anchor","xMargin","yMargin","vwMargin","vhMargin","transformOrigin","listboxWidth","listboxStyle","preventOverlap","disableSwapping","disableVHBounds","closeOnResize","closeOnScroll","propDisableShowOnFocus","disableShowOnFocus","isListAutocomplete","isInlineAutocomplete","_d","__read","ref","refHandler","_e","options","__assign","getItemValue","startsWith","value","filteredData","match","length","_f","stateValue","stateFilteredData","setState","_b","setValue","nextValue","isBackspace","filtered","nextMatch","input","current","setSelectionRange","autocompleted","handleChange","event","currentTarget","_g","visible","show","hide","isTouch","focused","handleBlur","handleFocus","handleClick","handleAutoComplete","index","result","resultValue","dataIndex","findIndex","datum","nodeRef","_h","VERTICAL_COMBOBOX","getId","items","baseId","itemRefs","target","item","listbox","scrollHeight","offsetHeight","prevState","key","altKey","preventDefault","stopPropagation","setFocusedIndex","selectionStart","selectionEnd","focusedIndex","activeId","handleKeyDown","enabled","element","onOutsideClick","_j","fixedTo","onScroll","_event","onResize","undefined","width","listboxRef","style","callbacks","updateStyle","fixedStyle","transitionHooks"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\autocomplete\\src\\useAutoComplete.ts"],"sourcesContent":["import type {\n  ChangeEventHandler,\n  CSSProperties,\n  FocusEventHandler,\n  HTMLAttributes,\n  KeyboardEventHandler,\n  MouseEventHandler,\n  Ref,\n} from \"react\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport type { ListElement } from \"@react-md/list\";\nimport type { FixedPositioningTransitionCallbacks } from \"@react-md/transition\";\nimport { useFixedPositioning } from \"@react-md/transition\";\nimport type { ItemRefList } from \"@react-md/utils\";\nimport {\n  MovementPresets,\n  scrollIntoView,\n  useActiveDescendantMovement,\n  useCloseOnOutsideClick,\n  useEnsuredRef,\n  useIsUserInteractionMode,\n  useToggle,\n} from \"@react-md/utils\";\n\nimport type {\n  AutoCompleteData,\n  AutoCompleteListboxPositionOptions,\n  AutoCompleteProps,\n} from \"./types\";\nimport { getFilterFunction } from \"./utils\";\n\ntype EventHandlers = Pick<\n  HTMLAttributes<HTMLInputElement>,\n  \"onBlur\" | \"onFocus\" | \"onChange\" | \"onClick\" | \"onKeyDown\"\n>;\n\nexport type RequiredAutoCompleteProps = Required<\n  Pick<\n    AutoCompleteProps,\n    | \"data\"\n    | \"filter\"\n    | \"filterOptions\"\n    | \"filterOnNoValue\"\n    | \"valueKey\"\n    | \"getResultId\"\n    | \"getResultValue\"\n    | \"clearOnAutoComplete\"\n  >\n>;\n\nexport type OptionalAutoCompleteProps = Pick<\n  AutoCompleteProps,\n  \"onAutoComplete\" | \"disableShowOnFocus\"\n>;\n\nexport interface AutoCompleteOptions\n  extends EventHandlers,\n    OptionalAutoCompleteProps,\n    RequiredAutoCompleteProps,\n    AutoCompleteListboxPositionOptions {\n  isListAutocomplete: boolean;\n  isInlineAutocomplete: boolean;\n  forwardedRef?: Ref<HTMLInputElement>;\n  suggestionsId: string;\n  propValue?: string;\n  defaultValue?: string;\n}\n\nexport interface AutoCompleteReturnValue {\n  ref: (instance: HTMLInputElement | null) => void;\n  match: string;\n  value: string;\n  visible: boolean;\n  activeId: string;\n  itemRefs: ItemRefList<HTMLLIElement>;\n  filteredData: readonly AutoCompleteData[];\n  listboxRef: Ref<ListElement>;\n  handleBlur: FocusEventHandler<HTMLInputElement>;\n  handleFocus: FocusEventHandler<HTMLInputElement>;\n  handleClick: MouseEventHandler<HTMLInputElement>;\n  handleChange: ChangeEventHandler<HTMLInputElement>;\n  handleKeyDown: KeyboardEventHandler<HTMLInputElement>;\n  handleAutoComplete: (index: number) => void;\n  fixedStyle: CSSProperties | undefined;\n  transitionHooks: Required<FixedPositioningTransitionCallbacks>;\n}\n\n/**\n * This hook handles all the autocomplete's \"logic\" and behavior.\n *\n * @internal\n */\nexport function useAutoComplete({\n  suggestionsId,\n  data,\n  propValue,\n  defaultValue = \"\",\n  filter: filterFn,\n  filterOptions,\n  filterOnNoValue,\n  valueKey,\n  getResultId,\n  getResultValue,\n  onBlur,\n  onFocus,\n  onClick,\n  onChange,\n  onKeyDown,\n  forwardedRef,\n  onAutoComplete,\n  clearOnAutoComplete,\n  anchor,\n  xMargin,\n  yMargin,\n  vwMargin,\n  vhMargin,\n  transformOrigin,\n  listboxWidth,\n  listboxStyle,\n  preventOverlap,\n  disableSwapping,\n  disableVHBounds,\n  closeOnResize,\n  closeOnScroll,\n  disableShowOnFocus: propDisableShowOnFocus,\n  isListAutocomplete,\n  isInlineAutocomplete,\n}: AutoCompleteOptions): AutoCompleteReturnValue {\n  const [ref, refHandler] = useEnsuredRef(forwardedRef);\n\n  const filter = getFilterFunction(filterFn);\n  const [\n    { value: stateValue, match, filteredData: stateFilteredData },\n    setState,\n  ] = useState(() => {\n    const options = {\n      ...filterOptions,\n      valueKey,\n      getItemValue: getResultValue,\n      startsWith: filterOptions?.startsWith ?? isInlineAutocomplete,\n    };\n    const value = propValue ?? defaultValue;\n    const filteredData =\n      filterOnNoValue || value ? filter(value, data, options) : data;\n\n    let match = value;\n    if (isInlineAutocomplete && filteredData.length) {\n      match = getResultValue(filteredData[0], valueKey);\n    }\n\n    return {\n      value,\n      match,\n      filteredData,\n    };\n  });\n  const filteredData = filterFn === \"none\" ? data : stateFilteredData;\n  const startsWith = filterOptions?.startsWith ?? isInlineAutocomplete;\n  const value = propValue ?? stateValue;\n\n  const setValue = useCallback(\n    (nextValue: string) => {\n      const isBackspace =\n        value.length > nextValue.length ||\n        (!!match && value.length === nextValue.length);\n\n      let filtered = data;\n      if (nextValue || filterOnNoValue) {\n        const options = {\n          ...filterOptions,\n          valueKey,\n          getItemValue: getResultValue,\n          startsWith,\n        };\n\n        filtered = filter(nextValue, data, options);\n      }\n\n      let nextMatch = nextValue;\n      if (isInlineAutocomplete && filtered.length && !isBackspace) {\n        nextMatch = getResultValue(filtered[0], valueKey);\n\n        const input = ref.current;\n        if (input && !isBackspace) {\n          input.value = nextMatch;\n          input.setSelectionRange(nextValue.length, nextMatch.length);\n        }\n      }\n\n      setState({ value: nextValue, match: nextMatch, filteredData: filtered });\n    },\n    [\n      ref,\n      data,\n      filter,\n      filterOnNoValue,\n      filterOptions,\n      isInlineAutocomplete,\n      getResultValue,\n      value,\n      match,\n      startsWith,\n      valueKey,\n    ]\n  );\n\n  // this is really just a hacky way to make sure that once a value has been\n  // autocompleted, the menu doesn't immediately re-appear due to the hook below\n  // for showing when the value/ filtered data list change\n  const autocompleted = useRef(false);\n\n  const handleChange = useCallback(\n    (event: React.ChangeEvent<HTMLInputElement>) => {\n      if (onChange) {\n        onChange(event);\n      }\n\n      autocompleted.current = false;\n      setValue(event.currentTarget.value);\n    },\n    [setValue, onChange]\n  );\n\n  const [visible, show, hide] = useToggle(false);\n  const isTouch = useIsUserInteractionMode(\"touch\");\n  const disableShowOnFocus = propDisableShowOnFocus ?? isTouch;\n\n  const focused = useRef(false);\n  const handleBlur = useCallback(\n    (event: React.FocusEvent<HTMLInputElement>) => {\n      if (onBlur) {\n        onBlur(event);\n      }\n\n      focused.current = false;\n    },\n    [onBlur]\n  );\n  const handleFocus = useCallback(\n    (event: React.FocusEvent<HTMLInputElement>) => {\n      if (onFocus) {\n        onFocus(event);\n      }\n\n      if (disableShowOnFocus) {\n        return;\n      }\n\n      focused.current = true;\n      if (isListAutocomplete && filteredData.length) {\n        show();\n      }\n    },\n    [filteredData, isListAutocomplete, onFocus, show, disableShowOnFocus]\n  );\n  const handleClick = useCallback(\n    (event: React.MouseEvent<HTMLInputElement>) => {\n      if (onClick) {\n        onClick(event);\n      }\n\n      // since click events also trigger focus events right beforehand, want to\n      // skip the first click handler and require a second click to show it.\n      // this is why the focused.current isn't set onFocus for\n      // disableShowOnFocus\n      if (disableShowOnFocus && !focused.current) {\n        focused.current = true;\n        return;\n      }\n\n      if (isListAutocomplete && filteredData.length) {\n        show();\n      }\n    },\n    [disableShowOnFocus, filteredData.length, isListAutocomplete, onClick, show]\n  );\n\n  const handleAutoComplete = useCallback(\n    (index: number) => {\n      const result = filteredData[index];\n      const resultValue = getResultValue(result, valueKey);\n      if (onAutoComplete) {\n        onAutoComplete({\n          value: resultValue,\n          index,\n          result,\n          dataIndex: data.findIndex(\n            (datum) => getResultValue(datum, valueKey) === resultValue\n          ),\n          filteredData,\n        });\n      }\n\n      setValue(clearOnAutoComplete ? \"\" : resultValue);\n      autocompleted.current = true;\n    },\n    [\n      clearOnAutoComplete,\n      data,\n      filteredData,\n      getResultValue,\n      onAutoComplete,\n      valueKey,\n      setValue,\n    ]\n  );\n\n  const nodeRef = useRef<ListElement | null>(null);\n  const {\n    activeId,\n    itemRefs,\n    onKeyDown: handleKeyDown,\n    focusedIndex,\n    setFocusedIndex,\n  } = useActiveDescendantMovement<\n    AutoCompleteData,\n    HTMLInputElement,\n    HTMLLIElement\n  >({\n    ...MovementPresets.VERTICAL_COMBOBOX,\n    getId: getResultId,\n    items: filteredData,\n    baseId: suggestionsId,\n    onChange({ index, items, target }, itemRefs) {\n      // the default scroll into view behavior for aria-activedescendant\n      // movement won't work here since the \"target\" element will actually be\n      // the input element instead of the listbox. So need to implement the\n      // scroll into view behavior manually from the listbox instead.\n      const item = itemRefs[index] && itemRefs[index].current;\n      const { current: listbox } = nodeRef;\n      if (item && listbox && listbox.scrollHeight > listbox.offsetHeight) {\n        scrollIntoView(listbox, item);\n      }\n\n      if (!isInlineAutocomplete) {\n        return;\n      }\n\n      const nextMatch = getResultValue(items[index], valueKey);\n      target.value = nextMatch;\n      target.setSelectionRange(0, nextMatch.length);\n      setState((prevState) => ({\n        ...prevState,\n        value: nextMatch,\n        match: nextMatch,\n      }));\n    },\n    onKeyDown(event) {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      const input = event.currentTarget;\n      switch (event.key) {\n        case \"ArrowDown\":\n          if (\n            isListAutocomplete &&\n            event.altKey &&\n            !visible &&\n            filteredData.length\n          ) {\n            // don't want the cursor to move if there is text\n            event.preventDefault();\n            event.stopPropagation();\n            show();\n            setFocusedIndex(-1);\n          }\n          break;\n        case \"ArrowUp\":\n          if (isListAutocomplete && event.altKey && visible) {\n            // don't want the cursor to move if there is text\n            event.preventDefault();\n            event.stopPropagation();\n            hide();\n          }\n          break;\n        case \"Tab\":\n          event.stopPropagation();\n          hide();\n          break;\n        case \"ArrowRight\":\n          if (\n            isInlineAutocomplete &&\n            input.selectionStart !== input.selectionEnd\n          ) {\n            const index = focusedIndex !== -1 ? focusedIndex : 0;\n            hide();\n            handleAutoComplete(index);\n          }\n          break;\n        case \"Enter\":\n          if (visible && focusedIndex >= 0) {\n            event.preventDefault();\n            event.stopPropagation();\n            handleAutoComplete(focusedIndex);\n            hide();\n          }\n          break;\n        case \"Escape\":\n          if (visible) {\n            event.stopPropagation();\n            hide();\n          } else if (value) {\n            event.stopPropagation();\n            setValue(\"\");\n          }\n          break;\n        // no default\n      }\n    },\n  });\n\n  useCloseOnOutsideClick({\n    enabled: visible,\n    element: ref.current,\n    onOutsideClick: hide,\n  });\n\n  const {\n    ref: listboxRef,\n    style,\n    callbacks,\n    updateStyle,\n  } = useFixedPositioning({\n    fixedTo: ref,\n    nodeRef,\n    anchor,\n    onScroll(_event, { visible }) {\n      if (closeOnScroll || !visible) {\n        hide();\n      }\n    },\n    onResize: closeOnResize ? hide : undefined,\n    width: listboxWidth,\n    xMargin,\n    yMargin,\n    vwMargin,\n    vhMargin,\n    transformOrigin,\n    preventOverlap,\n    disableSwapping,\n    disableVHBounds,\n  });\n\n  useEffect(() => {\n    if (!focused.current || autocompleted.current) {\n      return;\n    }\n\n    if (filteredData.length && !visible && value.length && isListAutocomplete) {\n      show();\n    } else if (!filteredData.length && visible) {\n      hide();\n    }\n\n    // this effect is just for toggling the visibility states as needed if the\n    // value or filter data list changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [filteredData, value]);\n\n  useEffect(() => {\n    if (!visible) {\n      setFocusedIndex(-1);\n      return;\n    }\n\n    updateStyle();\n\n    // only want to trigger on data changes and setFocusedIndex shouldn't change\n    // anyways\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [visible, filteredData]);\n\n  return {\n    ref: refHandler,\n    value,\n    match,\n    visible,\n    activeId,\n    itemRefs,\n    filteredData,\n    fixedStyle: { ...style, ...listboxStyle },\n    transitionHooks: callbacks,\n    listboxRef,\n    handleBlur,\n    handleFocus,\n    handleClick,\n    handleChange,\n    handleKeyDown,\n    handleAutoComplete,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}