{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { useCallback, useEffect, useReducer } from \"react\";\nimport { nanoid } from \"nanoid\";\nimport { omit } from \"@react-md/utils\";\nimport { getFileParser as defaultGetFileParser, FileAccessError, isValidFileName as defaultIsValidFileName, validateFiles as defaultValidateFiles } from \"./utils\";\n/** @internal */\nvar EMPTY_LIST = [];\n/** @internal */\nvar EMPTY_OBJECT = {};\n/**\n * This hook is generally used to upload files **to the browser** in different\n * formats to be previewed `<img>`, `<video>`, `<embed>`, etc tags. However, it\n * can also be used to upload the files as an `ArrayBuffer` and then uploaded to\n * a server.\n *\n * Note: If using the `aws-sdk` to upload files directly to S3, **do not use\n * this hook** since it uses its own upload process.\n *\n * @typeParam E - An optional HTMLElement type that is used for the\n * {@link FileUploadHandlers}.\n * @typeParam CustomError - An optional error type that gets returned from the\n * {@link FilesValidator}.\n * @param options - All the {@link FileUploadOptions}\n * @returns the {@link FileUploadHookReturnValue}\n * @remarks \\@since 2.9.0\n */\nexport function useFileUpload(_a) {\n  var _b = _a === void 0 ? {} : _a,\n    _c = _b.maxFiles,\n    maxFiles = _c === void 0 ? -1 : _c,\n    _d = _b.extensions,\n    extensions = _d === void 0 ? EMPTY_LIST : _d,\n    _e = _b.minFileSize,\n    minFileSize = _e === void 0 ? -1 : _e,\n    _f = _b.maxFileSize,\n    maxFileSize = _f === void 0 ? -1 : _f,\n    _g = _b.totalFileSize,\n    totalFileSize = _g === void 0 ? -1 : _g,\n    _h = _b.concurrency,\n    concurrency = _h === void 0 ? -1 : _h,\n    propOnDrop = _b.onDrop,\n    propOnChange = _b.onChange,\n    _j = _b.validateFiles,\n    validateFiles = _j === void 0 ? defaultValidateFiles : _j,\n    _k = _b.getFileParser,\n    getFileParser = _k === void 0 ? defaultGetFileParser : _k,\n    _l = _b.isValidFileName,\n    isValidFileName = _l === void 0 ? defaultIsValidFileName : _l;\n  var _m = __read(useReducer(function reducer(state, action) {\n      var _a, _b, _c, _d;\n      switch (action.type) {\n        case \"reset\":\n          // need to reuse constants so that calling reset doesn't cause an\n          // infinite loop in an effect\n          return {\n            stats: EMPTY_OBJECT,\n            errors: EMPTY_LIST,\n            readers: EMPTY_OBJECT\n          };\n        case \"remove\":\n          return __assign(__assign({}, state), {\n            stats: omit(state.stats, action.files)\n          });\n        case \"queue\":\n          return __assign(__assign({}, state), {\n            stats: __assign(__assign({}, state.stats), action.files.reduce(function (files, file) {\n              var key = nanoid();\n              files[key] = {\n                key: key,\n                file: file,\n                progress: 0,\n                status: \"pending\"\n              };\n              return files;\n            }, {})),\n            errors: __spreadArray(__spreadArray([], __read(state.errors), false), __read(action.errors), false)\n          });\n        case \"start\":\n          {\n            var key = action.key,\n              reader = action.reader;\n            /* istanbul ignore next */\n            if (!state.stats[key]) {\n              throw new Error(\"Missing file with key \\\"\".concat(key, \"\\\"\"));\n            }\n            var fileStats = {\n              key: key,\n              file: state.stats[key].file,\n              progress: 0,\n              status: \"uploading\"\n            };\n            return __assign(__assign({}, state), {\n              readers: __assign(__assign({}, state.readers), (_a = {}, _a[key] = reader, _a)),\n              stats: __assign(__assign({}, state.stats), (_b = {}, _b[key] = fileStats, _b))\n            });\n          }\n        case \"progress\":\n          {\n            var key = action.key,\n              progress = action.progress;\n            /* istanbul ignore next */\n            if (!state.stats[key]) {\n              throw new Error(\"Missing file with key \\\"\".concat(key, \"\\\"\"));\n            }\n            return __assign(__assign({}, state), {\n              stats: __assign(__assign({}, state.stats), (_c = {}, _c[key] = __assign(__assign({}, state.stats[key]), {\n                progress: progress\n              }), _c))\n            });\n          }\n        case \"complete\":\n          {\n            var key = action.key,\n              result = action.result;\n            /* istanbul ignore next */\n            if (!state.stats[key]) {\n              throw new Error(\"Missing file with key \\\"\".concat(key, \"\\\"\"));\n            }\n            var file = {\n              key: key,\n              file: state.stats[key].file,\n              status: \"complete\",\n              result: result,\n              progress: 100\n            };\n            var _e = state.readers,\n              _f = key,\n              _reader = _e[_f],\n              readers_1 = __rest(_e, [typeof _f === \"symbol\" ? _f : _f + \"\"]);\n            return __assign(__assign({}, state), {\n              readers: readers_1,\n              stats: __assign(__assign({}, state.stats), (_d = {}, _d[key] = file, _d))\n            });\n          }\n        case \"clearErrors\":\n          return __assign(__assign({}, state), {\n            errors: []\n          });\n        default:\n          /* istanbul ignore next */\n          return state;\n      }\n    }, {\n      stats: EMPTY_OBJECT,\n      errors: EMPTY_LIST,\n      readers: EMPTY_OBJECT\n    }), 2),\n    state = _m[0],\n    dispatch = _m[1];\n  var stats = state.stats,\n    errors = state.errors,\n    readers = state.readers;\n  var statsList = Object.values(stats);\n  var totalFiles = statsList.length;\n  var totalBytes = statsList.reduce(function (result, _a) {\n    var size = _a.file.size;\n    return result + size;\n  }, 0);\n  var queueFiles = useCallback(function (files) {\n    var _a = validateFiles(files, {\n        maxFiles: maxFiles,\n        extensions: extensions,\n        minFileSize: minFileSize,\n        maxFileSize: maxFileSize,\n        totalBytes: totalBytes,\n        totalFiles: totalFiles,\n        totalFileSize: totalFileSize,\n        isValidFileName: isValidFileName\n      }),\n      pending = _a.pending,\n      errors = _a.errors;\n    dispatch({\n      type: \"queue\",\n      errors: errors,\n      files: pending\n    });\n  }, [validateFiles, maxFiles, extensions, minFileSize, maxFileSize, totalBytes, totalFiles, totalFileSize, isValidFileName]);\n  var onDrop = useCallback(function (event) {\n    propOnDrop === null || propOnDrop === void 0 ? void 0 : propOnDrop(event);\n    event.preventDefault();\n    event.stopPropagation();\n    try {\n      var files = event.dataTransfer.files;\n      if (files) {\n        queueFiles(Array.from(files));\n      }\n    } catch (e) {\n      dispatch({\n        type: \"queue\",\n        files: [],\n        errors: [new FileAccessError(e instanceof Error ? e.message : undefined)]\n      });\n    }\n  }, [queueFiles, propOnDrop]);\n  var onChange = useCallback(function (event) {\n    propOnChange === null || propOnChange === void 0 ? void 0 : propOnChange(event);\n    try {\n      var files = event.currentTarget.files;\n      if (files) {\n        queueFiles(Array.from(files));\n      } else {\n        throw new Error();\n      }\n    } catch (e) {\n      dispatch({\n        type: \"queue\",\n        files: [],\n        errors: [new FileAccessError(e instanceof Error ? e.message : undefined)]\n      });\n    }\n  }, [queueFiles, propOnChange]);\n  var remove = useCallback(function (keyOrKeys) {\n    var files = typeof keyOrKeys === \"string\" ? [keyOrKeys] : keyOrKeys;\n    files.forEach(function (fileKey) {\n      var _a;\n      (_a = readers[fileKey]) === null || _a === void 0 ? void 0 : _a.abort();\n    });\n    dispatch({\n      type: \"remove\",\n      files: files\n    });\n  }, [readers]);\n  var reset = useCallback(function () {\n    Object.values(readers).forEach(function (reader) {\n      reader.abort();\n    });\n    dispatch({\n      type: \"reset\"\n    });\n  }, [readers]);\n  var clearErrors = useCallback(function () {\n    dispatch({\n      type: \"clearErrors\"\n    });\n  }, []);\n  var start = useCallback(function (key, reader) {\n    dispatch({\n      type: \"start\",\n      key: key,\n      reader: reader\n    });\n  }, []);\n  var complete = useCallback(function (key, result) {\n    if (result === void 0) {\n      result = null;\n    }\n    dispatch({\n      type: \"complete\",\n      key: key,\n      result: result\n    });\n  }, []);\n  var createProgressEventHandler = useCallback(function (key) {\n    return function (event) {\n      if (event.lengthComputable) {\n        var percentage = Math.round(event.loaded * 100 / event.total);\n        dispatch({\n          type: \"progress\",\n          key: key,\n          progress: percentage\n        });\n      }\n    };\n  }, []);\n  useEffect(function () {\n    var pending = [];\n    var uploading = [];\n    Object.values(stats).forEach(function (file) {\n      if (file.status === \"pending\") {\n        pending.push(file);\n      } else if (file.status === \"uploading\") {\n        uploading.push(file);\n      }\n    });\n    var lastIndex = concurrency === -1 ? pending.length : Math.max(0, concurrency - uploading.length);\n    var queue = pending.slice(0, lastIndex);\n    if (!queue.length) {\n      return;\n    }\n    queue.forEach(function (stats) {\n      var key = stats.key,\n        file = stats.file;\n      var reader = new FileReader();\n      // using `addEventListener` instead of directly setting to\n      // `reader.progress`/`reader.load` so it's easier to test\n      reader.addEventListener(\"progress\", createProgressEventHandler(key));\n      reader.addEventListener(\"load\", function () {\n        complete(key, reader.result);\n      });\n      start(key, reader);\n      var parser = getFileParser(file);\n      /* istanbul ignore next */\n      if (process.env.NODE_ENV !== \"production\" && ![\"readAsText\", \"readAsDataURL\", \"readAsArrayBuffer\", \"readAsBinaryString\"].includes(parser)) {\n        throw new Error(\"Invalid file reader parser\");\n      }\n      reader[parser](file);\n    });\n  }, [concurrency, stats, getFileParser, createProgressEventHandler, start, complete]);\n  var accept = \"\";\n  if (extensions.length) {\n    accept = extensions.reduce(function (s, ext) {\n      return \"\".concat(s ? \"\".concat(s, \",\") : \"\", \".\").concat(ext);\n    }, \"\");\n  }\n  return {\n    stats: statsList,\n    errors: errors,\n    accept: accept,\n    totalBytes: totalBytes,\n    totalFiles: totalFiles,\n    onDrop: onDrop,\n    onChange: onChange,\n    reset: reset,\n    remove: remove,\n    clearErrors: clearErrors\n  };\n}","map":{"version":3,"names":["useCallback","useEffect","useReducer","nanoid","omit","getFileParser","defaultGetFileParser","FileAccessError","isValidFileName","defaultIsValidFileName","validateFiles","defaultValidateFiles","EMPTY_LIST","EMPTY_OBJECT","useFileUpload","_a","_b","_c","maxFiles","_d","extensions","_e","minFileSize","_f","maxFileSize","_g","totalFileSize","_h","concurrency","propOnDrop","onDrop","propOnChange","onChange","_j","_k","_l","_m","__read","reducer","state","action","type","stats","errors","readers","__assign","files","reduce","file","key","progress","status","__spreadArray","reader","Error","concat","fileStats","result","_reader","readers_1","__rest","dispatch","statsList","Object","values","totalFiles","length","totalBytes","size","queueFiles","pending","event","preventDefault","stopPropagation","dataTransfer","Array","from","e","message","undefined","currentTarget","remove","keyOrKeys","forEach","fileKey","abort","reset","clearErrors","start","complete","createProgressEventHandler","lengthComputable","percentage","Math","round","loaded","total","uploading","push","lastIndex","max","queue","slice","FileReader","addEventListener","parser","process","env","NODE_ENV","includes","accept","s","ext"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\form\\src\\file-input\\useFileUpload.ts"],"sourcesContent":["import type { ChangeEvent, DragEvent } from \"react\";\nimport { useCallback, useEffect, useReducer } from \"react\";\nimport { nanoid } from \"nanoid\";\nimport { omit } from \"@react-md/utils\";\n\nimport type {\n  CompletedFileUploadStats,\n  FileReaderResult,\n  FileUploadHandlers,\n  FileUploadStats,\n  FileValidationError,\n  FilesValidator,\n  GetFileParser,\n  ProcessingFileUploadStats,\n  FileValidationOptions,\n} from \"./utils\";\nimport {\n  getFileParser as defaultGetFileParser,\n  FileAccessError,\n  isValidFileName as defaultIsValidFileName,\n  validateFiles as defaultValidateFiles,\n} from \"./utils\";\n\n/**\n *\n * @typeParam CustomError - An optional error type that gets returned from the\n * {@link FilesValidator}.\n * @remarks \\@since 2.9.0\n */\nexport interface FileUploadState<CustomError = never> {\n  /**\n   * All the files that have been validated and are either:\n   * - pending upload\n   * - uploading\n   * - complete\n   *\n   * Each key in this object is the {@link BaseFileUploadStats.key} generated\n   * once the upload starts pending.\n   */\n  stats: Readonly<Record<string, Readonly<FileUploadStats>>>;\n\n  /**\n   * A list of validation errors that have occurred before starting the upload\n   * process.\n   *\n   * @see {@link FileAccessError}\n   * @see {@link TooManyFilesError}\n   * @see {@link FileValidationError}\n   */\n  errors: readonly FileValidationError<CustomError>[];\n}\n\n/**\n *\n * @typeParam CustomError - An optional error type that gets returned from the\n * {@link FilesValidator}.\n * @remarks \\@since 2.9.0\n * @internal\n */\nexport interface FileUploadHookState<CustomError = never>\n  extends FileUploadState<CustomError> {\n  /**\n   * All the current readers used for uploading files to the browser.\n   *\n   * Note: Once an upload has completed, the reader will be removed.\n   */\n  readers: Readonly<Record<string, FileReader>>;\n}\n\n/**\n *\n * @typeParam E - An optional HTMLElement type that is used for the\n * {@link FileUploadHandlers}.\n * @typeParam CustomError - An optional error type that gets returned from the\n * {@link FilesValidator}.\n * @remarks \\@since 2.9.0\n */\nexport interface FileUploadOptions<E extends HTMLElement, CustomError = never>\n  extends FileUploadHandlers<E>,\n    FileValidationOptions {\n  /**\n   * Setting this value to a number greater than `0` will update the browser\n   * upload process to queue the uploads in chunks instead of all at once. This\n   * can help prevent the browser from freezing if dealing with large files that\n   * are being converted to data urls.\n   *\n   * @defaultValue `-1`\n   */\n  concurrency?: number;\n\n  /** {@inheritDoc FilesValidator} */\n  validateFiles?: FilesValidator<CustomError>;\n  /** {@inheritDoc GetFileParser} */\n  getFileParser?: GetFileParser;\n}\n\n/** @internal */\ntype Action<E = never> =\n  | {\n      type: \"queue\";\n      errors: readonly FileValidationError<E>[];\n      files: readonly File[];\n    }\n  | { type: \"reset\" }\n  | { type: \"remove\"; files: readonly string[] }\n  | { type: \"start\"; key: string; reader: FileReader }\n  | { type: \"progress\"; key: string; progress: number }\n  | { type: \"complete\"; key: string; result: FileReaderResult }\n  | { type: \"clearErrors\" };\n\n/** @remarks \\@since 2.9.0 */\nexport interface FileUploadActions {\n  /**\n   * Reset everything related to uploads ensuring that all file readers have\n   * been aborted.\n   */\n  reset(): void;\n\n  /**\n   * Removes all the errors that exist in state without cancelling any of the\n   * uploads already in progress.\n   */\n  clearErrors(): void;\n\n  /**\n   * This function is used to cancel pending and uploading files or removing\n   * completed files.\n   *\n   * @param keyOrKeys - A single or list of {@link BaseFileUploadStats.key} to\n   * remove from state.\n   */\n  remove(keyOrKeys: string | readonly string[]): void;\n}\n\n/**\n *\n * @typeParam E - An optional HTMLElement type that is used for the\n * {@link FileUploadHandlers}.\n * @typeParam CustomError - An optional error type that gets returned from the\n * {@link FilesValidator}.\n * @remarks \\@since 2.9.0\n */\nexport interface FileUploadHookReturnValue<\n  E extends HTMLElement = HTMLElement,\n  CustomError = never\n> extends FileUploadActions,\n    Required<FileUploadHandlers<E>> {\n  /** {@inheritDoc FileUploadState.errors} */\n  errors: readonly FileValidationError<CustomError>[];\n\n  /**\n   * A list of all the {@link FileUploadStats}.\n   *\n   * @see {@link getSplitFileUploads} for separating by status\n   */\n  stats: readonly Readonly<FileUploadStats>[];\n\n  /**\n   * The total number of bytes for all the files that exist in the\n   * {@link stats} list.\n   */\n  totalBytes: number;\n\n  /**\n   * The total number of files in the {@link stats} list.\n   */\n  totalFiles: number;\n\n  /**\n   * An `accept` string that can be passed to the {@link FileInput} component\n   * when the {@link FileValidationOptions.extensions} list has been provided to\n   * limit which files the OS will _attempt_ to allow access to.\n   *\n   * @example\n   * Simple example\n   * ```ts\n   * const extensions = ['pdf', 'docx', 'ppt'];\n   * const { accept } = useFileUpload({ extensions, ...others });\n   *\n   * expect(accept).toBe(\"*.pdf,*.docx,*.ppt\")\n   * ```\n   *\n   * @defaultValue `\"*\"`\n   */\n  accept: string;\n}\n\n/** @internal */\nconst EMPTY_LIST = [] as const;\n/** @internal */\nconst EMPTY_OBJECT = {} as const;\n\n/**\n * This hook is generally used to upload files **to the browser** in different\n * formats to be previewed `<img>`, `<video>`, `<embed>`, etc tags. However, it\n * can also be used to upload the files as an `ArrayBuffer` and then uploaded to\n * a server.\n *\n * Note: If using the `aws-sdk` to upload files directly to S3, **do not use\n * this hook** since it uses its own upload process.\n *\n * @typeParam E - An optional HTMLElement type that is used for the\n * {@link FileUploadHandlers}.\n * @typeParam CustomError - An optional error type that gets returned from the\n * {@link FilesValidator}.\n * @param options - All the {@link FileUploadOptions}\n * @returns the {@link FileUploadHookReturnValue}\n * @remarks \\@since 2.9.0\n */\nexport function useFileUpload<E extends HTMLElement, CustomError = never>({\n  maxFiles = -1,\n  extensions = EMPTY_LIST,\n  minFileSize = -1,\n  maxFileSize = -1,\n  totalFileSize = -1,\n  concurrency = -1,\n  onDrop: propOnDrop,\n  onChange: propOnChange,\n  validateFiles = defaultValidateFiles,\n  getFileParser = defaultGetFileParser,\n  isValidFileName = defaultIsValidFileName,\n}: FileUploadOptions<E, CustomError> = {}): Readonly<\n  FileUploadHookReturnValue<E, CustomError>\n> {\n  const [state, dispatch] = useReducer(\n    function reducer(\n      state: FileUploadHookState<CustomError>,\n      action: Action<CustomError>\n    ) {\n      switch (action.type) {\n        case \"reset\":\n          // need to reuse constants so that calling reset doesn't cause an\n          // infinite loop in an effect\n          return {\n            stats: EMPTY_OBJECT,\n            errors: EMPTY_LIST,\n            readers: EMPTY_OBJECT,\n          };\n        case \"remove\":\n          return {\n            ...state,\n            stats: omit(state.stats, action.files),\n          };\n        case \"queue\":\n          return {\n            ...state,\n            stats: {\n              ...state.stats,\n              ...action.files.reduce<Record<string, ProcessingFileUploadStats>>(\n                (files, file) => {\n                  const key = nanoid();\n                  files[key] = {\n                    key,\n                    file,\n                    progress: 0,\n                    status: \"pending\",\n                  };\n\n                  return files;\n                },\n                {}\n              ),\n            },\n            errors: [...state.errors, ...action.errors],\n          };\n        case \"start\": {\n          const { key, reader } = action;\n          /* istanbul ignore next */\n          if (!state.stats[key]) {\n            throw new Error(`Missing file with key \"${key}\"`);\n          }\n\n          const fileStats: ProcessingFileUploadStats = {\n            key,\n            file: state.stats[key].file,\n            progress: 0,\n            status: \"uploading\",\n          };\n\n          return {\n            ...state,\n            readers: {\n              ...state.readers,\n              [key]: reader,\n            },\n            stats: {\n              ...state.stats,\n              [key]: fileStats,\n            },\n          };\n        }\n        case \"progress\": {\n          const { key, progress } = action;\n          /* istanbul ignore next */\n          if (!state.stats[key]) {\n            throw new Error(`Missing file with key \"${key}\"`);\n          }\n\n          return {\n            ...state,\n            stats: {\n              ...state.stats,\n              [key]: {\n                ...state.stats[key],\n                progress,\n              },\n            },\n          };\n        }\n        case \"complete\": {\n          const { key, result } = action;\n          /* istanbul ignore next */\n          if (!state.stats[key]) {\n            throw new Error(`Missing file with key \"${key}\"`);\n          }\n\n          const file: CompletedFileUploadStats = {\n            key,\n            file: state.stats[key].file,\n            status: \"complete\",\n            result,\n            progress: 100,\n          };\n          const { [key]: _reader, ...readers } = state.readers;\n\n          return {\n            ...state,\n            readers,\n            stats: {\n              ...state.stats,\n              [key]: file,\n            },\n          };\n        }\n        case \"clearErrors\":\n          return { ...state, errors: [] };\n        default:\n          /* istanbul ignore next */\n          return state;\n      }\n    },\n    {\n      stats: EMPTY_OBJECT,\n      errors: EMPTY_LIST,\n      readers: EMPTY_OBJECT,\n    }\n  );\n  const { stats, errors, readers } = state;\n\n  const statsList = Object.values(stats);\n  const totalFiles = statsList.length;\n  const totalBytes = statsList.reduce(\n    (result, { file: { size } }) => result + size,\n    0\n  );\n  const queueFiles = useCallback(\n    (files: readonly File[]) => {\n      const { pending, errors } = validateFiles(files, {\n        maxFiles,\n        extensions,\n        minFileSize,\n        maxFileSize,\n        totalBytes,\n        totalFiles,\n        totalFileSize,\n        isValidFileName,\n      });\n\n      dispatch({ type: \"queue\", errors, files: pending });\n    },\n    [\n      validateFiles,\n      maxFiles,\n      extensions,\n      minFileSize,\n      maxFileSize,\n      totalBytes,\n      totalFiles,\n      totalFileSize,\n      isValidFileName,\n    ]\n  );\n  const onDrop = useCallback(\n    (event: DragEvent<E>) => {\n      propOnDrop?.(event);\n      event.preventDefault();\n      event.stopPropagation();\n\n      try {\n        const files = event.dataTransfer.files;\n        if (files) {\n          queueFiles(Array.from(files));\n        }\n      } catch (e) {\n        dispatch({\n          type: \"queue\",\n          files: [],\n          errors: [\n            new FileAccessError(e instanceof Error ? e.message : undefined),\n          ],\n        });\n      }\n    },\n    [queueFiles, propOnDrop]\n  );\n  const onChange = useCallback(\n    (event: ChangeEvent<HTMLInputElement>) => {\n      propOnChange?.(event);\n      try {\n        const files = event.currentTarget.files;\n        if (files) {\n          queueFiles(Array.from(files));\n        } else {\n          throw new Error();\n        }\n      } catch (e) {\n        dispatch({\n          type: \"queue\",\n          files: [],\n          errors: [\n            new FileAccessError(e instanceof Error ? e.message : undefined),\n          ],\n        });\n      }\n    },\n    [queueFiles, propOnChange]\n  );\n\n  const remove = useCallback(\n    (keyOrKeys: string | readonly string[]) => {\n      const files = typeof keyOrKeys === \"string\" ? [keyOrKeys] : keyOrKeys;\n      files.forEach((fileKey) => {\n        readers[fileKey]?.abort();\n      });\n\n      dispatch({ type: \"remove\", files });\n    },\n    [readers]\n  );\n  const reset = useCallback(() => {\n    Object.values(readers).forEach((reader) => {\n      reader.abort();\n    });\n\n    dispatch({ type: \"reset\" });\n  }, [readers]);\n  const clearErrors = useCallback(() => {\n    dispatch({ type: \"clearErrors\" });\n  }, []);\n  const start = useCallback((key: string, reader: FileReader) => {\n    dispatch({ type: \"start\", key, reader });\n  }, []);\n  const complete = useCallback(\n    (key: string, result: FileReaderResult = null) => {\n      dispatch({ type: \"complete\", key, result });\n    },\n    []\n  );\n  const createProgressEventHandler = useCallback(\n    (key: string) => (event: ProgressEvent) => {\n      if (event.lengthComputable) {\n        const percentage = Math.round((event.loaded * 100) / event.total);\n        dispatch({ type: \"progress\", key, progress: percentage });\n      }\n    },\n    []\n  );\n\n  useEffect(() => {\n    const pending: ProcessingFileUploadStats[] = [];\n    const uploading: ProcessingFileUploadStats[] = [];\n    Object.values(stats).forEach((file) => {\n      if (file.status === \"pending\") {\n        pending.push(file);\n      } else if (file.status === \"uploading\") {\n        uploading.push(file);\n      }\n    });\n\n    const lastIndex =\n      concurrency === -1\n        ? pending.length\n        : Math.max(0, concurrency - uploading.length);\n    const queue = pending.slice(0, lastIndex);\n    if (!queue.length) {\n      return;\n    }\n\n    queue.forEach((stats) => {\n      const { key, file } = stats;\n      const reader = new FileReader();\n\n      // using `addEventListener` instead of directly setting to\n      // `reader.progress`/`reader.load` so it's easier to test\n      reader.addEventListener(\"progress\", createProgressEventHandler(key));\n      reader.addEventListener(\"load\", () => {\n        complete(key, reader.result);\n      });\n\n      start(key, reader);\n      const parser = getFileParser(file);\n      /* istanbul ignore next */\n      if (\n        process.env.NODE_ENV !== \"production\" &&\n        ![\n          \"readAsText\",\n          \"readAsDataURL\",\n          \"readAsArrayBuffer\",\n          \"readAsBinaryString\",\n        ].includes(parser)\n      ) {\n        throw new Error(\"Invalid file reader parser\");\n      }\n\n      reader[parser](file);\n    });\n  }, [\n    concurrency,\n    stats,\n    getFileParser,\n    createProgressEventHandler,\n    start,\n    complete,\n  ]);\n\n  let accept = \"\";\n  if (extensions.length) {\n    accept = extensions.reduce((s, ext) => `${s ? `${s},` : \"\"}.${ext}`, \"\");\n  }\n\n  return {\n    stats: statsList,\n    errors,\n    accept,\n    totalBytes,\n    totalFiles,\n    onDrop,\n    onChange,\n    reset,\n    remove,\n    clearErrors,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}