{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { useCallback, useState } from \"react\";\nimport { getViewportSize } from \"@react-md/utils\";\nimport { DEFAULT_TOOLTIP_THRESHOLD } from \"./constants\";\n/** @internal */\nvar noop = function () {\n  // do nothing\n};\n/**\n * A hook that's used to determine the \"best\" position to render the tooltip\n * within the viewport.\n *\n * @internal\n * @remarks \\@since 2.8.0\n */\nexport function useTooltipPosition(_a) {\n  var determinedPosition = _a.position,\n    _b = _a.defaultPosition,\n    defaultPosition = _b === void 0 ? \"below\" : _b,\n    _c = _a.threshold,\n    threshold = _c === void 0 ? DEFAULT_TOOLTIP_THRESHOLD : _c;\n  var _d = __read(useState(defaultPosition), 2),\n    position = _d[0],\n    setPosition = _d[1];\n  var updatePosition = useCallback(function (container) {\n    var _a = container.getBoundingClientRect(),\n      top = _a.top,\n      left = _a.left;\n    var vh = getViewportSize(\"height\");\n    var vw = getViewportSize(\"width\");\n    var nextPosition = defaultPosition;\n    if (defaultPosition === \"above\" && top < vh * threshold) {\n      nextPosition = \"below\";\n    } else if (defaultPosition === \"below\" && top > vh * threshold) {\n      nextPosition = \"above\";\n    } else if (defaultPosition === \"left\" && left < vw * threshold) {\n      nextPosition = \"right\";\n    } else if (defaultPosition === \"right\" && left > vw * threshold) {\n      nextPosition = \"left\";\n    }\n    setPosition(nextPosition);\n  }, [defaultPosition, threshold]);\n  if (typeof determinedPosition !== \"undefined\") {\n    return [determinedPosition, noop];\n  }\n  return [position, updatePosition];\n}","map":{"version":3,"names":["useCallback","useState","getViewportSize","DEFAULT_TOOLTIP_THRESHOLD","noop","useTooltipPosition","_a","determinedPosition","position","_b","defaultPosition","_c","threshold","_d","__read","setPosition","updatePosition","container","getBoundingClientRect","top","left","vh","vw","nextPosition"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\tooltip\\src\\useTooltipPosition.ts"],"sourcesContent":["import { useCallback, useState } from \"react\";\nimport type { SimplePosition } from \"@react-md/utils\";\nimport { getViewportSize } from \"@react-md/utils\";\n\nimport { DEFAULT_TOOLTIP_THRESHOLD } from \"./constants\";\n\n/** @internal */\nconst noop = (): void => {\n  // do nothing\n};\n\n/**\n * @remarks \\@since 2.8.0\n */\nexport interface TooltipPositionHookOptions {\n  /**\n   * An optional controlled position to use that will disable the functionality\n   * to determine the \"best\" position to render the tooltip within the viewport.\n   */\n  position?: SimplePosition;\n\n  /**\n   * An optional position to use before the positioning calculation has\n   * occurred. This is also used to determine if the position should be\n   * horizontal vs vertical.\n   *\n   * Vertical - `\"below\"` or `\"above\"`\n   * Horizontal - `\"left\"` or `\"right\"`\n   *\n   * @defaultValue `\"below\"`\n   */\n  defaultPosition?: SimplePosition;\n\n  /**\n   * This value should be between 0 and 1 and will be multiplied by either the\n   * viewport height or viewport width to determine the best position to render\n   * the tooltip based on available space within the viewport.\n   *\n   * You _probably_ won't ever really need to update this value.\n   */\n  threshold?: number;\n}\n\n/**\n * @internal\n * @remarks \\@since 2.8.0\n */\nexport type UpdateTooltipPosition = (container: HTMLElement) => void;\n\n/**\n * @internal\n * @remarks \\@since 2.8.0\n */\nexport type TooltipPositionHookReturnValue = [\n  SimplePosition,\n  UpdateTooltipPosition\n];\n\n/**\n * A hook that's used to determine the \"best\" position to render the tooltip\n * within the viewport.\n *\n * @internal\n * @remarks \\@since 2.8.0\n */\nexport function useTooltipPosition({\n  position: determinedPosition,\n  defaultPosition = \"below\",\n  threshold = DEFAULT_TOOLTIP_THRESHOLD,\n}: TooltipPositionHookOptions): TooltipPositionHookReturnValue {\n  const [position, setPosition] = useState(defaultPosition);\n  const updatePosition = useCallback<UpdateTooltipPosition>(\n    (container) => {\n      const { top, left } = container.getBoundingClientRect();\n      const vh = getViewportSize(\"height\");\n      const vw = getViewportSize(\"width\");\n      let nextPosition = defaultPosition;\n      if (defaultPosition === \"above\" && top < vh * threshold) {\n        nextPosition = \"below\";\n      } else if (defaultPosition === \"below\" && top > vh * threshold) {\n        nextPosition = \"above\";\n      } else if (defaultPosition === \"left\" && left < vw * threshold) {\n        nextPosition = \"right\";\n      } else if (defaultPosition === \"right\" && left > vw * threshold) {\n        nextPosition = \"left\";\n      }\n\n      setPosition(nextPosition);\n    },\n    [defaultPosition, threshold]\n  );\n\n  if (typeof determinedPosition !== \"undefined\") {\n    return [determinedPosition, noop];\n  }\n\n  return [position, updatePosition];\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,WAAW,EAAEC,QAAQ,QAAQ,OAAO;AAE7C,SAASC,eAAe,QAAQ,iBAAiB;AAEjD,SAASC,yBAAyB,QAAQ,aAAa;AAEvD;AACA,IAAMC,IAAI,GAAG,SAAAA,CAAA;EACX;AAAA,CACD;AAiDD;;;;;;;AAOA,OAAM,SAAUC,kBAAkBA,CAACC,EAIN;MAHjBC,kBAAkB,GAAAD,EAAA,CAAAE,QAAA;IAC5BC,EAAA,GAAAH,EAAA,CAAAI,eAAyB;IAAzBA,eAAe,GAAAD,EAAA,cAAG,OAAO,GAAAA,EAAA;IACzBE,EAAA,GAAAL,EAAA,CAAAM,SAAqC;IAArCA,SAAS,GAAAD,EAAA,cAAGR,yBAAyB,GAAAQ,EAAA;EAE/B,IAAAE,EAAA,GAAAC,MAAA,CAA0Bb,QAAQ,CAACS,eAAe,CAAC;IAAlDF,QAAQ,GAAAK,EAAA;IAAEE,WAAW,GAAAF,EAAA,GAA6B;EACzD,IAAMG,cAAc,GAAGhB,WAAW,CAChC,UAACiB,SAAS;IACF,IAAAX,EAAA,GAAgBW,SAAS,CAACC,qBAAqB,EAAE;MAA/CC,GAAG,GAAAb,EAAA,CAAAa,GAAA;MAAEC,IAAI,GAAAd,EAAA,CAAAc,IAAsC;IACvD,IAAMC,EAAE,GAAGnB,eAAe,CAAC,QAAQ,CAAC;IACpC,IAAMoB,EAAE,GAAGpB,eAAe,CAAC,OAAO,CAAC;IACnC,IAAIqB,YAAY,GAAGb,eAAe;IAClC,IAAIA,eAAe,KAAK,OAAO,IAAIS,GAAG,GAAGE,EAAE,GAAGT,SAAS,EAAE;MACvDW,YAAY,GAAG,OAAO;KACvB,MAAM,IAAIb,eAAe,KAAK,OAAO,IAAIS,GAAG,GAAGE,EAAE,GAAGT,SAAS,EAAE;MAC9DW,YAAY,GAAG,OAAO;KACvB,MAAM,IAAIb,eAAe,KAAK,MAAM,IAAIU,IAAI,GAAGE,EAAE,GAAGV,SAAS,EAAE;MAC9DW,YAAY,GAAG,OAAO;KACvB,MAAM,IAAIb,eAAe,KAAK,OAAO,IAAIU,IAAI,GAAGE,EAAE,GAAGV,SAAS,EAAE;MAC/DW,YAAY,GAAG,MAAM;;IAGvBR,WAAW,CAACQ,YAAY,CAAC;EAC3B,CAAC,EACD,CAACb,eAAe,EAAEE,SAAS,CAAC,CAC7B;EAED,IAAI,OAAOL,kBAAkB,KAAK,WAAW,EAAE;IAC7C,OAAO,CAACA,kBAAkB,EAAEH,IAAI,CAAC;;EAGnC,OAAO,CAACI,QAAQ,EAAEQ,cAAc,CAAC;AACnC"},"metadata":{},"sourceType":"module","externalDependencies":[]}