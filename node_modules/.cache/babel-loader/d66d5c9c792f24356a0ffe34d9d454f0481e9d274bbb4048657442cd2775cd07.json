{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport cn from \"classnames\";\nimport { useRipples } from \"./ripples/useRipples\";\nimport { useStatesConfigContext } from \"./StatesConfig\";\nimport { useKeyboardClickPolyfill } from \"./useKeyboardClickPolyfill\";\nimport { usePressedStates } from \"./usePressedStates\";\n/**\n * This is probably one of the most useful hook in react-md. Any functional\n * component component that uses this will gain all the different interaction\n * states based on the states context or any custom overrides.\n *\n * The main interaction state is the \"ripple\" effect when an element has been\n * clicked either via keyboard, mouse, or touch.\n *\n * If the ripple effect is disabled, it will fallback to \"polyfilling\"/fixing\n * the `:pressed` pseudo-selector state for items so that a different\n * background-color opacity is applied instead of the entire ripple effect. This\n * is polyfilled since the `:pressed` state does not work on anything other than\n * buttons and links by default and it is not triggered on \"valid\" keyboard\n * clicks with a spacebar.\n *\n * Finally, the element that uses this hook will gain a focused className\n * whenever it gains keyboard focus only.\n *\n * To get all these interaction states to work correctly, this hook returns an\n * object containing:\n *\n * - `handlers`- an object of event handlers that must be passed down to your\n *   component to get the different interaction states. All the event handlers\n *   are automatically merged with any `handlers` that are provided to this hook\n *   so they can all be called if needed.\n * - `className` - the current class name for the element\n * - `ripples` - a renderable element that displays the ripple effects. This\n *   will be `null` when ripples are disabled.\n *\n * @typeParam E - The element type for the component being wrapped. This is\n * really just used to \"better type\" the event handlers.\n */\nexport function useInteractionStates(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var disabled = options.disabled,\n    rippleClassName = options.rippleClassName,\n    rippleContainerClassName = options.rippleContainerClassName,\n    _a = options.disableSpacebarClick,\n    disableSpacebarClick = _a === void 0 ? false : _a,\n    _b = options.disablePressedFallback,\n    disablePressedFallback = _b === void 0 ? false : _b,\n    _c = options.enablePressedAndRipple,\n    enablePressedAndRipple = _c === void 0 ? false : _c,\n    _d = options.disableEnterClick,\n    disableEnterClick = _d === void 0 ? false : _d;\n  var className = options.className,\n    disableRipple = options.disableRipple,\n    disableProgrammaticRipple = options.disableProgrammaticRipple,\n    rippleTimeout = options.rippleTimeout,\n    rippleClassNames = options.rippleClassNames;\n  // populate undefined props from their context values\n  var context = useStatesConfigContext();\n  if (typeof disableRipple === \"undefined\") {\n    disableRipple = context.disableRipple;\n  }\n  if (typeof disableProgrammaticRipple === \"undefined\") {\n    disableProgrammaticRipple = context.disableProgrammaticRipple;\n  }\n  if (typeof rippleTimeout === \"undefined\") {\n    rippleTimeout = context.rippleTimeout;\n  }\n  if (typeof rippleClassNames === \"undefined\") {\n    rippleClassNames = context.rippleClassNames;\n  }\n  var handlers = null;\n  var ripples = null;\n  var ripplesResult = useRipples(__assign(__assign({}, options), {\n    disableSpacebarClick: disableSpacebarClick,\n    disableRipple: disableRipple,\n    disableProgrammaticRipple: disableProgrammaticRipple,\n    rippleTimeout: rippleTimeout,\n    rippleClassName: rippleClassName,\n    rippleContainerClassName: rippleContainerClassName\n  }));\n  if (!disableRipple) {\n    ripples = ripplesResult.ripples, handlers = ripplesResult.handlers;\n  }\n  var pressedResult = usePressedStates(__assign(__assign({}, options), {\n    handlers: handlers || options.handlers,\n    disableSpacebarClick: disableSpacebarClick\n  }));\n  if (enablePressedAndRipple || disableRipple && !disablePressedFallback) {\n    handlers = pressedResult.handlers;\n    className = cn(className, {\n      \"rmd-states--pressed\": pressedResult.pressed\n    });\n  }\n  handlers = handlers || options.handlers || {};\n  handlers.onKeyDown = useKeyboardClickPolyfill({\n    disabled: disabled,\n    disableEnterClick: disableEnterClick,\n    disableSpacebarClick: disableSpacebarClick,\n    onKeyDown: handlers.onKeyDown\n  });\n  return {\n    ripples: ripples,\n    className: className,\n    handlers: handlers\n  };\n}","map":{"version":3,"names":["cn","useRipples","useStatesConfigContext","useKeyboardClickPolyfill","usePressedStates","useInteractionStates","options","disabled","rippleClassName","rippleContainerClassName","_a","disableSpacebarClick","_b","disablePressedFallback","_c","enablePressedAndRipple","_d","disableEnterClick","className","disableRipple","disableProgrammaticRipple","rippleTimeout","rippleClassNames","context","handlers","ripples","ripplesResult","__assign","pressedResult","pressed","onKeyDown"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\states\\src\\useInteractionStates.ts"],"sourcesContent":["import type { ReactNode } from \"react\";\nimport cn from \"classnames\";\nimport type { Maybe } from \"@react-md/utils\";\n\nimport type { MergableRippleHandlers, RipplesOptions } from \"./ripples/types\";\nimport { useRipples } from \"./ripples/useRipples\";\nimport type { StatesConfigContextType } from \"./StatesConfig\";\nimport { useStatesConfigContext } from \"./StatesConfig\";\nimport { useKeyboardClickPolyfill } from \"./useKeyboardClickPolyfill\";\nimport { usePressedStates } from \"./usePressedStates\";\n\nexport interface InteractionStatesOptions<E extends HTMLElement = HTMLElement>\n  extends Partial<StatesConfigContextType>,\n    RipplesOptions<E> {\n  /**\n   * An optional className to merge with the different interaction states.\n   */\n  className?: string;\n\n  /**\n   * Boolean if the enter keyboard click polyfill should be completely disabled.\n   * This is generally used if the keyboard functionality is already built-in to\n   * the element like buttons or labels.\n   */\n  disableEnterClick?: boolean;\n\n  /**\n   * Boolean if the spacebar should not trigger a click event when using the\n   * user pressed spacebar on a focusable element. You _normally_ want the\n   * spacebar to also trigger a click event , but there are a few cases where it\n   * should not (like custom links).\n   *\n   * When this is disabled, it will also make sure that the ripple and pressed\n   * effects are not triggered from a spacebar click.\n   *\n   * @defaultValue `false`\n   */\n  disableSpacebarClick?: boolean;\n\n  /**\n   * Boolean if the component should fallback to using the custom pressed class\n   * names when ripples are disabled.\n   *\n   * @defaultValue `false`\n   */\n  disablePressedFallback?: boolean;\n\n  /**\n   * Boolean if the element should be able to gain both the ripple effect and\n   * the pressed states changes. This will only be enabled if both the\n   * `disableRipple` and `disabledPressedFallback` are still `false`\n   */\n  enablePressedAndRipple?: boolean;\n}\n\ninterface ReturnValue<E extends HTMLElement> {\n  ripples: ReactNode;\n  className: string | undefined;\n  handlers: MergableRippleHandlers<E>;\n}\n\n/**\n * This is probably one of the most useful hook in react-md. Any functional\n * component component that uses this will gain all the different interaction\n * states based on the states context or any custom overrides.\n *\n * The main interaction state is the \"ripple\" effect when an element has been\n * clicked either via keyboard, mouse, or touch.\n *\n * If the ripple effect is disabled, it will fallback to \"polyfilling\"/fixing\n * the `:pressed` pseudo-selector state for items so that a different\n * background-color opacity is applied instead of the entire ripple effect. This\n * is polyfilled since the `:pressed` state does not work on anything other than\n * buttons and links by default and it is not triggered on \"valid\" keyboard\n * clicks with a spacebar.\n *\n * Finally, the element that uses this hook will gain a focused className\n * whenever it gains keyboard focus only.\n *\n * To get all these interaction states to work correctly, this hook returns an\n * object containing:\n *\n * - `handlers`- an object of event handlers that must be passed down to your\n *   component to get the different interaction states. All the event handlers\n *   are automatically merged with any `handlers` that are provided to this hook\n *   so they can all be called if needed.\n * - `className` - the current class name for the element\n * - `ripples` - a renderable element that displays the ripple effects. This\n *   will be `null` when ripples are disabled.\n *\n * @typeParam E - The element type for the component being wrapped. This is\n * really just used to \"better type\" the event handlers.\n */\nexport function useInteractionStates<E extends HTMLElement = HTMLElement>(\n  options: InteractionStatesOptions<E> = {}\n): ReturnValue<E> {\n  const {\n    disabled,\n    rippleClassName,\n    rippleContainerClassName,\n    disableSpacebarClick = false,\n    disablePressedFallback = false,\n    enablePressedAndRipple = false,\n    disableEnterClick = false,\n  } = options;\n\n  let {\n    className,\n    disableRipple,\n    disableProgrammaticRipple,\n    rippleTimeout,\n    rippleClassNames,\n  } = options;\n\n  // populate undefined props from their context values\n  const context = useStatesConfigContext();\n  if (typeof disableRipple === \"undefined\") {\n    ({ disableRipple } = context);\n  }\n\n  if (typeof disableProgrammaticRipple === \"undefined\") {\n    ({ disableProgrammaticRipple } = context);\n  }\n\n  if (typeof rippleTimeout === \"undefined\") {\n    ({ rippleTimeout } = context);\n  }\n\n  if (typeof rippleClassNames === \"undefined\") {\n    ({ rippleClassNames } = context);\n  }\n\n  let handlers: Maybe<MergableRippleHandlers<E>> = null;\n  let ripples: ReactNode = null;\n  const ripplesResult = useRipples({\n    ...options,\n    disableSpacebarClick,\n    disableRipple,\n    disableProgrammaticRipple,\n    rippleTimeout,\n    rippleClassName,\n    rippleContainerClassName,\n  });\n\n  if (!disableRipple) {\n    ({ ripples, handlers } = ripplesResult);\n  }\n\n  const pressedResult = usePressedStates({\n    ...options,\n    handlers: handlers || options.handlers,\n    disableSpacebarClick,\n  });\n\n  if (enablePressedAndRipple || (disableRipple && !disablePressedFallback)) {\n    ({ handlers } = pressedResult);\n    className = cn(className, { \"rmd-states--pressed\": pressedResult.pressed });\n  }\n\n  handlers = handlers || options.handlers || ({} as MergableRippleHandlers<E>);\n\n  handlers.onKeyDown = useKeyboardClickPolyfill({\n    disabled,\n    disableEnterClick,\n    disableSpacebarClick,\n    onKeyDown: handlers.onKeyDown,\n  });\n\n  return {\n    ripples,\n    className,\n    handlers,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}