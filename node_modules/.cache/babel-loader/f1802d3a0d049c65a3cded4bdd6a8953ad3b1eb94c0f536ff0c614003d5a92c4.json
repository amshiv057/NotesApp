{"ast":null,"code":"/**\n * Creates the `left` style value for an element that should be fixed to the\n * (outer) left of the container element. So the right bounds of the fixed\n * element will be equal to the left bounds of the container element (before the\n * xMargin is applied).\n * @internal\n */\nexport function getLeftCoord(_a) {\n  var xMargin = _a.xMargin,\n    elWidth = _a.elWidth,\n    initialX = _a.initialX,\n    containerRect = _a.containerRect;\n  return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left) - elWidth - xMargin;\n}\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * inner-left of the container element. So the left bounds of both the container\n * and fixed elements will overlap (before the xMargin is applied)\n * @internal\n */\nexport function getInnerLeftCoord(_a) {\n  var xMargin = _a.xMargin,\n    initialX = _a.initialX,\n    containerRect = _a.containerRect;\n  return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left) + xMargin;\n}\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * center of the container element. So the center point of the fixed element\n * should be the center point of the container element.\n *\n * Note: Unlike all the other horizontal positioning logic, the center position\n * does not use the xMargin.\n * @internal\n */\nexport function getCenterXCoord(_a) {\n  var elWidth = _a.elWidth,\n    initialX = _a.initialX,\n    containerRect = _a.containerRect;\n  var containerCenter = containerRect.width / 2;\n  var elementCenter = elWidth / 2;\n  return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left + containerCenter) - elementCenter;\n}\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * inner-right of the container element. So the right bounds for both the\n * container and fixed elements will overlap (before the xMargin is applied).\n * @internal\n */\nexport function getInnerRightCoord(_a) {\n  var xMargin = _a.xMargin,\n    elWidth = _a.elWidth,\n    initialX = _a.initialX,\n    containerRect = _a.containerRect;\n  return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left + containerRect.width) - elWidth - xMargin;\n}\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * (outer) right of the container element. So the left bounds of the fixed\n * element will overlap with the right bounds of the container element (before\n * the xMargin is applied).\n * @internal\n */\nexport function getRightCoord(_a) {\n  var xMargin = _a.xMargin,\n    initialX = _a.initialX,\n    containerRect = _a.containerRect;\n  return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left + containerRect.width) + xMargin;\n}\n/**\n * Creates the `top` style value for an element that should be fixed above the\n * container element. So the bottom bounds of the fixed element will overlap\n * with the top bounds of the container element (before the yMargin is applied).\n * @internal\n */\nexport function getAboveCoord(_a) {\n  var yMargin = _a.yMargin,\n    initialY = _a.initialY,\n    elHeight = _a.elHeight,\n    containerRect = _a.containerRect;\n  return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top) - elHeight - yMargin;\n}\n/**\n * Creates the `top` style value for an element that should be fixed to the top\n * of the container element. So the top bounds for both the container and fixed\n * elements will overlap (before the yMargin is applied).\n * @internal\n */\nexport function getTopCoord(_a) {\n  var yMargin = _a.yMargin,\n    initialY = _a.initialY,\n    containerRect = _a.containerRect;\n  return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top) + yMargin;\n}\n/**\n * Creates the `top` style value for an element that should be fixed vertically\n * centered relative to the container element. So the vertical center point for\n * the fixed element should overlap the vertical center point of the container\n * element.\n *\n * Note: Unlike all the other vertical positioning logic, the center position\n * does not use the yMargin.\n */\nexport function getCenterYCoord(_a) {\n  var elHeight = _a.elHeight,\n    initialY = _a.initialY,\n    containerRect = _a.containerRect;\n  var containerCenter = containerRect.height / 2;\n  var elementCenter = elHeight / 2;\n  return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top + containerCenter) - elementCenter;\n}\n/**\n * Creates the `top` style value for an element that should be fixed to the\n * bottom of the container element. So the top bounds of the fixed element\n * should overlap the bottom bounds of the container element (before the yMargin\n * is applied).\n * @internal\n */\nexport function getBottomCoord(_a) {\n  var yMargin = _a.yMargin,\n    initialY = _a.initialY,\n    elHeight = _a.elHeight,\n    containerRect = _a.containerRect;\n  return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top + containerRect.height) - elHeight - yMargin;\n}\n/**\n * Creates the `top` style value for an element that should be fixed to the\n * bottom of the container element. So the bottom bounds of both the container\n * and fixed elements should overlap (before the yMargin is applied).\n * @internal\n */\nexport function getBelowCoord(_a) {\n  var yMargin = _a.yMargin,\n    initialY = _a.initialY,\n    containerRect = _a.containerRect;\n  return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top + containerRect.height) + yMargin;\n}","map":{"version":3,"names":["getLeftCoord","_a","xMargin","elWidth","initialX","containerRect","left","getInnerLeftCoord","getCenterXCoord","containerCenter","width","elementCenter","getInnerRightCoord","getRightCoord","getAboveCoord","yMargin","initialY","elHeight","top","getTopCoord","getCenterYCoord","height","getBottomCoord","getBelowCoord"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\utils\\src\\positioning\\getCoord.ts"],"sourcesContent":["export interface XCoordConfig {\n  xMargin: number;\n  elWidth: number;\n  initialX?: number;\n  containerRect: DOMRect;\n}\n\nexport interface YCoordConfig {\n  yMargin: number;\n  elHeight: number;\n  initialY?: number;\n  containerRect: DOMRect;\n}\n\ntype Left = number;\ntype Top = number;\n\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * (outer) left of the container element. So the right bounds of the fixed\n * element will be equal to the left bounds of the container element (before the\n * xMargin is applied).\n * @internal\n */\nexport function getLeftCoord({\n  xMargin,\n  elWidth,\n  initialX,\n  containerRect,\n}: XCoordConfig): Left {\n  return (initialX ?? containerRect.left) - elWidth - xMargin;\n}\n\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * inner-left of the container element. So the left bounds of both the container\n * and fixed elements will overlap (before the xMargin is applied)\n * @internal\n */\nexport function getInnerLeftCoord({\n  xMargin,\n  initialX,\n  containerRect,\n}: XCoordConfig): Left {\n  return (initialX ?? containerRect.left) + xMargin;\n}\n\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * center of the container element. So the center point of the fixed element\n * should be the center point of the container element.\n *\n * Note: Unlike all the other horizontal positioning logic, the center position\n * does not use the xMargin.\n * @internal\n */\nexport function getCenterXCoord({\n  elWidth,\n  initialX,\n  containerRect,\n}: XCoordConfig): Left {\n  const containerCenter = containerRect.width / 2;\n  const elementCenter = elWidth / 2;\n  return (initialX ?? containerRect.left + containerCenter) - elementCenter;\n}\n\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * inner-right of the container element. So the right bounds for both the\n * container and fixed elements will overlap (before the xMargin is applied).\n * @internal\n */\nexport function getInnerRightCoord({\n  xMargin,\n  elWidth,\n  initialX,\n  containerRect,\n}: XCoordConfig): Left {\n  return (\n    (initialX ?? containerRect.left + containerRect.width) - elWidth - xMargin\n  );\n}\n\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * (outer) right of the container element. So the left bounds of the fixed\n * element will overlap with the right bounds of the container element (before\n * the xMargin is applied).\n * @internal\n */\nexport function getRightCoord({\n  xMargin,\n  initialX,\n  containerRect,\n}: XCoordConfig): Left {\n  return (initialX ?? containerRect.left + containerRect.width) + xMargin;\n}\n\n/**\n * Creates the `top` style value for an element that should be fixed above the\n * container element. So the bottom bounds of the fixed element will overlap\n * with the top bounds of the container element (before the yMargin is applied).\n * @internal\n */\nexport function getAboveCoord({\n  yMargin,\n  initialY,\n  elHeight,\n  containerRect,\n}: YCoordConfig): Top {\n  return (initialY ?? containerRect.top) - elHeight - yMargin;\n}\n\n/**\n * Creates the `top` style value for an element that should be fixed to the top\n * of the container element. So the top bounds for both the container and fixed\n * elements will overlap (before the yMargin is applied).\n * @internal\n */\nexport function getTopCoord({\n  yMargin,\n  initialY,\n  containerRect,\n}: YCoordConfig): Top {\n  return (initialY ?? containerRect.top) + yMargin;\n}\n\n/**\n * Creates the `top` style value for an element that should be fixed vertically\n * centered relative to the container element. So the vertical center point for\n * the fixed element should overlap the vertical center point of the container\n * element.\n *\n * Note: Unlike all the other vertical positioning logic, the center position\n * does not use the yMargin.\n */\nexport function getCenterYCoord({\n  elHeight,\n  initialY,\n  containerRect,\n}: YCoordConfig): Top {\n  const containerCenter = containerRect.height / 2;\n  const elementCenter = elHeight / 2;\n  return (initialY ?? containerRect.top + containerCenter) - elementCenter;\n}\n\n/**\n * Creates the `top` style value for an element that should be fixed to the\n * bottom of the container element. So the top bounds of the fixed element\n * should overlap the bottom bounds of the container element (before the yMargin\n * is applied).\n * @internal\n */\nexport function getBottomCoord({\n  yMargin,\n  initialY,\n  elHeight,\n  containerRect,\n}: YCoordConfig): Top {\n  return (\n    (initialY ?? containerRect.top + containerRect.height) - elHeight - yMargin\n  );\n}\n\n/**\n * Creates the `top` style value for an element that should be fixed to the\n * bottom of the container element. So the bottom bounds of both the container\n * and fixed elements should overlap (before the yMargin is applied).\n * @internal\n */\nexport function getBelowCoord({\n  yMargin,\n  initialY,\n  containerRect,\n}: YCoordConfig): Top {\n  return (initialY ?? containerRect.top + containerRect.height) + yMargin;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}