{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport { nearest } from \"@react-md/utils\";\nimport { DEFAULT_SLIDER_MAX, DEFAULT_SLIDER_MIN, DEFAULT_SLIDER_STEP } from \"./constants\";\nimport { getJumpValue, getSteps } from \"./utils\";\nvar noop = function () {\n  // do nothing\n};\n/**\n * This hook is used to control the value and behavior of the `RangeSlider`\n * component. The first argument will contain the current slider value while the\n * second argument will be all the props required to control the `RangeSlider`\n * component.\n *\n * @param defaultValue - An optional default value to use. When omitted, this\n * will be the `[min, max]` values\n * @param options - An object containing the `min` and `max` values allowed for\n * the slider as well as a `step` to indicate valid values between the `min` and\n * `max`.\n * @returns an ordered list containing the current value followed by the\n * `RangeSlider` props\n * @remarks \\@since 2.5.0\n */\nexport function useRangeSlider(defaultValue, _a) {\n  var _b = _a === void 0 ? {} : _a,\n    _c = _b.min,\n    min = _c === void 0 ? DEFAULT_SLIDER_MIN : _c,\n    _d = _b.max,\n    max = _d === void 0 ? DEFAULT_SLIDER_MAX : _d,\n    _e = _b.step,\n    step = _e === void 0 ? DEFAULT_SLIDER_STEP : _e,\n    propJump = _b.jump,\n    _f = _b.updateOn,\n    updateOn = _f === void 0 ? \"change\" : _f,\n    _g = _b.onChange,\n    onChange = _g === void 0 ? noop : _g;\n  var jump = useMemo(function () {\n    return getJumpValue(min, max, step, propJump);\n  }, [min, max, step, propJump]);\n  // since the `currentValue` is a ref, this state is used to force a re-render\n  // to get the updated value from the ref.\n  var _h = __read(useState([]), 2),\n    hack = _h[1];\n  var _j = __read(useState(defaultValue !== null && defaultValue !== void 0 ? defaultValue : [min, max]), 2),\n    value = _j[0],\n    setValue = _j[1];\n  var currentValue = useRef(value);\n  var update = useCallback(function (_a) {\n    var index = _a.index,\n      type = _a.type;\n    /* istanbul ignore next */\n    if (process.env.NODE_ENV !== \"production\") {\n      if (index !== 0 && index !== 1) {\n        throw new TypeError(\"Thumb index must be 0 or 1.\");\n      }\n    }\n    setValue(function (_a) {\n      var _b = __read(_a, 2),\n        thumb1Value = _b[0],\n        thumb2Value = _b[1];\n      var value;\n      var minValue = min;\n      var maxValue = max;\n      if (index === 0) {\n        value = thumb1Value;\n        maxValue = thumb2Value - step;\n      } else {\n        value = thumb2Value;\n        minValue = thumb1Value + step;\n      }\n      switch (type) {\n        case \"min\":\n          value = minValue;\n          break;\n        case \"max\":\n          value = maxValue;\n          break;\n        case \"increment\":\n          value += step;\n          break;\n        case \"decrement\":\n          value -= step;\n          break;\n        case \"increment-jump\":\n          value += jump;\n          break;\n        case \"decrement-jump\":\n          value -= jump;\n          break;\n      }\n      value = Math.max(minValue, Math.min(maxValue, value));\n      return index === 0 ? [value, thumb2Value] : [thumb1Value, value];\n    });\n  }, [jump, max, min, step]);\n  var increment = useCallback(function (index) {\n    return update({\n      index: index,\n      type: \"increment\"\n    });\n  }, [update]);\n  var incrementJump = useCallback(function (index) {\n    return update({\n      index: index,\n      type: \"increment-jump\"\n    });\n  }, [update]);\n  var decrement = useCallback(function (index) {\n    return update({\n      index: index,\n      type: \"decrement\"\n    });\n  }, [update]);\n  var decrementJump = useCallback(function (index) {\n    return update({\n      index: index,\n      type: \"decrement-jump\"\n    });\n  }, [update]);\n  var minimum = useCallback(function (index) {\n    return update({\n      index: index,\n      type: \"min\"\n    });\n  }, [update]);\n  var maximum = useCallback(function (index) {\n    return update({\n      index: index,\n      type: \"max\"\n    });\n  }, [update]);\n  var persist = useCallback(function () {\n    var _a = __read(currentValue.current, 2),\n      prev1 = _a[0],\n      prev2 = _a[1];\n    if (prev1 === value[0] && prev2 === value[1]) {\n      return;\n    }\n    onChange(value);\n    currentValue.current = value;\n    hack([]);\n  }, [onChange, value]);\n  var prev = useRef({\n    min: min,\n    max: max,\n    step: step\n  });\n  useEffect(function () {\n    if (prev.current.min !== min || prev.current.max !== max || prev.current.step !== step) {\n      // ensure that if the `min`, `max`, or `step` value changes that the value\n      // is updated as well. Without this, there will be a runtime error if the\n      // value is not within the new range.\n      prev.current = {\n        min: min,\n        max: max,\n        step: step\n      };\n      var steps = getSteps(min, max, step);\n      var nextValue = [nearest(value[0], min, max, steps), nearest(value[1], min, max, steps)];\n      currentValue.current = nextValue;\n      setValue(nextValue);\n    }\n  }, [min, max, step, value]);\n  if (updateOn === \"change\" && currentValue.current !== value) {\n    currentValue.current = value;\n  }\n  return [currentValue.current, {\n    min: min,\n    max: max,\n    step: step,\n    value: value,\n    minimum: minimum,\n    maximum: maximum,\n    increment: increment,\n    incrementJump: incrementJump,\n    decrement: decrement,\n    decrementJump: decrementJump,\n    persist: persist,\n    setValue: setValue\n  }];\n}","map":{"version":3,"names":["useCallback","useEffect","useMemo","useRef","useState","nearest","DEFAULT_SLIDER_MAX","DEFAULT_SLIDER_MIN","DEFAULT_SLIDER_STEP","getJumpValue","getSteps","noop","useRangeSlider","defaultValue","_a","_b","_c","min","_d","max","_e","step","propJump","jump","_f","updateOn","_g","onChange","_h","__read","hack","_j","value","setValue","currentValue","update","index","type","process","env","NODE_ENV","TypeError","thumb1Value","thumb2Value","minValue","maxValue","Math","increment","incrementJump","decrement","decrementJump","minimum","maximum","persist","current","prev1","prev2","prev","steps","nextValue"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\form\\src\\slider\\useRangeSlider.ts"],"sourcesContent":["import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport { nearest } from \"@react-md/utils\";\n\nimport {\n  DEFAULT_SLIDER_MAX,\n  DEFAULT_SLIDER_MIN,\n  DEFAULT_SLIDER_STEP,\n} from \"./constants\";\nimport type {\n  DefinedSliderValueOptions,\n  RangeSliderControls,\n  RangeSliderDefaultValue,\n  RangeSliderValue,\n  SliderStepOptions,\n  ThumbIndex,\n} from \"./types\";\nimport { getJumpValue, getSteps } from \"./utils\";\n\nconst noop = (): void => {\n  // do nothing\n};\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\ninterface UpdateOptions {\n  /**\n   * The thumb index that is being updated.\n   */\n  index: ThumbIndex;\n\n  type:\n    | \"increment\"\n    | \"decrement\"\n    | \"min\"\n    | \"max\"\n    | \"increment-jump\"\n    | \"decrement-jump\";\n}\n\n/**\n * @remarks \\@since 2.5.0\n */\nexport interface UseRangeSliderOptions extends SliderStepOptions {\n  /**\n   * An optional callback that will be triggered when the value has changed when\n   * the `updateOn` behavior is set to `\"blur\"`. When the `updateOn` behavior is\n   * set to `\"change\"` (default), this will do nothing since the return value\n   * from the hook will always be the latest value.\n   */\n  onChange?(value: RangeSliderValue): void;\n}\n\n/**\n * @remarks \\@since 2.5.0\n */\nexport interface RangeSliderRequiredProps\n  extends RangeSliderControls,\n    DefinedSliderValueOptions {\n  /**\n   * The current value of the slider.\n   */\n  value: RangeSliderValue;\n}\n\n/**\n * @remarks \\@since 2.5.0\n */\nexport type RangeSliderValueReturnType = readonly [\n  RangeSliderValue,\n  RangeSliderRequiredProps\n];\n\n/**\n * This hook is used to control the value and behavior of the `RangeSlider`\n * component. The first argument will contain the current slider value while the\n * second argument will be all the props required to control the `RangeSlider`\n * component.\n *\n * @param defaultValue - An optional default value to use. When omitted, this\n * will be the `[min, max]` values\n * @param options - An object containing the `min` and `max` values allowed for\n * the slider as well as a `step` to indicate valid values between the `min` and\n * `max`.\n * @returns an ordered list containing the current value followed by the\n * `RangeSlider` props\n * @remarks \\@since 2.5.0\n */\nexport function useRangeSlider(\n  defaultValue?: RangeSliderDefaultValue,\n  {\n    min = DEFAULT_SLIDER_MIN,\n    max = DEFAULT_SLIDER_MAX,\n    step = DEFAULT_SLIDER_STEP,\n    jump: propJump,\n    updateOn = \"change\",\n    onChange = noop,\n  }: UseRangeSliderOptions = {}\n): RangeSliderValueReturnType {\n  const jump = useMemo(\n    () => getJumpValue(min, max, step, propJump),\n    [min, max, step, propJump]\n  );\n\n  // since the `currentValue` is a ref, this state is used to force a re-render\n  // to get the updated value from the ref.\n  const [, hack] = useState([]);\n  const [value, setValue] = useState<RangeSliderValue>(\n    defaultValue ?? [min, max]\n  );\n  const currentValue = useRef(value);\n\n  const update = useCallback(\n    ({ index, type }: UpdateOptions) => {\n      /* istanbul ignore next */\n      if (process.env.NODE_ENV !== \"production\") {\n        if (index !== 0 && index !== 1) {\n          throw new TypeError(\"Thumb index must be 0 or 1.\");\n        }\n      }\n\n      setValue(([thumb1Value, thumb2Value]) => {\n        let value: number;\n        let minValue = min;\n        let maxValue = max;\n        if (index === 0) {\n          value = thumb1Value;\n          maxValue = thumb2Value - step;\n        } else {\n          value = thumb2Value;\n          minValue = thumb1Value + step;\n        }\n\n        switch (type) {\n          case \"min\":\n            value = minValue;\n            break;\n          case \"max\":\n            value = maxValue;\n            break;\n          case \"increment\":\n            value += step;\n            break;\n          case \"decrement\":\n            value -= step;\n            break;\n          case \"increment-jump\":\n            value += jump;\n            break;\n          case \"decrement-jump\":\n            value -= jump;\n            break;\n        }\n\n        value = Math.max(minValue, Math.min(maxValue, value));\n\n        return index === 0 ? [value, thumb2Value] : [thumb1Value, value];\n      });\n    },\n    [jump, max, min, step]\n  );\n  const increment = useCallback(\n    (index: ThumbIndex) => update({ index, type: \"increment\" }),\n    [update]\n  );\n  const incrementJump = useCallback(\n    (index: ThumbIndex) => update({ index, type: \"increment-jump\" }),\n    [update]\n  );\n  const decrement = useCallback(\n    (index: ThumbIndex) => update({ index, type: \"decrement\" }),\n    [update]\n  );\n  const decrementJump = useCallback(\n    (index: ThumbIndex) => update({ index, type: \"decrement-jump\" }),\n    [update]\n  );\n  const minimum = useCallback(\n    (index: ThumbIndex) => update({ index, type: \"min\" }),\n    [update]\n  );\n  const maximum = useCallback(\n    (index: ThumbIndex) => update({ index, type: \"max\" }),\n    [update]\n  );\n\n  const persist = useCallback(() => {\n    const [prev1, prev2] = currentValue.current;\n    if (prev1 === value[0] && prev2 === value[1]) {\n      return;\n    }\n\n    onChange(value);\n    currentValue.current = value;\n    hack([]);\n  }, [onChange, value]);\n\n  const prev = useRef({ min, max, step });\n  useEffect(() => {\n    if (\n      prev.current.min !== min ||\n      prev.current.max !== max ||\n      prev.current.step !== step\n    ) {\n      // ensure that if the `min`, `max`, or `step` value changes that the value\n      // is updated as well. Without this, there will be a runtime error if the\n      // value is not within the new range.\n      prev.current = { min, max, step };\n      const steps = getSteps(min, max, step);\n      const nextValue: RangeSliderValue = [\n        nearest(value[0], min, max, steps),\n        nearest(value[1], min, max, steps),\n      ];\n      currentValue.current = nextValue;\n      setValue(nextValue);\n    }\n  }, [min, max, step, value]);\n\n  if (updateOn === \"change\" && currentValue.current !== value) {\n    currentValue.current = value;\n  }\n\n  return [\n    currentValue.current,\n    {\n      min,\n      max,\n      step,\n      value,\n      minimum,\n      maximum,\n      increment,\n      incrementJump,\n      decrement,\n      decrementJump,\n      persist,\n      setValue,\n    },\n  ];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}