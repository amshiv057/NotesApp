{"ast":null,"code":"export {};","map":{"version":3,"names":[],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\layout\\src\\types.ts"],"sourcesContent":["import type { ElementType, ReactNode } from \"react\";\nimport type { AppBarTitleProps } from \"@react-md/app-bar\";\nimport type { BaseTreeItem, TreeData } from \"@react-md/tree\";\nimport type { PropsWithRef } from \"@react-md/utils\";\n\n/**\n * Due to the limited screen size for phones, the layout only supports having\n * temporary navigation with an optional persistent mini navigation.\n *\n * A temporary navigation will create a `Sheet` that renders your navigation\n * items and will only become visible when the main `AppBarNav` component has\n * been clicked.  Once a navigation item within this sheet has been clicked, the\n * sheet will automatically close.\n *\n * A temporary mini navigation will extend the temporary navigation as well as\n * showing a persistent mini navigation that is icons only for different routes.\n */\nexport type SupportedPhoneLayout = \"temporary\" | \"temporary-mini\";\n\n/**\n * Since tablets have more real-estate than phones, they also support two more\n * types of navigation with a toggleable persistent navigation as well as a\n * persistent navigation.\n *\n * The toggleable navigation will not be visible until the `AppBarNav` component\n * has been clicked in the main fixed header. This sort of navigation will be\n * rendered inline with the rest of your content and will persist until the user\n * hides this sheet by clicking the close button within this sheet.\n *\n * The toggleable mini navigation is just an expansion of this by also allowing\n * a persistent mini navigation that will be covered when the toggleable\n * navigation becomes visible.\n */\nexport type SupportedTabletLayout =\n  | SupportedPhoneLayout\n  | \"toggleable\"\n  | \"toggleable-mini\";\n\n/**\n * Finally, when there is a lot of real estate, you can have three different\n * types of static navigation that will always be visible, can't be hidden, and\n * are rendered inline with the rest of your content.\n *\n * A floating navigation is a static sheet that will have a transparent\n * background and no elevation applied so it is really inline with the rest of\n * the content on your page. It will expand the entire viewport height except\n * ensuring that the main fixed header does not overlap the top of it.\n *\n * A clipped navigation is like the floating navigation except that it gains the\n * main surface background color and adds some default elevation to help draw\n * focus to itself.\n *\n * Finally, a full-height navigation will cover the entire viewport height and\n * shift the main fixed header so that the left edge of the header stops at the\n * right edge of the navigation.\n */\nexport type SupportedWideLayout =\n  | SupportedTabletLayout\n  | \"floating\"\n  | \"clipped\"\n  | \"full-height\";\n\n/**\n * The configuration for the layout based on media sizes.\n */\nexport interface LayoutConfiguration {\n  /**\n   * The type of layout to use when your app is viewed on a phone sized screen.\n   */\n  phoneLayout?: SupportedPhoneLayout;\n\n  /**\n   * The type of layout to use when your app is viewed on a portrait tabled\n   * sized screen.\n   */\n  tabletLayout?: SupportedTabletLayout;\n\n  /**\n   * The type of layout to use when your app is viewed on a landscape tablet\n   * sized screen.\n   */\n  landscapeTabletLayout?: SupportedWideLayout;\n\n  /**\n   * The type of layout to use when your app is viewed on a desktop sized\n   * screen.\n   */\n  desktopLayout?: SupportedWideLayout;\n\n  /**\n   * The type of layout to use when your app is viewed on a large desktop sized\n   * screen.\n   *\n   * Note: Unlike all the other layout types, this one will automatically\n   * inherit the `desktopLayout` if it is omitted.\n   */\n  largeDesktopLayout?: SupportedWideLayout;\n\n  /**\n   * This prop is used to be able to update the toggleable layouts to start\n   * visible/expanded instead of requiring the toggle button to be pressed.\n   *\n   * If this is:\n   * - `\"toggleable\"` - the `\"toggleable-mini\"` variant will still require a\n   *   button click to be visible\n   * - `\"toggleable-mini\"` - the `\"toggleable\"` variant will still require a\n   *   button click to be visible\n   * - `true` - both toggleable variants will start visible\n   * - `false | undefined` - both toggleable variants will require a button\n   *   click to be visible\n   *\n   * @remarks \\@since 2.6.0\n   */\n  defaultToggleableVisible?: boolean | \"toggleable\" | \"toggleable-mini\";\n}\n\n/**\n * This is the \"recommended\" layout navigation item configuration that works\n * pretty well out of the box for creating a navigation tree.\n */\nexport interface LayoutNavigationItem extends BaseTreeItem {\n  /**\n   * The children to display for each item. This **should** actually be a string\n   * unless you manually provide a `getTreeItemValue` prop and/or update the\n   * `valueKey` to be a key referencing a stringified value of this item so it\n   * can be keyboard searched.\n   *\n   * This is only optional by default in case you want to be able to render\n   * custom dividers or subheaders within your navigation tree. Otherwise, this\n   * should be required.\n   */\n  children?: ReactNode;\n\n  /**\n   * An optional link target. Example: \"_blank\".\n   */\n  target?: string;\n\n  /**\n   * If your routing library uses the `to` prop to render a link, this will be\n   * used and assume the tree item is a link component.\n   */\n  to?: string;\n\n  /**\n   * This will make the tree item a link component and set this to the `href`.\n   */\n  href?: string;\n\n  /**\n   * An optional icon to display to the left of the `children`. See the\n   * `ListItem` component for more details.\n   */\n  leftAddon?: ReactNode;\n\n  /**\n   * An optional `rel` attribute to apply when using rendering a link.\n   */\n  rel?: string;\n\n  /**\n   * The component that should be used to render the tree item content. This is\n   * normally a custom `Link` component if using a routing library.\n   *\n   * Note: You can always provide a `linkComponent` prop on the main `Layout`\n   * component instead which will be used whenever the `to` or `href` props\n   * exist on an item.\n   */\n  contentComponent?: ElementType;\n\n  /**\n   * Boolean if the item is just a placeholder `Divider` element. None of the\n   * other props will be used.\n   */\n  divider?: boolean;\n\n  /**\n   * Boolean if the item is just a placeholder `ListSubheader` element. None of\n   * the other props will be used other than `children` with the default item\n   * renderer.\n   */\n  subheader?: boolean;\n\n  /**\n   * Adding record syntax for the rest just to be safe.\n   */\n  [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n}\n\n/**\n * The layout navigation tree. It is recommended to set this up so that each\n * `itemId` within your tree is the route that the link should be. For example:\n *\n * ```ts\n * const navItems: LayoutNavigationTree = {\n *   \"/\": {\n *     itemId: \"/\",\n *     parentId: null,\n *     children: \"Home\",\n *     leftAddon: <HomeSVGIcon />,\n *     to: \"/\",\n *     contentComponent: Link,\n *   },\n *   \"/route-1\": {\n *     itemId: \"/route-1\",\n *     parentId: null,\n *     children: \"Route 1\",\n *     leftAddon: <TVSVGIcon />,\n *     to: \"/route-1\",\n *     contentComponent: Link,\n *   },\n *   \"/route-2\": {\n *     itemId: \"/route-2\",\n *     parentId: null,\n *     children: \"Route 2\",\n *     leftAddon: <AppsSVGIcon />,\n *     to: \"/route-2\",\n *     contentComponent: Link,\n *   },\n *   \"/route-3\": {\n *     itemId: \"/route-3\",\n *     parentId: null,\n *     children: \"Route 3\",\n *     leftAddon: <BookSVGIcon />,\n *     to: \"/route-3\",\n *     contentComponent: Link,\n *   },\n * };\n * ```\n *\n * This will work amazingly with the provided `useLayoutNavigation` hook.\n */\nexport type LayoutNavigationTree<\n  T extends BaseTreeItem = LayoutNavigationItem\n> = TreeData<T>;\n\nexport interface LayoutWithTitle {\n  /**\n   * A custom implementation for the main `AppBarTitle` within the `Layout` that\n   * will be used instead of the default `LayoutAppBarTitle` if it is not\n   * `undefined`. This means that if you don't want to have a title within the\n   * main `AppBar`, set this value to `null`.\n   *\n   * Using this prop will make the following props do nothing:\n   *\n   * - `title`\n   * - `titleProps`\n   */\n  customTitle?: ReactNode;\n\n  /**\n   * An optional main title to display in the `Layout`. This should normally be\n   * something like the page title since it will be rendered in the default\n   * `AppBar` for the `Layout`.\n   */\n  title?: ReactNode;\n\n  /**\n   * Any additional props that should be applied to the layout's default\n   * `AppBarTitle`.\n   */\n  titleProps?: PropsWithRef<\n    Omit<AppBarTitleProps, \"children\">,\n    HTMLHeadingElement\n  >;\n}\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}