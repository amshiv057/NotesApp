{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n/**\n * This hook is used to handle the different states for the text field based on\n * the current value and user interaction.\n *\n * @internal\n * @remarks \\@since 2.5.2\n */\nexport function useFieldStates(_a) {\n  var onBlur = _a.onBlur,\n    onFocus = _a.onFocus,\n    onChange = _a.onChange,\n    value = _a.value,\n    defaultValue = _a.defaultValue;\n  var _b = __read(useState(false), 2),\n    focused = _b[0],\n    setFocused = _b[1];\n  var _c = __read(useState(function () {\n      if (typeof value === \"undefined\") {\n        return typeof defaultValue !== \"undefined\" && defaultValue.length > 0;\n      }\n      return value.length > 0;\n    }), 2),\n    valued = _c[0],\n    setValued = _c[1];\n  var handleBlur = useCallback(function (event) {\n    if (onBlur) {\n      onBlur(event);\n    }\n    setFocused(false);\n    var input = event.currentTarget;\n    if (input.getAttribute(\"type\") === \"number\") {\n      input.checkValidity();\n      setValued(input.validity.badInput || (value !== null && value !== void 0 ? value : input.value).length > 0);\n    }\n  }, [onBlur, value]);\n  var handleFocus = useCallback(function (event) {\n    if (onFocus) {\n      onFocus(event);\n    }\n    setFocused(true);\n  }, [onFocus]);\n  var handleChange = useCallback(function (event) {\n    if (onChange) {\n      onChange(event);\n    }\n    var input = event.currentTarget;\n    if (input.getAttribute(\"type\") === \"number\") {\n      input.checkValidity();\n      /* istanbul ignore next */\n      if (input.validity.badInput) {\n        return;\n      }\n    }\n    setValued(input.value.length > 0);\n  }, [onChange]);\n  // another way to handle this could be to just make the `valued` state derived\n  // based on the `value`, but it gets wonky for number fields. This technically\n  // still fails right now for number fields if you don't use the\n  // `useNumberField` hook since the `value` will be set back to the empty\n  // string on invalid numbers.\n  var prevValue = useRef(value);\n  useEffect(function () {\n    if (prevValue.current !== value && typeof value === \"string\") {\n      prevValue.current = value;\n      setValued(value.length > 0);\n    }\n  }, [value]);\n  return {\n    valued: valued,\n    focused: focused,\n    onBlur: handleBlur,\n    onFocus: handleFocus,\n    onChange: handleChange\n  };\n}","map":{"version":3,"names":["useCallback","useEffect","useRef","useState","useFieldStates","_a","onBlur","onFocus","onChange","value","defaultValue","_b","__read","focused","setFocused","_c","length","valued","setValued","handleBlur","event","input","currentTarget","getAttribute","checkValidity","validity","badInput","handleFocus","handleChange","prevValue","current"],"sources":["E:\\WebDevelop\\React\\Project 07\\movies-app\\node_modules\\@react-md\\form\\src\\useFieldStates.ts"],"sourcesContent":["import type {\n  ChangeEvent,\n  ChangeEventHandler,\n  FocusEvent,\n  FocusEventHandler,\n} from \"react\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n\n/**\n * @internal\n * @remarks \\@since 2.5.2\n */\ntype FormElement = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;\n\n/**\n * @internal\n * @remarks \\@since 2.5.2\n */\ninterface EventHandlers<E extends FormElement> {\n  onBlur?: FocusEventHandler<E>;\n  onFocus?: FocusEventHandler<E>;\n  onChange?: ChangeEventHandler<E>;\n}\n\n/**\n * @internal\n * @remarks \\@since 2.5.2\n */\ninterface FieldStatesOptions<E extends FormElement> extends EventHandlers<E> {\n  value?: string | readonly string[];\n  defaultValue?: string | readonly string[];\n}\n\n/**\n * @internal\n * @remarks \\@since 2.5.2\n */\ninterface ReturnValue<E extends FormElement>\n  extends Required<EventHandlers<E>> {\n  /**\n   * Boolean if the TextField or TextArea current has a value with a `length > 0`\n   * so that any labels will correctly float above the text field. This will\n   * also make sure that number inputs will still be considered valued when\n   * there is a `badInput` validity error.\n   */\n  valued: boolean;\n\n  /**\n   * Boolean if the TextField or TextArea currently has focus.\n   */\n  focused: boolean;\n}\n\n/**\n * This hook is used to handle the different states for the text field based on\n * the current value and user interaction.\n *\n * @internal\n * @remarks \\@since 2.5.2\n */\nexport function useFieldStates<E extends FormElement>({\n  onBlur,\n  onFocus,\n  onChange,\n  value,\n  defaultValue,\n}: FieldStatesOptions<E>): ReturnValue<E> {\n  const [focused, setFocused] = useState(false);\n  const [valued, setValued] = useState(() => {\n    if (typeof value === \"undefined\") {\n      return typeof defaultValue !== \"undefined\" && defaultValue.length > 0;\n    }\n\n    return value.length > 0;\n  });\n\n  const handleBlur = useCallback(\n    (event: FocusEvent<E>) => {\n      if (onBlur) {\n        onBlur(event);\n      }\n\n      setFocused(false);\n      const input = event.currentTarget;\n      if (input.getAttribute(\"type\") === \"number\") {\n        input.checkValidity();\n        setValued(input.validity.badInput || (value ?? input.value).length > 0);\n      }\n    },\n    [onBlur, value]\n  );\n\n  const handleFocus = useCallback(\n    (event: FocusEvent<E>) => {\n      if (onFocus) {\n        onFocus(event);\n      }\n\n      setFocused(true);\n    },\n    [onFocus]\n  );\n\n  const handleChange = useCallback(\n    (event: ChangeEvent<E>) => {\n      if (onChange) {\n        onChange(event);\n      }\n\n      const input = event.currentTarget;\n      if (input.getAttribute(\"type\") === \"number\") {\n        input.checkValidity();\n        /* istanbul ignore next */\n        if (input.validity.badInput) {\n          return;\n        }\n      }\n\n      setValued(input.value.length > 0);\n    },\n    [onChange]\n  );\n\n  // another way to handle this could be to just make the `valued` state derived\n  // based on the `value`, but it gets wonky for number fields. This technically\n  // still fails right now for number fields if you don't use the\n  // `useNumberField` hook since the `value` will be set back to the empty\n  // string on invalid numbers.\n  const prevValue = useRef(value);\n  useEffect(() => {\n    if (prevValue.current !== value && typeof value === \"string\") {\n      prevValue.current = value;\n      setValued(value.length > 0);\n    }\n  }, [value]);\n\n  return {\n    valued,\n    focused,\n    onBlur: handleBlur,\n    onFocus: handleFocus,\n    onChange: handleChange,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}